<?php class InputFilter {	protected $tagsArray;	protected $attrArray;	protected $tagsMethod;	protected $attrMethod;	protected $xssAuto;	protected $tagBlacklist = array('applet', 'body', 'bgsound', 'base', 'basefont', 'embed', 'frame', 'frameset', 'head', 'html', 'id', 'iframe', 'ilayer', 'layer', 'link', 'meta', 'name', 'object', 'script', 'style', 'title', 'xml');	protected $attrBlacklist = array('action', 'background', 'codebase', 'dynsrc', 'lowsrc');	public function __construct($tagsArray = array(), $attrArray = array(), $tagsMethod = 0, $attrMethod = 0, $xssAuto = 1) {	for ($i = 0; $i < count($tagsArray); $i++) $tagsArray[$i] = strtolower($tagsArray[$i]);	for ($i = 0; $i < count($attrArray); $i++) $attrArray[$i] = strtolower($attrArray[$i]);	$this->tagsArray = (array) $tagsArray;	$this->attrArray = (array) $attrArray;	$this->tagsMethod = $tagsMethod;	$this->attrMethod = $attrMethod;	$this->xssAuto = $xssAuto;	}	public function process($source) {	if (is_array($source)) {	foreach($source as $key => $value)	if (is_string($value)) $source[$key] = $this->remove($this->decode($value));	return $source;	} else if (is_string($source)) {	return $this->remove($this->decode($source));	} else return $source;	}	protected function remove($source) {	$loopCounter=0;	while($source != $this->filterTags($source)) {	$source = $this->filterTags($source);	$loopCounter++;	}	return $source;	}	protected function filterTags($source) {	$preTag = NULL;	$postTag = $source;	$tagOpen_start = strpos($source, '<');	while($tagOpen_start !== FALSE) {	$preTag .= substr($postTag, 0, $tagOpen_start);	$postTag = substr($postTag, $tagOpen_start);	$fromTagOpen = substr($postTag, 1);	$tagOpen_end = strpos($fromTagOpen, '>');	if ($tagOpen_end === false) break;	$tagOpen_nested = strpos($fromTagOpen, '<');	if (($tagOpen_nested !== false) && ($tagOpen_nested < $tagOpen_end)) {	$preTag .= substr($postTag, 0, ($tagOpen_nested+1));	$postTag = substr($postTag, ($tagOpen_nested+1));	$tagOpen_start = strpos($postTag, '<');	continue;	}	$tagOpen_nested = (strpos($fromTagOpen, '<') + $tagOpen_start + 1);	$currentTag = substr($fromTagOpen, 0, $tagOpen_end);	$tagLength = strlen($currentTag);	if (!$tagOpen_end) {	$preTag .= $postTag;	$tagOpen_start = strpos($postTag, '<');	}	$tagLeft = $currentTag;	$attrSet = array();	$currentSpace = strpos($tagLeft, ' ');	if (substr($currentTag, 0, 1) == "/") {	$isCloseTag = TRUE;	list($tagName) = explode(' ', $currentTag);	$tagName = substr($tagName, 1);	} else {	$isCloseTag = FALSE;	list($tagName) = explode(' ', $currentTag);	}	if ((!preg_match("/^[a-z][a-z0-9]*$/i",$tagName)) || (!$tagName) || ((in_array(strtolower($tagName), $this->tagBlacklist)) && ($this->xssAuto))) {	$postTag = substr($postTag, ($tagLength + 2));	$tagOpen_start = strpos($postTag, '<');	continue;	}	while ($currentSpace !== FALSE) {	$fromSpace = substr($tagLeft, ($currentSpace+1));	$nextSpace = strpos($fromSpace, ' ');	$openQuotes = strpos($fromSpace, '"');	$closeQuotes = strpos(substr($fromSpace, ($openQuotes+1)), '"') + $openQuotes + 1;	if (strpos($fromSpace, '=') !== FALSE) {	if (($openQuotes !== FALSE) && (strpos(substr($fromSpace, ($openQuotes+1)), '"') !== FALSE))	$attr = substr($fromSpace, 0, ($closeQuotes+1));	else $attr = substr($fromSpace, 0, $nextSpace);	} else $attr = substr($fromSpace, 0, $nextSpace);	if (!$attr) $attr = $fromSpace;	$attrSet[] = $attr;	$tagLeft = substr($fromSpace, strlen($attr));	$currentSpace = strpos($tagLeft, ' ');	}	$tagFound = in_array(strtolower($tagName), $this->tagsArray);	if ((!$tagFound && $this->tagsMethod) || ($tagFound && !$this->tagsMethod)) {	if (!$isCloseTag) {	$attrSet = $this->filterAttr($attrSet);	$preTag .= '<' . $tagName;	for ($i = 0; $i < count($attrSet); $i++)	$preTag .= ' ' . $attrSet[$i];	if (strpos($fromTagOpen, "</" . $tagName)) $preTag .= '>';	else $preTag .= ' />'; } else $preTag .= '</' . $tagName . '>';	}	$postTag = substr($postTag, ($tagLength + 2));	$tagOpen_start = strpos($postTag, '<');	}	$preTag .= $postTag;	return $preTag;	}	protected function filterAttr($attrSet) {	$newSet = array();	for ($i = 0; $i <count($attrSet); $i++) {	if (!$attrSet[$i]) continue;	$attrSubSet = explode('=', trim($attrSet[$i]));	list($attrSubSet[0]) = explode(' ', $attrSubSet[0]);	if ((!eregi("^[a-z]*$",$attrSubSet[0])) || (($this->xssAuto) && ((in_array(strtolower($attrSubSet[0]), $this->attrBlacklist)) || (substr($attrSubSet[0], 0, 2) == 'on'))))	continue;	if ($attrSubSet[1]) {	$attrSubSet[1] = str_replace('&#', '', $attrSubSet[1]);	$attrSubSet[1] = preg_replace('/\s+/', '', $attrSubSet[1]);	$attrSubSet[1] = str_replace('"', '', $attrSubSet[1]);	if ((substr($attrSubSet[1], 0, 1) == "'") && (substr($attrSubSet[1], (strlen($attrSubSet[1]) - 1), 1) == "'"))	$attrSubSet[1] = substr($attrSubSet[1], 1, (strlen($attrSubSet[1]) - 2));	$attrSubSet[1] = stripslashes($attrSubSet[1]);	}	if (	((strpos(strtolower($attrSubSet[1]), 'expression') !== false) &&	(strtolower($attrSubSet[0]) == 'style')) ||	(strpos(strtolower($attrSubSet[1]), 'javascript:') !== false) ||	(strpos(strtolower($attrSubSet[1]), 'behaviour:') !== false) ||	(strpos(strtolower($attrSubSet[1]), 'vbscript:') !== false) ||	(strpos(strtolower($attrSubSet[1]), 'mocha:') !== false) ||	(strpos(strtolower($attrSubSet[1]), 'livescript:') !== false)	) continue;	$attrFound = in_array(strtolower($attrSubSet[0]), $this->attrArray);	if ((!$attrFound && $this->attrMethod) || ($attrFound && !$this->attrMethod)) {	if ($attrSubSet[1]) $newSet[] = $attrSubSet[0] . '="' . $attrSubSet[1] . '"';	else if ($attrSubSet[1] == "0") $newSet[] = $attrSubSet[0] . '="0"';	else $newSet[] = $attrSubSet[0] . '="' . $attrSubSet[0] . '"';	}	}	return $newSet;	}	protected function decode($source) {	$source = html_entity_decode($source, ENT_QUOTES, "ISO-8859-1");	$source = preg_replace('/&#(\d+);/me',"chr(\\1)", $source);	$source = preg_replace('/&#x([a-f0-9]+);/mei',"chr(0x\\1)", $source);	return $source;	}	public function safeSQL($source, &$connection) {	if (is_array($source)) {	foreach($source as $key => $value)	if (is_string($value)) $source[$key] = $this->quoteSmart($this->decode($value), $connection);	return $source;	} else if (is_string($source)) {	if (is_string($source)) return $this->quoteSmart($this->decode($source), $connection);	} else return $source;	}	protected function quoteSmart($source, &$connection) {	if (get_magic_quotes_gpc()) $source = stripslashes($source);	$source = $this->escapeString($source, $connection);	return $source;	}	protected function escapeString($string, &$connection) {	if (version_compare(phpversion(),"4.3.0", "<")) mysql_escape_string($string);	else mysql_real_escape_string($string);	return $string;	} } define('SERVICES_JSON_SLICE', 1); define('SERVICES_JSON_IN_STR', 2); define('SERVICES_JSON_IN_ARR', 3); define('SERVICES_JSON_IN_OBJ', 4); define('SERVICES_JSON_IN_CMT', 5); define('SERVICES_JSON_LOOSE_TYPE', 16); define('SERVICES_JSON_SUPPRESS_ERRORS', 32); class Services_JSON { function Services_JSON($use = 0) { $this->use = $use; } function utf162utf8($utf16) { if(function_exists('mb_convert_encoding')) { return mb_convert_encoding($utf16, 'UTF-8', 'UTF-16'); } $bytes = (ord($utf16{0}) << 8) | ord($utf16{1}); switch(true) { case ((0x7F & $bytes) == $bytes): return chr(0x7F & $bytes); case (0x07FF & $bytes) == $bytes: return chr(0xC0 | (($bytes >> 6) & 0x1F)) . chr(0x80 | ($bytes & 0x3F)); case (0xFFFF & $bytes) == $bytes: return chr(0xE0 | (($bytes >> 12) & 0x0F)) . chr(0x80 | (($bytes >> 6) & 0x3F)) . chr(0x80 | ($bytes & 0x3F)); } return ''; } function utf82utf16($utf8) { if(function_exists('mb_convert_encoding')) { return mb_convert_encoding($utf8, 'UTF-16', 'UTF-8'); } switch(strlen($utf8)) { case 1: return $utf8; case 2: return chr(0x07 & (ord($utf8{0}) >> 2)) . chr((0xC0 & (ord($utf8{0}) << 6)) | (0x3F & ord($utf8{1}))); case 3: return chr((0xF0 & (ord($utf8{0}) << 4)) | (0x0F & (ord($utf8{1}) >> 2))) . chr((0xC0 & (ord($utf8{1}) << 6)) | (0x7F & ord($utf8{2}))); } return ''; } function encode($var) { switch (gettype($var)) { case 'boolean': return $var ? 'true' : 'false'; case 'NULL': return 'null'; case 'integer': return (int) $var; case 'double': case 'float': return (float) $var; case 'string': $ascii = ''; $strlen_var = strlen($var); for ($c = 0; $c < $strlen_var; ++$c) { $ord_var_c = ord($var{$c}); switch (true) { case $ord_var_c == 0x08: $ascii .= '\b'; break; case $ord_var_c == 0x09: $ascii .= '\t'; break; case $ord_var_c == 0x0A: $ascii .= '\n'; break; case $ord_var_c == 0x0C: $ascii .= '\f'; break; case $ord_var_c == 0x0D: $ascii .= '\r'; break; case $ord_var_c == 0x22: case $ord_var_c == 0x2F: case $ord_var_c == 0x5C: $ascii .= '\\'.$var{$c}; break; case (($ord_var_c >= 0x20) && ($ord_var_c <= 0x7F)): $ascii .= $var{$c}; break; case (($ord_var_c & 0xE0) == 0xC0): $char = pack('C*', $ord_var_c, ord($var{$c + 1})); $c += 1; $utf16 = $this->utf82utf16($char); $ascii .= sprintf('\u%04s', bin2hex($utf16)); break; case (($ord_var_c & 0xF0) == 0xE0): $char = pack('C*', $ord_var_c, ord($var{$c + 1}), ord($var{$c + 2})); $c += 2; $utf16 = $this->utf82utf16($char); $ascii .= sprintf('\u%04s', bin2hex($utf16)); break; case (($ord_var_c & 0xF8) == 0xF0): $char = pack('C*', $ord_var_c, ord($var{$c + 1}), ord($var{$c + 2}), ord($var{$c + 3})); $c += 3; $utf16 = $this->utf82utf16($char); $ascii .= sprintf('\u%04s', bin2hex($utf16)); break; case (($ord_var_c & 0xFC) == 0xF8): $char = pack('C*', $ord_var_c, ord($var{$c + 1}), ord($var{$c + 2}), ord($var{$c + 3}), ord($var{$c + 4})); $c += 4; $utf16 = $this->utf82utf16($char); $ascii .= sprintf('\u%04s', bin2hex($utf16)); break; case (($ord_var_c & 0xFE) == 0xFC): $char = pack('C*', $ord_var_c, ord($var{$c + 1}), ord($var{$c + 2}), ord($var{$c + 3}), ord($var{$c + 4}), ord($var{$c + 5})); $c += 5; $utf16 = $this->utf82utf16($char); $ascii .= sprintf('\u%04s', bin2hex($utf16)); break; } } return '"'.$ascii.'"'; case 'array': if (is_array($var) && count($var) && (array_keys($var) !== range(0, sizeof($var) - 1))) { $properties = array_map(array($this, 'name_value'), array_keys($var), array_values($var)); foreach($properties as $property) { if(Services_JSON::isError($property)) { return $property; } } return '{' . join(',', $properties) . '}'; } $elements = array_map(array($this, 'encode'), $var); foreach($elements as $element) { if(Services_JSON::isError($element)) { return $element; } } return '[' . join(',', $elements) . ']'; case 'object': if( method_exists( $var, 'Services_JSON' ) ) return $this->encode( $var->Services_JSON() ); $vars = get_object_vars($var); $properties = array_map(array($this, 'name_value'), array_keys($vars), array_values($vars)); foreach($properties as $property) { if(Services_JSON::isError($property)) { return $property; } } return '{' . join(',', $properties) . '}'; default: return ($this->use & SERVICES_JSON_SUPPRESS_ERRORS) ? 'null' : new Services_JSON_Error(gettype($var)." can not be encoded as JSON string"); } } function name_value($name, $value) { $encoded_value = $this->encode($value); if(Services_JSON::isError($encoded_value)) { return $encoded_value; } return $this->encode(strval($name)) . ':' . $encoded_value; } function reduce_string($str) { $str = preg_replace(array( '#^\s*//(.+)$#m', '#^\s*/\*(.+)\*/#Us', '#/\*(.+)\*/\s*$#Us' ), '', $str); return trim($str); } function decode($str) { $str = $this->reduce_string($str); switch (strtolower($str)) { case 'true': return true; case 'false': return false; case 'null': return null; default: $m = array(); if (is_numeric($str)) { return ((float)$str == (integer)$str) ? (integer)$str : (float)$str; } elseif (preg_match('/^("|\').*(\1)$/s', $str, $m) && $m[1] == $m[2]) { $delim = substr($str, 0, 1); $chrs = substr($str, 1, -1); $utf8 = ''; $strlen_chrs = strlen($chrs); for ($c = 0; $c < $strlen_chrs; ++$c) { $substr_chrs_c_2 = substr($chrs, $c, 2); $ord_chrs_c = ord($chrs{$c}); switch (true) { case $substr_chrs_c_2 == '\b': $utf8 .= chr(0x08); ++$c; break; case $substr_chrs_c_2 == '\t': $utf8 .= chr(0x09); ++$c; break; case $substr_chrs_c_2 == '\n': $utf8 .= chr(0x0A); ++$c; break; case $substr_chrs_c_2 == '\f': $utf8 .= chr(0x0C); ++$c; break; case $substr_chrs_c_2 == '\r': $utf8 .= chr(0x0D); ++$c; break; case $substr_chrs_c_2 == '\\"': case $substr_chrs_c_2 == '\\\'': case $substr_chrs_c_2 == '\\\\': case $substr_chrs_c_2 == '\\/': if (($delim == '"' && $substr_chrs_c_2 != '\\\'') || ($delim == "'" && $substr_chrs_c_2 != '\\"')) { $utf8 .= $chrs{++$c}; } break; case preg_match('/\\\u[0-9A-F]{4}/i', substr($chrs, $c, 6)): $utf16 = chr(hexdec(substr($chrs, ($c + 2), 2))) . chr(hexdec(substr($chrs, ($c + 4), 2))); $utf8 .= $this->utf162utf8($utf16); $c += 5; break; case ($ord_chrs_c >= 0x20) && ($ord_chrs_c <= 0x7F): $utf8 .= $chrs{$c}; break; case ($ord_chrs_c & 0xE0) == 0xC0: $utf8 .= substr($chrs, $c, 2); ++$c; break; case ($ord_chrs_c & 0xF0) == 0xE0: $utf8 .= substr($chrs, $c, 3); $c += 2; break; case ($ord_chrs_c & 0xF8) == 0xF0: $utf8 .= substr($chrs, $c, 4); $c += 3; break; case ($ord_chrs_c & 0xFC) == 0xF8: $utf8 .= substr($chrs, $c, 5); $c += 4; break; case ($ord_chrs_c & 0xFE) == 0xFC: $utf8 .= substr($chrs, $c, 6); $c += 5; break; } } return $utf8; } elseif (preg_match('/^\[.*\]$/s', $str) || preg_match('/^\{.*\}$/s', $str)) { if ($str{0} == '[') { $stk = array(SERVICES_JSON_IN_ARR); $arr = array(); } else { if ($this->use & SERVICES_JSON_LOOSE_TYPE) { $stk = array(SERVICES_JSON_IN_OBJ); $obj = array(); } else { $stk = array(SERVICES_JSON_IN_OBJ); $obj = new stdClass(); } } array_push($stk, array('what' => SERVICES_JSON_SLICE, 'where' => 0, 'delim' => false)); $chrs = substr($str, 1, -1); $chrs = $this->reduce_string($chrs); if ($chrs == '') { if (reset($stk) == SERVICES_JSON_IN_ARR) { return $arr; } else { return $obj; } } $strlen_chrs = strlen($chrs); for ($c = 0; $c <= $strlen_chrs; ++$c) { $top = end($stk); $substr_chrs_c_2 = substr($chrs, $c, 2); if (($c == $strlen_chrs) || (($chrs{$c} == ',') && ($top['what'] == SERVICES_JSON_SLICE))) { $slice = substr($chrs, $top['where'], ($c - $top['where'])); array_push($stk, array('what' => SERVICES_JSON_SLICE, 'where' => ($c + 1), 'delim' => false)); if (reset($stk) == SERVICES_JSON_IN_ARR) { array_push($arr, $this->decode($slice)); } elseif (reset($stk) == SERVICES_JSON_IN_OBJ) { $parts = array(); if (preg_match('/^\s*(["\'].*[^\\\]["\'])\s*:\s*(\S.*),?$/Uis', $slice, $parts)) { $key = $this->decode($parts[1]); $val = $this->decode($parts[2]); if ($this->use & SERVICES_JSON_LOOSE_TYPE) { $obj[$key] = $val; } else { $obj->$key = $val; } } elseif (preg_match('/^\s*(\w+)\s*:\s*(\S.*),?$/Uis', $slice, $parts)) { $key = $parts[1]; $val = $this->decode($parts[2]); if ($this->use & SERVICES_JSON_LOOSE_TYPE) { $obj[$key] = $val; } else { $obj->$key = $val; } } } } elseif ((($chrs{$c} == '"') || ($chrs{$c} == "'")) && ($top['what'] != SERVICES_JSON_IN_STR)) { array_push($stk, array('what' => SERVICES_JSON_IN_STR, 'where' => $c, 'delim' => $chrs{$c})); } elseif (($chrs{$c} == $top['delim']) && ($top['what'] == SERVICES_JSON_IN_STR) && ((strlen(substr($chrs, 0, $c)) - strlen(rtrim(substr($chrs, 0, $c), '\\'))) % 2 != 1)) { array_pop($stk); } elseif (($chrs{$c} == '[') && in_array($top['what'], array(SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ))) { array_push($stk, array('what' => SERVICES_JSON_IN_ARR, 'where' => $c, 'delim' => false)); } elseif (($chrs{$c} == ']') && ($top['what'] == SERVICES_JSON_IN_ARR)) { array_pop($stk); } elseif (($chrs{$c} == '{') && in_array($top['what'], array(SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ))) { array_push($stk, array('what' => SERVICES_JSON_IN_OBJ, 'where' => $c, 'delim' => false)); } elseif (($chrs{$c} == '}') && ($top['what'] == SERVICES_JSON_IN_OBJ)) { array_pop($stk); } elseif (($substr_chrs_c_2 == '') && ($top['what'] == SERVICES_JSON_IN_CMT)) { array_pop($stk); $c++; for ($i = $top['where']; $i <= $c; ++$i) $chrs = substr_replace($chrs, ' ', $i, 1); } } if (reset($stk) == SERVICES_JSON_IN_ARR) { return $arr; } elseif (reset($stk) == SERVICES_JSON_IN_OBJ) { return $obj; } } } } function isError($data, $code = null) { if (class_exists('pear')) { return PEAR::isError($data, $code); } elseif (is_object($data) && (get_class($data) == 'services_json_error' || is_subclass_of($data, 'services_json_error'))) { return true; } return false; } } if (class_exists('PEAR_Error')) { class Services_JSON_Error extends PEAR_Error { function Services_JSON_Error($message = 'unknown error', $code = null, $mode = null, $options = null, $userinfo = null) { parent::PEAR_Error($message, $code, $mode, $options, $userinfo); } } } else { class Services_JSON_Error { function Services_JSON_Error($message = 'unknown error', $code = null, $mode = null, $options = null, $userinfo = null) { } } } define( 'TAG_START_MARKER', '<' ); define( 'TAG_START_END_MARKER', '>' ); define( 'TAG_END_START_MARKER', '</' ); define( 'TAG_END_MARKER', '/>' ); class Replace { static public $tagReplaceCount = 0; static public $elementReplaceCount = 0;	private $tag = null;	private $handler = null;	private $handlerMethods = null;	public function setHandler( $handler )	{ if( !is_object( $handler ) ) return false; $this->handler = $handler; $this->handlerMethods = get_class_methods( $this->handler ); return true;	}	public function tag( $xml, $tagName=null, $argsAsArray=false )	{ while( true ) { if( !$this->handler || !$tagName && !$this->getTagName() ) return $xml; if( $tagName ) $this->setTagName( $tagName );	$start = strpos( $xml, TAG_START_MARKER.$this->getTagName() );	if( $start === false ) return $xml;	$end = strpos( $xml, TAG_END_MARKER, $start ) + strlen( TAG_END_MARKER );	if( $end < $start ) return $xml;	$tag = substr( $xml, $start, $end-$start );	$args = $this->getTagArgs( $tag );	$xml = str_replace( $tag, $this->call( $this->getTagName(), $args, $argsAsArray ), $xml );	self::$tagReplaceCount++; }	}	public function element( $xml, $tagName=null, $argsAsArray=false )	{ while( true ) { if( !$this->handler || !$tagName && !$this->getTagName() ) return $xml; if( $tagName ) $this->setTagName( $tagName ); $startMarker = TAG_START_MARKER.$this->getTagName();	$endMarker = TAG_END_START_MARKER.$this->getTagName().TAG_START_END_MARKER; $start = strpos( $xml, $startMarker );	if( $start === false ) return $xml;	$endTag = strpos( $xml, TAG_START_END_MARKER, $start ) + strlen( TAG_START_END_MARKER );	if( $endTag < $start ) return $xml;	$end = strpos( $xml, $endMarker, $start ) + strlen( $endMarker );	if( $end < $start ) return $xml;	$tag = substr( $xml, $start, $endTag-$start );	$args = $this->getTagArgs( $tag );	$element = substr( $xml, $start, $end-$start );	$content = $this->getElementContent( $element, $tag );	$args = array_merge( array( 'content'=>$content ), $args ); $xml = str_replace( $element, $this->call( $this->getTagName(), $args, $argsAsArray ), $xml ); self::$elementReplaceCount++; }	}	private function getTagArgs( $tag )	{ $tag = str_replace( TAG_START_MARKER.$this->getTagName(), '', $tag ); $tag = str_replace( TAG_END_MARKER, '', $tag ); $tag = str_replace( TAG_START_END_MARKER, '', $tag ); $result = array(); $join = ''; $args = explode( ' ', $tag ); foreach( $args as $arg ) { if( $join ) $arg = $join.' '.$arg; if( trim( $arg ) && strpos( $arg, '=' ) !== false ) { list( $key, $value ) = explode( '=', $arg, 2 ); if( substr( $value, -1 ) != '"' ) { $join = $key.'='.$value; } else { $result[$key] = str_replace( '"', '', $value ); $join = ''; } } } return $result;	}	private function getElementContent( $element, $tag )	{ $element = str_replace( $tag, '', $element ); $element = str_replace( TAG_END_START_MARKER.$this->getTagName().TAG_START_END_MARKER, '', $element ); return $element;	}	private function call( $method, $args=array(), $argsAsArray=false )	{ $method = str_replace( ':', '_', $method ); if( $argsAsArray ) $args = array( $args ); return call_user_func_array( array( $this->handler, $method ), $args );	}	private function setTagName( $tag ){ $this->tag = $tag; }	private function getTagName(){ return $this->tag; } } use Doctrine\Common\ClassLoader, Doctrine\ORM\Configuration, Doctrine\ORM\EntityManager, Doctrine\Common\Cache\ArrayCache, Doctrine\DBAL\Event\Listeners\MysqlSessionInit; use Doctrine\Common\Annotations\AnnotationReader; use Doctrine\Common\Annotations\AnnotationRegistry; use Doctrine\Common\Annotations\CachedReader; use Doctrine\Common\Cache\ApcCache; class izDoctrine extends Object {	static private $connections = array();	static private $classLoader = null;	static private $entityLoader = null;	private $config = null;	private $cache = null;	private $em = null;	private $signature = null;	public function init($dbConfig)	{	global $ds;	$this->signature = md5(serialize($dbConfig));	if (!empty(self::$connections[$this->signature])) return self::$connections[$this->signature];	if (!self::$entityLoader)	{ self::$entityLoader = new ClassLoader('Entity', config('root.abs')); self::$entityLoader->register();	}	$this->config = new Configuration;	if(ENVIRONMENT == 'development') $cache = new \Doctrine\Common\Cache\ArrayCache; else $cache = new \Doctrine\Common\Cache\ApcCache;	$reader = new CachedReader( new AnnotationReader(), $cache, $debug = true	);	AnnotationRegistry::registerFile(realpath(__DIR__."/../../../libs/doctrine2/lib/Doctrine/ORM/Mapping/Driver/DoctrineAnnotations.php"));	AnnotationRegistry::registerAutoloadNamespace( 'Gedmo\\Mapping\\Annotation', realpath(__DIR__.'/../../../libs/gedmo/lib')	);	$chain = new \Doctrine\ORM\Mapping\Driver\DriverChain();	$annotationDriver = new Doctrine\ORM\Mapping\Driver\AnnotationDriver($reader, array( realpath(__DIR__."/../../../Entity"), realpath(__DIR__."/../../../libs/gedmo/lib/Gedmo/Translatable/Entity"),	realpath(__DIR__."/../../../libs/gedmo/lib/Gedmo/Loggable/Entity"),	realpath(__DIR__."/../../../libs/gedmo/lib/Gedmo/Tree/Entity")	));	$chain->addDriver($annotationDriver, 'Gedmo\\Translatable\\Entity');	$chain->addDriver($annotationDriver, 'Gedmo\\Loggable\\Entity');	$chain->addDriver($annotationDriver, 'Gedmo\\Tree\\Entity');	$chain->addDriver($annotationDriver, 'Entity');	$this->config->setMetadataCacheImpl($cache);	$this->config->setMetadataDriverImpl($chain);	$this->config->setQueryCacheImpl($cache);	$this->config->setProxyDir(config('root.abs').config('root.proxy_folder') . DIRECTORY_SEPARATOR);	$this->config->setProxyNamespace('Proxies');	$this->config->setAutoGenerateProxyClasses(ENVIRONMENT == 'development');	$evm = new \Doctrine\Common\EventManager();	$evm->addEventSubscriber(new \Gedmo\Timestampable\TimestampableListener());	$evm->addEventSubscriber(new \Gedmo\Tree\TreeListener());	$evm->addEventSubscriber(new \Gedmo\Sluggable\SluggableListener());	$loggableListener = new \Gedmo\Loggable\LoggableListener();	$loggableListener->setUsername('admin');	$evm->addEventSubscriber($loggableListener);	$translatableListener = new \Gedmo\Translatable\TranslationListener();	$translatableListener->setTranslatableLocale(config('root.default_lang'));	$translatableListener->setDefaultLocale(config('root.default_lang'));	$evm->addEventSubscriber($translatableListener);	$this->em = EntityManager::create($dbConfig, $this->config, $evm);	$this->em->getEventManager()->addEventSubscriber(new MysqlSessionInit('utf8', 'utf8_unicode_ci'));	self::$connections[$this->signature] = $this;	return $this;	}	public function getEntityManager()	{	$conn = self::$connections[$this->signature];	return $conn->em;	}	public function getConfig()	{	$conn = self::$connections[$this->signature];	return $conn->config;	} } define( 'LOCALE_FILE_NOT_FOUND', '__file_not_found__'); class izLocale { static private $locale = null; static private $history = array( LOCALE_FILE_NOT_FOUND => array() ); private $defaultLocale = null; private $currentLocale = null; private $localeFolder = null; private $localePath = null; private $localeUrl = null; private $localeAppFolders = array(''); static public function getInstance() { if( self::$locale ) return self::$locale; self::$locale = new izLocale(); return self::$locale; } public function setLocaleDefault( $defaultLocale ) { $this->defaultLocale = $defaultLocale; } public function setLocaleCurrent( $currentLocale ) { $this->currentLocale = $currentLocale; } public function setLocaleFolder( $localeFolder ) { $this->localeFolder = $localeFolder; } public function setLocalePath( $path ) { $this->localePath = $path; } public function setLocaleUrl( $url ) { $this->localeUrl = $url; } public function setLocaleAppFolders( $folders ) { $this->localeAppFolders = $folders; } public function getLocaleCurrent() { return $this->currentLocale; } public function getLocaleDefault() { return $this->defaultLocale; } public function getLocaleFolder() { return $this->localeFolder; } public function getLocalePath() { return $this->localePath; } public function getLocaleUrl() { return $this->localeUrl; } public function getLocaleAppFolders() { return $this->localeAppFolders; } public function localePathUrl( $localePath, $locale=null ) { return $this->localePath( $localePath, $locale, true ); } public function localePath( $localePath, $locale=null, $isUrl=false ) { if( !$locale ) $locale = $this->getLocaleCurrent() ? $this->getLocaleCurrent() : $this->getLocaleDefault(); $key = $localePath.$locale.$isUrl; if( isset( self::$history[$key] ) ) return self::$history[$key]; if( isset( self::$history[LOCALE_FILE_NOT_FOUND][$key] ) ) return null;	$locales = array( $locale, $this->getLocaleDefault() ); $appFolders = $this->getLocaleAppFolders();	foreach( $appFolders as $folder )	{	foreach( $locales as $locale )	{ if( strlen( $folder ) && (substr($folder, strlen($folder)-1) !== DIRECTORY_SEPARATOR)) $folder.= DIRECTORY_SEPARATOR; $path = $folder.$this->getLocaleFolder().DIRECTORY_SEPARATOR.strtolower( $locale ).DIRECTORY_SEPARATOR.$localePath; if( is_readable( $this->getLocalePath().$path ) )	{ if( $isUrl ) return self::$history[$key] = $this->getLocaleUrl().str_replace( '\\', '/', $path ); return self::$history[$key] = $this->getLocalePath().$path;	}	}	}	self::$history[LOCALE_FILE_NOT_FOUND][$key] = $locale.DIRECTORY_SEPARATOR.$localePath; return null; } static public function getHistory() { return self::$history; } } function locale( $path, $url=false, $locale=null ) { return izLocale::getInstance()->localePath( $path, $locale, $url ); } class Benchmark { private $markers = array(); private $memory = array(); static private $self = null; static public function getInstance() { if( self::$self ) return self::$self; self::$self = new Benchmark(); return self::$self; } public function getAll() { return $this->markers; } public function setMark( $marker ) { $this->markers[$marker] = microtime( true ); $this->setMemory( $marker ); return $this->markers[$marker]; } public function getTime( $from, $to, $round=4 ) { $start = isset( $this->markers[$from] ) ? $this->markers[$from] : $this->setMark( $from ); $end = isset( $this->markers[$to] ) ? $this->markers[$to] : $this->setMark( $to ); return round( ( $end-$start ), $round ); } public function getMemory( $from, $to=null, $asBytes=true ) { $start = isset( $this->memory[$from] ) ? $this->memory[$from] : $this->setMemory( $from ); $end = isset( $this->memory[$to] ) ? $this->memory[$to] : ( is_string( $to ) ? $this->setMemory( $to ) : null ); $result = $end ? $end-$start : $start; return ( is_bool( $to ) && !$to ) || !$asBytes ? $result/1048576 : $result; } private function setMemory( $marker ) { return $this->memory[$marker] = memory_get_usage( true ); } } function benchmark( $marker=null, $to=null, $round=4 ) { if( !$marker ) return Benchmark::getInstance(); if( $to ) return Benchmark::getInstance()->getTime( $marker, $to, $round ); return Benchmark::getInstance()->setMark( $marker ); } class Cache extends Object {	public function fetch($cacheFile)	{	if (file_exists($cacheFile) and ((time()-filemtime($cacheFile)) < $this->getRefresh_seconds())){	$cacheContent = file_get_contents($cacheFile);	}	return $cacheContent;	}	public function save()	{	return $this->saveToFile();	}	private function saveToFile()	{	$file = fopen($this->getCache_file(),'w');	fwrite($file, $this->getContent());	fclose($file);	return true;	} } class acmeCache extends Object {	public function fetch($name, $refreshSeconds = 0){	if(!$GLOBALS['cache_active']) return false;	if(!$refreshSeconds) $refreshSeconds = 60;	$cacheFile = acmeCache::cachePath($name);	if(file_exists($cacheFile) and ((time()-filemtime($cacheFile))< $refreshSeconds)) $cacheContent = file_get_contents($cacheFile);	return $cacheContent;	}	public function save($name, $cacheContent){	if(!$GLOBALS['cache_active']) return;	$cacheFile = acmeCache::cachePath($name);	acmeCache::savetofile($cacheFile, $cacheContent);	}	function cachePath($name){	$cacheFolder = $GLOBALS['cache_folder'];	if(!$cacheFolder) $cacheFolder = trim($_SERVER['DOCUMENT_ROOT'],'/').'/cache/';	return $cacheFolder . md5(strtolower(trim($name))) . '.cache';	}	function savetofile($filename, $data){	$dir = trim(dirname($filename),'/').'/';	acmeCache::forceDirectory($dir);	$file = fopen($filename, 'w');	fwrite($file, $data); fclose($file);	}	function forceDirectory($dir){	return is_dir($dir) or (acmeCache::forceDirectory(dirname($dir)) and mkdir($dir, 0777));	} } class Cookie extends Object { private $stored = false; private $instance = 'object-cookie-root'; private $lifeTime = null; private $path = '/'; private $domain = null; private $secure = null; public function setCookieControls( $lifeTime, $path='/', $domain=null, $secure=null ) { if( $this->stored ) trigger_error( 'Cookie ERROR, cannot set Cookie Controls after "Cookie::store()" has been called', E_USER_ERROR ); $this->lifeTime = $lifeTime; $this->path = $path; $this->domain = $domain; $this->secure = $secure; return $this; } public function instance( $instance=null ) { if( !$instance ) return $this->instance; if( $this->stored ) trigger_error( 'Cookie ERROR, cannot set Instance after "Cookie::store()" has been called', E_USER_ERROR ); $this->instance = $instance; if( !isset( $_COOKIE[$this->instance()] ) ) return; $this->properties( $this->decode( $_COOKIE[$this->instance()] ) ); return $this; } public function store() { if( $this->stored ) return; if( headers_sent() ) trigger_error( 'Cookie ERROR, cannot call "Cookie::store()" after HTTP Headers have been sent.', E_USER_ERROR ); $ret = setrawcookie( $this->instance(), $this->encode( $this->properties() ), $this->lifeTime, $this->path, $this->domain, $this->secure ); if ($ret) izlog('Cookie set for '.$this->instance); $this->stored = true; return $this; } public function kill() { if( headers_sent() ) trigger_error( 'Cookie ERROR, cannot call "Cookie::kill()" after HTTP Headers have been sent.', E_USER_ERROR ); setrawcookie( $this->instance(), '', time()-42000, $this->path, $this->domain, $this->secure ); $this->properties( array() ); $this->stored = true; return $this; } protected function encode( $data ) { $data = $this->http_build_query( $data ); $data = base64_encode( $data ); return $data; } protected function decode( $data ) { $data = base64_decode( $data ); parse_str( $data, $result ); return $result; } public function __set( $key, $value ) { if( $value && !is_scalar( $value ) ) trigger_error( 'Cookie ERROR, Cookie can only contain integer, float, string or boolean values.', E_USER_ERROR ); if( $this->stored ) trigger_error( 'Cookie ERROR, cannot set data after "Cookie::store()" has been called', E_USER_ERROR ); parent::__set( $key, $value ); } function http_build_query( $formdata, $numeric_prefix = null, $key = null ) { $res = array(); foreach ((array)$formdata as $k=>$v) { $tmp_key = urlencode(is_int($k) ? $numeric_prefix.$k : $k); if ($key) { $tmp_key = $key.'['.$tmp_key.']'; } if ( is_array($v) || is_object($v) ) { $res[] = http_build_query($v, null, $tmp_key); } else { $res[] = $tmp_key."=".urlencode($v); } } return implode("&", $res); } } class Curl extends Object { private $handle = null; private $count = 0; private $stack = array(); public function get( $url, $type='string' ) { return $this->post( $url, null, $type ); } public function post( $url, $postArgs=null, $type='string' ) { $args = func_get_args(); $curlKey = implode( '', $args ); if( !$this->hasCurlKey( $curlKey ) ) { $curl = curl_init(); curl_setopt( $curl, CURLOPT_URL, $url ); curl_setopt( $curl, CURLOPT_HEADER, false ); curl_setopt( $curl, CURLOPT_RETURNTRANSFER, true ); curl_setopt( $curl, CURLOPT_FOLLOWLOCATION, true ); curl_setopt( $curl, CURLOPT_MAXREDIRS, 3 ); if( $postArgs ) { curl_setopt( $curl, CURLOPT_POST, true ); curl_setopt( $curl, CURLOPT_POSTFIELDS, $postArgs ); } $this->addCurlKey( $curlKey, $curl ); } return lambda( $this, 'call', $curlKey, $type ); } public function call( $curlKey, $type ) { if( is_resource( $this->stack[$curlKey] ) ) $this->process(); return $this->parse( $this->stack[$curlKey], $type ); } private function process() { $active = null; do { $mrc = curl_multi_exec( $this->gethandle(), $active ); } while( $mrc == CURLM_CALL_MULTI_PERFORM ); while( $active && $mrc == CURLM_OK ) { if( curl_multi_select( $this->gethandle() ) != -1 ) { do { $mrc = curl_multi_exec( $this->gethandle(), $active ); } while( $mrc == CURLM_CALL_MULTI_PERFORM ); } } foreach( $this->getStack() as $curlKey => $curl ) { if( is_resource( $curl ) ) $this->getContent( $curlKey, $curl ); } } private function getContent( $curlKey, $curl ) { $this->stack[$curlKey] = curl_multi_getcontent( $curl ); curl_multi_remove_handle( $this->handle, $curl ); $this->count--; if( $this->count == 0 ) curl_multi_close( $this->handle ); } private function getStack() { return $this->stack; } private function gethandle() { return $this->handle; } private function hasCurlKey( $curlKey ) { return isset( $this->stack[$curlKey] ); } private function addCurlKey( $curlKey, $curl ) { if( $this->count == 0 ) $this->handle = curl_multi_init(); curl_multi_add_handle( $this->handle, $curl ); $this->stack[$curlKey] = $curl; $this->count++; } private function parse( $data, $type='string' ) { switch( strtolower( $type ) ) { case 'sphp': return $this->unserializePhp( $data ); case 'json': return $this->unserializeJson( $data ); default: return $this->unserialize( $data ); } } public function unserializePhp( $data ) { if( $lambda = $this->__lambda( 'unserializephp' ) ) { return $lambda->call( $data ); } return @unserialize( $data ); } public function unserializeJson( $data ) { if( $lambda = $this->__lambda( 'unserializejson' ) ) { return $lambda->call( $data ); } return @json_decode( $data, true ); } public function unserialize( $data ) { if( $lambda = $this->__lambda( 'unserialize' ) ) { return $lambda->call( $data ); } return $data; } } define( 'EVENTS_CALLED', '__events_called__'); class Event extends Object { static private $listeners = array(); static private $history = array( EVENTS_CALLED => array() ); static private $map = array(); public function addListener( $listener, $listenerId ) { $listenerId = intval( $listenerId ); self::$listeners[$listenerId] = $listener; if( !isset( self::$history[$listener->toString()] ) ) self::$history[$listener->toString()] = array(); ksort( self::$listeners ); return true; } static public function fire() { $args = func_get_args(); $method = @$args[0]; $args = array_slice( $args, 1 ); self::$history[EVENTS_CALLED][] = $method; $postion = 0; while( $postion < count( self::$listeners ) ) { $keys = array_keys( self::$listeners ); if( method_exists( self::$listeners[$keys[$postion]], $method ) ) { self::$history[self::$listeners[$keys[$postion]]->toString()][] = $method; call_user_func_array( array( self::$listeners[$keys[$postion]], $method ), $args ); } $postion++; } } static public function getHistory() { return self::$history; } static public function getEventMap() { return self::$map; } } class http { var $log; var $dir; var $name; var $filename; var $url; var $port; var $verb; var $status; var $header; var $body; var $ttl; var $headers; var $postvars; var $xmlrequest; var $connect_timeout; var $data_ts; function http() { $this->log = "New http() object instantiated.<br />\n"; $this->connect_timeout = 30; $this->dir = realpath("./")."/"; $this->clean(); return true; } function fetch($url="", $ttl=0, $name="", $user="", $pwd="", $verb="GET") { $this->log .= "--------------------------------<br />fetch() called<br />\n"; $this->log .= "url: ".$url."<br />\n"; $this->status = ""; $this->header = ""; $this->body = ""; if (!$url) { $this->log .= "OOPS: You need to pass a URL!<br />"; return false; } $this->url = $url; $this->ttl = $ttl; $this->name = $name; $need_to_save = false; if ($this->ttl == "0") { if (!$fh = $this->getFromUrl($url, $user, $pwd, $verb)) { return false; } } else { if (strlen(trim($this->name)) == 0) { $this->name = MD5($url); } $this->filename = $this->dir."http_".$this->name; $this->log .= "Filename: ".$this->filename."<br />"; $this->getFile_ts(); if ($this->ttl == "daily") { if (date('Y-m-d',$this->data_ts) != date('Y-m-d',time())) { $this->log .= "cache has expired<br />"; if (!$fh = $this->getFromUrl($url, $user, $pwd, $verb)) { return false; } $need_to_save = true; if ($this->getFromUrl()) { return $this->saveToCache(); } } else { if (!$fh = $this->getFromCache()) { return false; } } } else { if ((time() - $this->data_ts) >= $this->ttl) { $this->log .= "cache has expired<br />"; if (!$fh = $this->getFromUrl($url, $user, $pwd)) { return false; } $need_to_save = true; } else { if (!$fh = $this->getFromCache()) { return false; } } } } $this->header = fgets($fh, 1024); $this->status = substr($this->header,9,3); while ((trim($line = fgets($fh, 1024)) != "") && (!feof($fh))) { $this->header .= $line; if ($this->status=="401" and strpos($line,"WWW-Authenticate: Basic realm=\"")===0) { fclose($fh); $this->log .= "Could not authenticate<br />\n"; return FALSE; } } while (!feof($fh)) { $this->body .= fgets($fh, 1024); } fclose($fh); if ($need_to_save) { $this->saveToCache(); } return $this->status; } function getFromUrl($url, $user="", $pwd="", $verb="GET") { $this->log .= "getFromUrl() called<br />"; preg_match("~([a-z]*: $protocol = $parts[1]; $server = $parts[2]; $port = $parts[4]; $path = $parts[5]; if ($port == "") { if (strtolower($protocol) == "https: $port = "443"; } else { $port = "80"; } } if ($path == "") { $path = "/"; } if (!$sock = @fsockopen(((strtolower($protocol) == "https: $this->log .= "Could not open connection. Error " .$errno.": ".$errstr."<br />\n"; return false; } $this->headers["Host"] = $server.":".$port; if ($user != "" && $pwd != "") { $this->log .= "Authentication will be attempted<br />\n"; $this->headers["Authorization"] = "Basic ".base64_encode($user.":".$pwd); } if (count($this->postvars) > 0) { $this->log .= "Variables will be POSTed<br />\n"; $request = "POST ".$path." HTTP/1.0\r\n"; $post_string = ""; foreach ($this->postvars as $key=>$value) { $post_string .= "&".urlencode($key)."=".urlencode($value); } $post_string = substr($post_string,1); $this->headers["Content-Type"] = "application/x-www-form-urlencoded"; $this->headers["Content-Length"] = strlen($post_string); } elseif (strlen($this->xmlrequest) > 0) { $this->log .= "XML request will be sent<br />\n"; $request = $verb." ".$path." HTTP/1.0\r\n"; $this->headers["Content-Length"] = strlen($this->xmlrequest); } else { $request = $verb." ".$path." HTTP/1.0\r\n"; } #echo "<br />request: ".$request; if (fwrite($sock, $request) === FALSE) { fclose($sock); $this->log .= "Error writing request type to socket<br />\n"; return false; } foreach ($this->headers as $key=>$value) { if (fwrite($sock, $key.": ".$value."\r\n") === FALSE) { fclose($sock); $this->log .= "Error writing headers to socket<br />\n"; return false; } } if (fwrite($sock, "\r\n") === FALSE) { fclose($sock); $this->log .= "Error writing end-of-line to socket<br />\n"; return false; } #echo "<br />post_string: ".$post_string; if (count($this->postvars) > 0) { if (fwrite($sock, $post_string."\r\n") === FALSE) { fclose($sock); $this->log .= "Error writing POST string to socket<br />\n"; return false; } } elseif (strlen($this->xmlrequest) > 0) { if (fwrite($sock, $this->xmlrequest."\r\n") === FALSE) { fclose($sock); $this->log .= "Error writing xml request string to socket<br />\n"; return false; } } return $sock; } function clean() { $this->status = ""; $this->header = ""; $this->body = ""; $this->headers = array(); $this->postvars = array(); if (isset($_SERVER['HTTP_USER_AGENT'])) { $this->headers["User-Agent"] = $_SERVER['HTTP_USER_AGENT']; } else { $this->headers["User-Agent"] = "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"; } if (substr($_SERVER['SERVER_PROTOCOL'],0,5) == "HTTPS") { $this->headers["Referer"] = "https: } else { $this->headers["Referer"] = "http: } } function getFromCache() { $this->log .= "getFromCache() called<br />"; if (!$fp=@fopen($this->filename,"r")) { $this->log .= "Could not open ".$this->filename."<br />"; return false; } return $fp; } function saveToCache() { $this->log .= "saveToCache() called<br />"; if (!$fp=@fopen($this->filename,"w")) { $this->log .= "Could not open ".$this->filename."<br />"; return false; } if (!@fwrite($fp,$this->header."\r\n".$this->body)) { $this->log .= "Could not write to ".$this->filename."<br />"; fclose($fp); return false; } fclose($fp); return true; } function getFile_ts() { $this->log .= "getFile_ts() called<br />"; if (!file_exists($this->filename)) { $this->data_ts = 0; $this->log .= $this->filename." does not exist<br />"; return false; } $this->data_ts = filemtime($this->filename); return true; } function table_into_array($rawHTML,$needle="",$needle_within=0,$allowed_tags="") { $upperHTML = strtoupper($rawHTML); $idx = 0; if (strlen($needle) > 0) { $needle = strtoupper($needle); $idx = strpos($upperHTML,$needle); if ($idx === false) { return false; } if ($needle_within == 1) { $cnt = 0; while(($cnt < 100) && (substr($upperHTML,$idx,6) != "<TABLE")) { $idx = strrpos(substr($upperHTML,0,$idx-1),"<"); $cnt++; } } } $aryData = array(); $rowIdx = 0; $tmp = strpos($upperHTML,"<TR",$idx); if ($tmp === false) { return false; } $tmp2 = strpos($upperHTML,"</TR>",$tmp); if ($tmp2 === false) { return false; } $row = substr($rawHTML,$tmp,$tmp2-$tmp); $pattern = "/<TH>|<TH\ |<TD>|<TD\ /"; preg_match($pattern,strtoupper($row),$matches); $hdrTag = $matches[0]; while ($tmp = strpos(strtoupper($row),$hdrTag) !== false) { $tmp = strpos(strtoupper($row),">",$tmp); if ($tmp === false) { return false; } $tmp++; $tmp2 = strpos(strtoupper($row),"</T"); $aryData[$rowIdx][] = trim(strip_tags(substr($row,$tmp,$tmp2-$tmp),$allowed_tags)); $row = substr($row,$tmp2+5); preg_match($pattern,strtoupper($row),$matches); $hdrTag = $matches[0]; } $idx = strpos($upperHTML,"</TR>",$idx)+5; $rowIdx++; $tmp = strpos($upperHTML,"<TR",$idx); if ($tmp === false) { return false; } $tmp2 = strpos($upperHTML,"</TABLE>",$idx); if ($tmp2 === false) { return false; } $table = substr($rawHTML,$tmp,$tmp2-$tmp); while ($tmp = strpos(strtoupper($table),"<TR") !== false) { $tmp2 = strpos(strtoupper($table),"</TR"); if ($tmp2 === false) { return false; } $row = substr($table,$tmp,$tmp2-$tmp); while ($tmp = strpos(strtoupper($row),"<TD") !== false) { $tmp = strpos(strtoupper($row),">",$tmp); if ($tmp === false) { return false; } $tmp++; $tmp2 = strpos(strtoupper($row),"</TD"); $aryData[$rowIdx][] = trim(strip_tags(substr($row,$tmp,$tmp2-$tmp),$allowed_tags)); $row = substr($row,$tmp2+5); } $table = substr($table,strpos(strtoupper($table),"</TR>")+5); $rowIdx++; } return $aryData; } function table_into_xml($rawHTML,$needle="",$needle_within=0,$allowedTags="") { if (!$aryTable = http::table_into_array($rawHTML,$needle,$needle_within,$allowedTags)) { return false; } $xml = "<?xml version=\"1.0\" standalone=\"yes\" \?\>\n"; $xml .= "<TABLE>\n"; $rowIdx = 0; foreach ($aryTable as $row) { $xml .= "\t<ROW id=\"".$rowIdx."\">\n"; $colIdx = 0; foreach ($row as $col) { $xml .= "\t\t<COL id=\"".$colIdx."\">".trim(utf8_encode(htmlspecialchars($col)))."</COL>\n"; $colIdx++; } $xml .= "\t</ROW>\n"; $rowIdx++; } $xml .= "</TABLE>"; return $xml; } } abstract class SeverityLevel {	const EMERGENCY = 0;	# system is unusable	const ALERT = 1;	# action must be taken immediately	const CRITICAL = 2;	# critical conditions	const ERROR = 3;	# error conditions	const WARNING = 4;	# warining conditions	const NOTICE = 5;	# normal but signification conditions	const INFORMATIONAL = 6;	# informational messages	const DEBUG = 7;	# debug-level messages } class IzLogger extends Object {	static private $logger = null;	static public function getInstance(){ if (!self::$logger) { self::$logger = object('IzLogger'); self::$logger->setFilePath(config('root.abs').config('root.log_folder').DIRECTORY_SEPARATOR.'izomi.log'); } return self::$logger; } public function log($message, $severity = SeverityLevel::INFORMATIONAL, $module = null, $info = null){ $time = izDateTime::timeStampToString();	$ip = $_SERVER['REMOTE_ADDR'];	$data = "{$ip}\t{$time}\t{$severity}\t{$message}\t{$module}\t{$info}";	file_put_contents(self::$logger->getFilePath(), "\n".$data, FILE_APPEND); } } class izLogging extends Object { static private $logger = null; static public function getInstance(){ if (!self::$logger) { self::$logger = object('izLogging'); self::$logger->setFilePath(config('root.abs').config('root.log_folder').DIRECTORY_SEPARATOR.'izomi.log'); } return self::$logger; } public function log($data){ @file_put_contents(self::$logger->getFilePath(), "\n".$data, FILE_APPEND); } } function izlog($data) { if (!is_string($data) && is_array($data)) $data = print_r($data, true); izLogging::getInstance()->log($data); } function logging($message, $severity = SeverityLevel::INFORMATIONAL, $module = null, $info = null) {	if (!is_string($info) && is_array($info)){	$json = new Services_JSON;	$info = $json->encode($info);	} IzLogger::getInstance()->log($message, $severity, $module, $info); } define( 'IZ_SESSION_ACTIVE', 'IZ_SESSION_ACTIVE' ); class Session extends Object { static private $stored = false; private $instance = 'object-session-root'; public function setCookieControls( $lifeTime, $path='/', $domain=null, $secure=null ) { if( @$_SESSION[IZ_SESSION_ACTIVE] ) trigger_error( 'Session ERROR, cannot set Cookie Controls after "Session::store()" has been called', E_USER_ERROR ); session_set_cookie_params( $lifeTime, $path, $domain, $secure ); } public function instance( $instance=null ) { if( !$instance ) return $this->instance; $this->instance = $instance; return $this; } public function store() { session_write_close(); self::$stored = true; $_SESSION[IZ_SESSION_ACTIVE] = 0; return $this; } public function kill( $all=false ) { $this->sessionStart(); unset( $_SESSION[$this->instance()] ); if( !$all ) return; $_SESSION = array(); if( isset( $_COOKIE[$this->getSessionName()] ) ) setcookie( $this->getSessionName(), '', time()-42000, '/' ); unset( $_REQUEST[$this->getSessionName()] ); unset( $_COOKIE[$this->getSessionName()] ); unset( $_POST[$this->getSessionName()] ); unset( $_GET[$this->getSessionName()] ); session_unset(); session_destroy(); return $this; } public function __set( $key, $value ) { $this->sessionStart(); $_SESSION[$this->instance()][$key] = $value; return $this; } public function __get( $key ) { $this->sessionStart(); if( isset( $_SESSION[$this->instance()] ) && isset( $_SESSION[$this->instance()][$key] ) ) return $_SESSION[$this->instance()][$key]; return parent::__get( $key ); } public function hasOwnProperty( $key ) { return isset( $_SESSION[$this->instance()] ) && isset( $_SESSION[$this->instance()][$key] ); } public function setSessionHandler( $handler ) { if( !is_subclass_of( $handler, 'SessionHandlerInterface' ) ) trigger_error( 'Session ERROR, "Session Handler" must use SessionHandlerInterface', E_USER_ERROR ); if( $this->detectSession() ) trigger_error( 'Session ERROR, cannot set Session Handler after Session has been started', E_USER_ERROR ); return session_set_save_handler( $handler->open(), $handler->close(), $handler->read(), $handler->write(), $handler->destory(), $handler->gc() ); } public function setSessionId( $id=null ) { if( $this->detectSession() ) return $this->regenerateSessionId( $id ); if( $id ) session_id( $id ); else session_id( $this->makeSessionId() ); return $this; } private function regenerateSessionId( $id=null ) { if( $this->detectSession() === false ) trigger_error( 'Session ERROR, cannot Regenerate a Session Id before the Session has been started', E_USER_ERROR ); $_SESSION_COPY = $_SESSION; $this->kill( true ); $this->sessionStart( $id ); $_SESSION = $_SESSION_COPY; return $this; } public function setSessionName( $name ) { if( $this->detectSession() ) trigger_error( 'Session ERROR, cannot set Session Name after Session has been started', E_USER_ERROR ); session_name( $name ); return $this; } public function getSessionName() { return session_name(); } public function getSessionId() { return session_id(); } public function sessionStart( $id=null ) { if( @$_SESSION[IZ_SESSION_ACTIVE] ) return; if( $this->detectSession() === false ) $this->setSessionId( $id ); session_cache_limiter( 'nocache' ); session_start();	header( 'P3P: CP="NOI ADM DEV PSAi COM NAV OUR OTRo STP IND DEM"' );	$_SESSION[IZ_SESSION_ACTIVE] = 1;	return $this; } private function detectSession() { if( isset( $_COOKIE[$this->getSessionName()] ) ) { return $_COOKIE[$this->getSessionName()]; } return false; } private function makeSessionId() { return md5( @$_SERVER['HTTP_USER_AGENT'].uniqid(rand()).microtime() ); } } interface SessionHandlerInterface { public function open( $save_path, $session_name ); public function close(); public function read( $id ); public function write( $id, $sess_data ); public function destory( $id ); public function gc( $maxlifetime ); } class Uri extends Object { public function __construct( $uri=null ) { if( $uri ) $this->set( $uri ); } public function getUserinfo() { return $this->user ? $this->user.':'.$this->pass : null; } public function getHostname() { return $this->host; } public function setHostname( $hostname ) { $this->host = $hostname; return $this; } public function getParameter( $key=null, $default=null ) { if( $key ) { return isset( $this->parameters[$key] ) ? $this->parameters[$key] : $default; } return $this->parameter; } public function getQuery( $key=null, $default=null ) { if( $key ) { return isset( $this->queries[$key] ) ? $this->queries[$key] : $default; } return $this->query; } public function setQuery( $query='' ) { $this->query = $query; $queries = array(); mb_parse_str( $this->query, $queries ); $this->queries = $queries; return $this; } public function getAuthority() { $authority = null; $authority = $this->getUserinfo() ? $this->getUserinfo().'@' : null; $authority.= $this->host; $authority.= $this->port ? ':'.$this->port : null; return $authority; } public function get() { $uri = null; $uri.= $this->scheme ? $this->scheme.':/'.'/' : null; $uri.= $this->getAuthority().$this->path.'/'; $uri.= $this->filename ? $this->filename : null; $uri.= $this->extension ? '.'.$this->extension : null; $uri.= $this->parameter ? ';'.$this->parameter : null; $uri.= $this->query ? '?'.$this->query : null; $uri.= $this->fragment ? '#'.$this->fragment : null; return $uri; } public function current() { $ssl = !empty( $_SERVER['HTTPS'] ) ? $_SERVER['HTTPS'] : 'off'; $uri = (($ssl == 'on') ? 'https' : 'http') . ':/'.'/'; $uri.= isset( $_SERVER['PHP_AUTH_USER'] ) ? $_SERVER['PHP_AUTH_USER'].':'.$_SERVER['PHP_AUTH_PW'].'@' : ''; $uri.= $_SERVER['SERVER_NAME']; $uri.= $_SERVER['SERVER_PORT'] != 80 ? ':'.$_SERVER['SERVER_PORT'] : ''; $uri.= $_SERVER['REQUEST_URI']; $this->set( $uri ); return $this; } public function set( $uri=null ) { $this->properties( parse_url( $uri ) ); $parts = explode( ';', basename( $this->path ), 2 ); $this->path = dirname( $this->path ); $this->filename = @$parts[0]; $this->parameter = @$parts[1]; $parts = pathinfo( $this->filename ); $this->filename = @$parts['filename']; $this->extension = @$parts['extension']; if( $this->filename && !$this->extension ) { $this->path.= '/'.$this->filename; $this->filename = ''; } $parameters = array(); mb_parse_str( str_replace( ';', '&', $this->parameter ), $parameters ); $this->parameters = $parameters; $this->setQuery( $this->query ); return $this; } static public function encode( $plainText ) { return strtr( base64_encode( $plainText ), '+/=', '-_,' ); } static public function decode( $base64url ) { return base64_decode( strtr( $base64url, '-_,', '+/=' ) ); } } class UUID { const UUID_TIME = 1; const UUID_NAME_MD5 = 3; const UUID_RANDOM = 4; const UUID_NAME_SHA1 = 5; const FMT_FIELD = 100; const FMT_STRING = 101; const FMT_BINARY = 102; const FMT_QWORD = 1; const FMT_DWORD = 2; const FMT_WORD = 4; const FMT_SHORT = 8; const FMT_BYTE = 16; const FMT_DEFAULT = 16; static private $m_uuid_field = array( 'time_low' => 0, 'time_mid' => 0, 'time_hi' => 0, 'clock_seq_hi' => 0, 'clock_seq_low' => 0, 'node' => array() ); static private $m_generate = array( self::UUID_TIME => "generateTime", self::UUID_RANDOM => "generateRandom", self::UUID_NAME_MD5 => "generateNameMD5", self::UUID_NAME_SHA1 => "generateNameSHA1" ); static private $m_convert = array( self::FMT_FIELD => array( self::FMT_BYTE => "conv_field2byte", self::FMT_STRING => "conv_field2string", self::FMT_BINARY => "conv_field2binary" ), self::FMT_BYTE => array( self::FMT_FIELD => "conv_byte2field", self::FMT_STRING => "conv_byte2string", self::FMT_BINARY => "conv_byte2binary" ), self::FMT_STRING => array( self::FMT_BYTE => "conv_string2byte", self::FMT_FIELD => "conv_string2field", self::FMT_BINARY => "conv_string2binary" ), ); static private function swap32($x) { return (($x & 0x000000ff) << 24) | (($x & 0x0000ff00) << 8) | (($x & 0x00ff0000) >> 8) | (($x & 0xff000000) >> 24); } static private function swap16($x) { return (($x & 0x00ff) << 8) | (($x & 0xff00) >> 8); } static private function detectFormat($src) { if (is_string($src)) return self::FMT_STRING; else if (is_array($src)) { $len = count($src); if ($len == 1 || ($len % 2) == 0) return $len; else return (-1); } else return self::FMT_BINARY; } static public function generate($type, $fmt = self::FMT_BYTE, $node = "", $ns = "") { $func = self::$m_generate[$type]; if (!isset($func)) return null; $conv = self::$m_convert[self::FMT_FIELD][$fmt]; $uuid = self::$func($ns, $node); return self::$conv($uuid); } static public function convert($uuid, $from, $to) { $conv = self::$m_convert[$from][$to]; if (!isset($conv)) return ($uuid); return (self::$conv($uuid)); } static private function generateRandom($ns, $node) { $uuid = self::$m_uuid_field; $uuid['time_hi'] = (4 << 12) | (mt_rand(0, 0x1000)); $uuid['clock_seq_hi'] = (1 << 7) | mt_rand(0, 128); $uuid['time_low'] = mt_rand(0, 0xffff) + (mt_rand(0, 0xffff) << 16); $uuid['time_mid'] = mt_rand(0, 0xffff); $uuid['clock_seq_low'] = mt_rand(0, 255); for ($i = 0; $i < 6; $i++) $uuid['node'][$i] = mt_rand(0, 255); return ($uuid); } static private function generateName($ns, $node, $hash, $version) { $ns_fmt = self::detectFormat($ns); $field = self::convert($ns, $ns_fmt, self::FMT_FIELD); $field['time_low'] = self::swap32($field['time_low']); $field['time_mid'] = self::swap16($field['time_mid']); $field['time_hi'] = self::swap16($field['time_hi']); $raw = self::convert($field, self::FMT_FIELD, self::FMT_BINARY); $raw .= $node; $val = $hash($raw, true); $tmp = unpack('C16', $val); foreach (array_keys($tmp) as $key) $byte[$key - 1] = $tmp[$key]; $field = self::conv_byte2field($byte); $field['time_low'] = self::swap32($field['time_low']); $field['time_mid'] = self::swap16($field['time_mid']); $field['time_hi'] = self::swap16($field['time_hi']); $field['clock_seq_hi'] &= 0x3f; $field['clock_seq_hi'] |= (1 << 7); $field['time_hi'] &= 0x0fff; $field['time_hi'] |= ($version << 12); return ($field); } static private function generateNameMD5($ns, $node) { return self::generateName($ns, $node, "md5", self::UUID_NAME_MD5); } static private function generateNameSHA1($ns, $node) { return self::generateName($ns, $node, "sha1", self::UUID_NAME_SHA1); } static private function generateTime($ns, $node) { $uuid = self::$m_uuid_field; $tp = gettimeofday(); $time = ($tp['sec'] * 10000000) + ($tp['usec'] * 10) + 0x01B21DD213814000; $uuid['time_low'] = $time & 0xffffffff; $high = intval($time / 0xffffffff); $uuid['time_mid'] = $high & 0xffff; $uuid['time_hi'] = (($high >> 16) & 0xfff) | (self::UUID_TIME << 12); $uuid['clock_seq_hi'] = 0x80 | mt_rand(0, 64); $uuid['clock_seq_low'] = mt_rand(0, 255); for ($i = 0; $i < 6; $i++) $uuid['node'][$i] = ord(substr($node, $i, 1)); return ($uuid); } static private function conv_field2byte($src) { $uuid[0] = ($src['time_low'] & 0xff000000) >> 24; $uuid[1] = ($src['time_low'] & 0x00ff0000) >> 16; $uuid[2] = ($src['time_low'] & 0x0000ff00) >> 8; $uuid[3] = ($src['time_low'] & 0x000000ff); $uuid[4] = ($src['time_mid'] & 0xff00) >> 8; $uuid[5] = ($src['time_mid'] & 0x00ff); $uuid[6] = ($src['time_hi'] & 0xff00) >> 8; $uuid[7] = ($src['time_hi'] & 0x00ff); $uuid[8] = $src['clock_seq_hi']; $uuid[9] = $src['clock_seq_low']; for ($i = 0; $i < 6; $i++) $uuid[10+$i] = $src['node'][$i]; return ($uuid); } static private function conv_field2string($src) { $str = sprintf( '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x', ($src['time_low']), ($src['time_mid']), ($src['time_hi']), $src['clock_seq_hi'], $src['clock_seq_low'], $src['node'][0], $src['node'][1], $src['node'][2], $src['node'][3], $src['node'][4], $src['node'][5]); return ($str); } static private function conv_field2binary($src) { $byte = self::conv_field2byte($src); return self::conv_byte2binary($byte); } static private function conv_byte2field($uuid) { $field = self::$m_uuid_field; $field['time_low'] = ($uuid[0] << 24) | ($uuid[1] << 16) | ($uuid[2] << 8) | $uuid[3]; $field['time_mid'] = ($uuid[4] << 8) | $uuid[5]; $field['time_hi'] = ($uuid[6] << 8) | $uuid[7]; $field['clock_seq_hi'] = $uuid[8]; $field['clock_seq_low'] = $uuid[9]; for ($i = 0; $i < 6; $i++) $field['node'][$i] = $uuid[10+$i]; return ($field); } static public function conv_byte2string($src) { $field = self::conv_byte2field($src); return self::conv_field2string($field); } static private function conv_byte2binary($src) { $raw = pack('C16', $src[0], $src[1], $src[2], $src[3], $src[4], $src[5], $src[6], $src[7], $src[8], $src[9], $src[10], $src[11], $src[12], $src[13], $src[14], $src[15]); return ($raw); } static private function conv_string2field($src) { $parts = sscanf($src, '%x-%x-%x-%x-%02x%02x%02x%02x%02x%02x'); $field = self::$m_uuid_field; $field['time_low'] = ($parts[0]); $field['time_mid'] = ($parts[1]); $field['time_hi'] = ($parts[2]); $field['clock_seq_hi'] = ($parts[3] & 0xff00) >> 8; $field['clock_seq_low'] = $parts[3] & 0x00ff; for ($i = 0; $i < 6; $i++) $field['node'][$i] = $parts[4+$i]; return ($field); } static private function conv_string2byte($src) { $field = self::conv_string2field($src); return self::conv_field2byte($field); } static private function conv_string2binary($src) { $byte = self::conv_string2byte($src); return self::conv_byte2binary($byte); } } function new_uuid() {	return UUID::generate(UUID::UUID_RANDOM, UUID::FMT_STRING); } class Validate extends Object { private $validate = array(); public function insertValidateRule( $key, $type='string', $canBeNull=true, $maxLength=0, $minLength=0 ) { if( $type instanceof ValidateRule ) $this->validate[$key] = $type; else $this->validate[$key] = new ValidateRule( $type, $canBeNull, $maxLength, $minLength ); } public function removeValidateRule( $key ) { if( isset( $this->validate[$key] ) ) unset( $this->validate[$key] ); } public function getValidateRule( $key ) { if( isset( $this->validate[$key] ) ) return $this->validate[$key]; return null; } public function isValid( $key=null ) { if( $key ) if( isset( $this->validate[$key] ) ) return $this->validate[$key]->validate( $this->__get( $key ) ); if( empty( $key ) ) foreach( $this->validate as $key => $rule ) if( !$rule->validate( $this->__get( $key ) ) ) return false; return true; } } class ValidateRule { private $type = null; private $canBeNull = null; private $maxLength = null; private $minLength = null; public function __construct( $type='string', $canBeNull=true, $maxLength=0, $minLength=0 ) { $this->setType( $type ); $this->setCanBeNull( $canBeNull ); $this->setMaxLength( $maxLength ); $this->setMinLength( $minLength ); } public function validate( $value ) { if( empty( $value ) && $this->getCanBeNull() ) return true; if( empty( $value ) && !$this->getCanBeNull() ) return false; $type = strtoupper( $this->getType() ); switch( $type ) { case 'INT':	case 'INTEGER':	$result = strcmp( $value, intval( $value ) ) === 0 ? true : false;	break;	case 'FLOAT':	case 'DOUBLE':	$result = strcmp( $value, floatval( $value ) ) === 0 ? true : false;	break;	case 'BOOL':	case 'BOOLEAN':	$result = strcmp( strtolower( $value ), 'true' ) === 0 || strcmp( strtolower( $value ), 'false' ) === 0 || $value == 1 || $value == 0 ? true : false;	break;	case 'ARRAY':	$result = is_array( $value );	break;	case 'STRING':	$result = is_string( $value );	break; case 'CHARS':	preg_match_all( '/[A-Z0-9_-]/i', $value, $match );	$match = implode( '', $match[0] );	$result = strcmp( $match, $value ) == 0 ? true : false;	break;	case 'DOMAIN':	preg_match_all( '/[A-Z0-9._-]/i', $value, $match );	$match = implode( '', $match[0] );	$result = strcmp( $match, $value ) == 0 ? true : false;	break;	case 'EMAIL': preg_match_all( '/^[A-Z0-9._-]+@[A-Z0-9][A-Z0-9.-]{0,61}[A-Z0-9]\.[A-Z.]{2,6}$/i', $value, $match );	$match = implode( '', $match[0] );	$result = strcmp( $match, $value ) == 0 ? true : false;	break;	case 'OBJECT':	$result = is_object( $value );	break;	case 'CAPTCHA':	session_start();	$result = strcmp(@$_SESSION['captcha'], $value) == 0 ? true : false;	break;	default:	$result = true;	break; } if( $result === false ) return false; if( $this->getMaxLength() > 0 && strlen( $value ) > $this->getMaxLength() ) return false; if( $this->getMinLength() > 0 && strlen( $value ) < $this->getMinLength() ) return false; return true; } public function setType( $type ){ $this->type = $type; } public function setCanBeNull( $canBeNull ){ $this->canBeNull = $canBeNull; } public function setMaxLength( $maxLength ){ $this->maxLength = $maxLength; } public function setMinLength( $minLength ){ $this->minLength = $minLength; } public function getType(){ return $this->type; } public function getCanBeNull(){ return $this->canBeNull; } public function getMaxLength(){ return $this->maxLength; } public function getMinLength(){ return $this->minLength; } } ?>