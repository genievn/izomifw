<?php   class Aop extends Object { static private $aop = null; static public function getInstance() { if( self::$aop ) return self::$aop; self::$aop = new Aop(); return self::$aop; } public function before( $object, $method, $args=array() ) { foreach( $this->lambdas as $key=>$pointCut ) { if( substr( $key, 0, 6 ) == 'before' ) $pointCut->call( array( $object, $method, &$args ), false ); } return null; } public function after( $object, $method, $args=array(), $result=null ) { foreach( $this->lambdas as $key=>$pointCut ) { if( substr( $key, 0, 5 ) == 'after' ) $result = $pointCut->call( array( $object, $method, &$args, &$result ), false ); } return $result; } } function aop() { return Aop::getInstance(); }    class InputFilter { protected $tagsArray; protected $attrArray; protected $tagsMethod; protected $attrMethod; protected $xssAuto; protected $tagBlacklist = array('applet', 'body', 'bgsound', 'base', 'basefont', 'embed', 'frame', 'frameset', 'head', 'html', 'id', 'iframe', 'ilayer', 'layer', 'link', 'meta', 'name', 'object', 'script', 'style', 'title', 'xml'); protected $attrBlacklist = array('action', 'background', 'codebase', 'dynsrc', 'lowsrc'); public function __construct($tagsArray = array(), $attrArray = array(), $tagsMethod = 0, $attrMethod = 0, $xssAuto = 1) { for ($i = 0; $i < count($tagsArray); $i++) $tagsArray[$i] = strtolower($tagsArray[$i]); for ($i = 0; $i < count($attrArray); $i++) $attrArray[$i] = strtolower($attrArray[$i]); $this->tagsArray = (array) $tagsArray; $this->attrArray = (array) $attrArray; $this->tagsMethod = $tagsMethod; $this->attrMethod = $attrMethod; $this->xssAuto = $xssAuto; } public function process($source) { if (is_array($source)) { foreach($source as $key => $value) if (is_string($value)) $source[$key] = $this->remove($this->decode($value)); return $source; } else if (is_string($source)) { return $this->remove($this->decode($source)); } else return $source; } protected function remove($source) { $loopCounter=0; while($source != $this->filterTags($source)) { $source = $this->filterTags($source); $loopCounter++; } return $source; } protected function filterTags($source) { $preTag = NULL; $postTag = $source; $tagOpen_start = strpos($source, '<'); while($tagOpen_start !== FALSE) { $preTag .= substr($postTag, 0, $tagOpen_start); $postTag = substr($postTag, $tagOpen_start); $fromTagOpen = substr($postTag, 1); $tagOpen_end = strpos($fromTagOpen, '>'); if ($tagOpen_end === false) break; $tagOpen_nested = strpos($fromTagOpen, '<'); if (($tagOpen_nested !== false) && ($tagOpen_nested < $tagOpen_end)) { $preTag .= substr($postTag, 0, ($tagOpen_nested+1)); $postTag = substr($postTag, ($tagOpen_nested+1)); $tagOpen_start = strpos($postTag, '<'); continue; } $tagOpen_nested = (strpos($fromTagOpen, '<') + $tagOpen_start + 1); $currentTag = substr($fromTagOpen, 0, $tagOpen_end); $tagLength = strlen($currentTag); if (!$tagOpen_end) { $preTag .= $postTag; $tagOpen_start = strpos($postTag, '<'); } $tagLeft = $currentTag; $attrSet = array(); $currentSpace = strpos($tagLeft, ' '); if (substr($currentTag, 0, 1) == "/") { $isCloseTag = TRUE; list($tagName) = explode(' ', $currentTag); $tagName = substr($tagName, 1); } else { $isCloseTag = FALSE; list($tagName) = explode(' ', $currentTag); } if ((!preg_match("/^[a-z][a-z0-9]*$/i",$tagName)) || (!$tagName) || ((in_array(strtolower($tagName), $this->tagBlacklist)) && ($this->xssAuto))) { $postTag = substr($postTag, ($tagLength + 2)); $tagOpen_start = strpos($postTag, '<'); continue; } while ($currentSpace !== FALSE) { $fromSpace = substr($tagLeft, ($currentSpace+1)); $nextSpace = strpos($fromSpace, ' '); $openQuotes = strpos($fromSpace, '"'); $closeQuotes = strpos(substr($fromSpace, ($openQuotes+1)), '"') + $openQuotes + 1; if (strpos($fromSpace, '=') !== FALSE) { if (($openQuotes !== FALSE) && (strpos(substr($fromSpace, ($openQuotes+1)), '"') !== FALSE)) $attr = substr($fromSpace, 0, ($closeQuotes+1)); else $attr = substr($fromSpace, 0, $nextSpace); } else $attr = substr($fromSpace, 0, $nextSpace); if (!$attr) $attr = $fromSpace; $attrSet[] = $attr; $tagLeft = substr($fromSpace, strlen($attr)); $currentSpace = strpos($tagLeft, ' '); } $tagFound = in_array(strtolower($tagName), $this->tagsArray); if ((!$tagFound && $this->tagsMethod) || ($tagFound && !$this->tagsMethod)) { if (!$isCloseTag) { $attrSet = $this->filterAttr($attrSet); $preTag .= '<' . $tagName; for ($i = 0; $i < count($attrSet); $i++) $preTag .= ' ' . $attrSet[$i]; if (strpos($fromTagOpen, "</" . $tagName)) $preTag .= '>'; else $preTag .= ' />'; } else $preTag .= '</' . $tagName . '>'; } $postTag = substr($postTag, ($tagLength + 2)); $tagOpen_start = strpos($postTag, '<'); } $preTag .= $postTag; return $preTag; } protected function filterAttr($attrSet) { $newSet = array(); for ($i = 0; $i <count($attrSet); $i++) { if (!$attrSet[$i]) continue; $attrSubSet = explode('=', trim($attrSet[$i])); list($attrSubSet[0]) = explode(' ', $attrSubSet[0]); if ((!eregi("^[a-z]*$",$attrSubSet[0])) || (($this->xssAuto) && ((in_array(strtolower($attrSubSet[0]), $this->attrBlacklist)) || (substr($attrSubSet[0], 0, 2) == 'on')))) continue; if ($attrSubSet[1]) { $attrSubSet[1] = str_replace('&#', '', $attrSubSet[1]); $attrSubSet[1] = preg_replace('/\s+/', '', $attrSubSet[1]); $attrSubSet[1] = str_replace('"', '', $attrSubSet[1]); if ((substr($attrSubSet[1], 0, 1) == "'") && (substr($attrSubSet[1], (strlen($attrSubSet[1]) - 1), 1) == "'")) $attrSubSet[1] = substr($attrSubSet[1], 1, (strlen($attrSubSet[1]) - 2)); $attrSubSet[1] = stripslashes($attrSubSet[1]); } if ( ((strpos(strtolower($attrSubSet[1]), 'expression') !== false) && (strtolower($attrSubSet[0]) == 'style')) || (strpos(strtolower($attrSubSet[1]), 'javascript:') !== false) || (strpos(strtolower($attrSubSet[1]), 'behaviour:') !== false) || (strpos(strtolower($attrSubSet[1]), 'vbscript:') !== false) || (strpos(strtolower($attrSubSet[1]), 'mocha:') !== false) || (strpos(strtolower($attrSubSet[1]), 'livescript:') !== false) ) continue; $attrFound = in_array(strtolower($attrSubSet[0]), $this->attrArray); if ((!$attrFound && $this->attrMethod) || ($attrFound && !$this->attrMethod)) { if ($attrSubSet[1]) $newSet[] = $attrSubSet[0] . '="' . $attrSubSet[1] . '"'; else if ($attrSubSet[1] == "0") $newSet[] = $attrSubSet[0] . '="0"'; else $newSet[] = $attrSubSet[0] . '="' . $attrSubSet[0] . '"'; } } return $newSet; } protected function decode($source) { $source = html_entity_decode($source, ENT_QUOTES, "ISO-8859-1"); $source = preg_replace('/&#(\d+);/me',"chr(\\1)", $source); $source = preg_replace('/&#x([a-f0-9]+);/mei',"chr(0x\\1)", $source); return $source; } public function safeSQL($source, &$connection) { if (is_array($source)) { foreach($source as $key => $value) if (is_string($value)) $source[$key] = $this->quoteSmart($this->decode($value), $connection); return $source; } else if (is_string($source)) { if (is_string($source)) return $this->quoteSmart($this->decode($source), $connection); } else return $source; } protected function quoteSmart($source, &$connection) { if (get_magic_quotes_gpc()) $source = stripslashes($source); $source = $this->escapeString($source, $connection); return $source; } protected function escapeString($string, &$connection) { if (version_compare(phpversion(),"4.3.0", "<")) mysql_escape_string($string); else mysql_real_escape_string($string); return $string; } }    define('SERVICES_JSON_SLICE', 1); define('SERVICES_JSON_IN_STR', 2); define('SERVICES_JSON_IN_ARR', 3); define('SERVICES_JSON_IN_OBJ', 4); define('SERVICES_JSON_IN_CMT', 5); define('SERVICES_JSON_LOOSE_TYPE', 16); define('SERVICES_JSON_SUPPRESS_ERRORS', 32); class Services_JSON { function Services_JSON($use = 0) { $this->use = $use; } function utf162utf8($utf16) { if(function_exists('mb_convert_encoding')) { return mb_convert_encoding($utf16, 'UTF-8', 'UTF-16'); } $bytes = (ord($utf16{0}) << 8) | ord($utf16{1}); switch(true) { case ((0x7F & $bytes) == $bytes): return chr(0x7F & $bytes); case (0x07FF & $bytes) == $bytes: return chr(0xC0 | (($bytes >> 6) & 0x1F)) . chr(0x80 | ($bytes & 0x3F)); case (0xFFFF & $bytes) == $bytes: return chr(0xE0 | (($bytes >> 12) & 0x0F)) . chr(0x80 | (($bytes >> 6) & 0x3F)) . chr(0x80 | ($bytes & 0x3F)); } return ''; } function utf82utf16($utf8) { if(function_exists('mb_convert_encoding')) { return mb_convert_encoding($utf8, 'UTF-16', 'UTF-8'); } switch(strlen($utf8)) { case 1: return $utf8; case 2: return chr(0x07 & (ord($utf8{0}) >> 2)) . chr((0xC0 & (ord($utf8{0}) << 6)) | (0x3F & ord($utf8{1}))); case 3: return chr((0xF0 & (ord($utf8{0}) << 4)) | (0x0F & (ord($utf8{1}) >> 2))) . chr((0xC0 & (ord($utf8{1}) << 6)) | (0x7F & ord($utf8{2}))); } return ''; } function encode($var) { switch (gettype($var)) { case 'boolean': return $var ? 'true' : 'false'; case 'NULL': return 'null'; case 'integer': return (int) $var; case 'double': case 'float': return (float) $var; case 'string': $ascii = ''; $strlen_var = strlen($var); for ($c = 0; $c < $strlen_var; ++$c) { $ord_var_c = ord($var{$c}); switch (true) { case $ord_var_c == 0x08: $ascii .= '\b'; break; case $ord_var_c == 0x09: $ascii .= '\t'; break; case $ord_var_c == 0x0A: $ascii .= '\n'; break; case $ord_var_c == 0x0C: $ascii .= '\f'; break; case $ord_var_c == 0x0D: $ascii .= '\r'; break; case $ord_var_c == 0x22: case $ord_var_c == 0x2F: case $ord_var_c == 0x5C: $ascii .= '\\'.$var{$c}; break; case (($ord_var_c >= 0x20) && ($ord_var_c <= 0x7F)): $ascii .= $var{$c}; break; case (($ord_var_c & 0xE0) == 0xC0): $char = pack('C*', $ord_var_c, ord($var{$c + 1})); $c += 1; $utf16 = $this->utf82utf16($char); $ascii .= sprintf('\u%04s', bin2hex($utf16)); break; case (($ord_var_c & 0xF0) == 0xE0): $char = pack('C*', $ord_var_c, ord($var{$c + 1}), ord($var{$c + 2})); $c += 2; $utf16 = $this->utf82utf16($char); $ascii .= sprintf('\u%04s', bin2hex($utf16)); break; case (($ord_var_c & 0xF8) == 0xF0): $char = pack('C*', $ord_var_c, ord($var{$c + 1}), ord($var{$c + 2}), ord($var{$c + 3})); $c += 3; $utf16 = $this->utf82utf16($char); $ascii .= sprintf('\u%04s', bin2hex($utf16)); break; case (($ord_var_c & 0xFC) == 0xF8): $char = pack('C*', $ord_var_c, ord($var{$c + 1}), ord($var{$c + 2}), ord($var{$c + 3}), ord($var{$c + 4})); $c += 4; $utf16 = $this->utf82utf16($char); $ascii .= sprintf('\u%04s', bin2hex($utf16)); break; case (($ord_var_c & 0xFE) == 0xFC): $char = pack('C*', $ord_var_c, ord($var{$c + 1}), ord($var{$c + 2}), ord($var{$c + 3}), ord($var{$c + 4}), ord($var{$c + 5})); $c += 5; $utf16 = $this->utf82utf16($char); $ascii .= sprintf('\u%04s', bin2hex($utf16)); break; } } return '"'.$ascii.'"'; case 'array': if (is_array($var) && count($var) && (array_keys($var) !== range(0, sizeof($var) - 1))) { $properties = array_map(array($this, 'name_value'), array_keys($var), array_values($var)); foreach($properties as $property) { if(Services_JSON::isError($property)) { return $property; } } return '{' . join(',', $properties) . '}'; } $elements = array_map(array($this, 'encode'), $var); foreach($elements as $element) { if(Services_JSON::isError($element)) { return $element; } } return '[' . join(',', $elements) . ']'; case 'object': if( method_exists( $var, 'Services_JSON' ) ) return $this->encode( $var->Services_JSON() ); $vars = get_object_vars($var); $properties = array_map(array($this, 'name_value'), array_keys($vars), array_values($vars)); foreach($properties as $property) { if(Services_JSON::isError($property)) { return $property; } } return '{' . join(',', $properties) . '}'; default: return ($this->use & SERVICES_JSON_SUPPRESS_ERRORS) ? 'null' : new Services_JSON_Error(gettype($var)." can not be encoded as JSON string"); } } function name_value($name, $value) { $encoded_value = $this->encode($value); if(Services_JSON::isError($encoded_value)) { return $encoded_value; } return $this->encode(strval($name)) . ':' . $encoded_value; } function reduce_string($str) { $str = preg_replace(array( '#^\s*//(.+)$#m', '#^\s*/\*(.+)\*/#Us', '#/\*(.+)\*/\s*$#Us' ), '', $str); return trim($str); } function decode($str) { $str = $this->reduce_string($str); switch (strtolower($str)) { case 'true': return true; case 'false': return false; case 'null': return null; default: $m = array(); if (is_numeric($str)) { return ((float)$str == (integer)$str) ? (integer)$str : (float)$str; } elseif (preg_match('/^("|\').*(\1)$/s', $str, $m) && $m[1] == $m[2]) { $delim = substr($str, 0, 1); $chrs = substr($str, 1, -1); $utf8 = ''; $strlen_chrs = strlen($chrs); for ($c = 0; $c < $strlen_chrs; ++$c) { $substr_chrs_c_2 = substr($chrs, $c, 2); $ord_chrs_c = ord($chrs{$c}); switch (true) { case $substr_chrs_c_2 == '\b': $utf8 .= chr(0x08); ++$c; break; case $substr_chrs_c_2 == '\t': $utf8 .= chr(0x09); ++$c; break; case $substr_chrs_c_2 == '\n': $utf8 .= chr(0x0A); ++$c; break; case $substr_chrs_c_2 == '\f': $utf8 .= chr(0x0C); ++$c; break; case $substr_chrs_c_2 == '\r': $utf8 .= chr(0x0D); ++$c; break; case $substr_chrs_c_2 == '\\"': case $substr_chrs_c_2 == '\\\'': case $substr_chrs_c_2 == '\\\\': case $substr_chrs_c_2 == '\\/': if (($delim == '"' && $substr_chrs_c_2 != '\\\'') || ($delim == "'" && $substr_chrs_c_2 != '\\"')) { $utf8 .= $chrs{++$c}; } break; case preg_match('/\\\u[0-9A-F]{4}/i', substr($chrs, $c, 6)): $utf16 = chr(hexdec(substr($chrs, ($c + 2), 2))) . chr(hexdec(substr($chrs, ($c + 4), 2))); $utf8 .= $this->utf162utf8($utf16); $c += 5; break; case ($ord_chrs_c >= 0x20) && ($ord_chrs_c <= 0x7F): $utf8 .= $chrs{$c}; break; case ($ord_chrs_c & 0xE0) == 0xC0: $utf8 .= substr($chrs, $c, 2); ++$c; break; case ($ord_chrs_c & 0xF0) == 0xE0: $utf8 .= substr($chrs, $c, 3); $c += 2; break; case ($ord_chrs_c & 0xF8) == 0xF0: $utf8 .= substr($chrs, $c, 4); $c += 3; break; case ($ord_chrs_c & 0xFC) == 0xF8: $utf8 .= substr($chrs, $c, 5); $c += 4; break; case ($ord_chrs_c & 0xFE) == 0xFC: $utf8 .= substr($chrs, $c, 6); $c += 5; break; } } return $utf8; } elseif (preg_match('/^\[.*\]$/s', $str) || preg_match('/^\{.*\}$/s', $str)) { if ($str{0} == '[') { $stk = array(SERVICES_JSON_IN_ARR); $arr = array(); } else { if ($this->use & SERVICES_JSON_LOOSE_TYPE) { $stk = array(SERVICES_JSON_IN_OBJ); $obj = array(); } else { $stk = array(SERVICES_JSON_IN_OBJ); $obj = new stdClass(); } } array_push($stk, array('what' => SERVICES_JSON_SLICE, 'where' => 0, 'delim' => false)); $chrs = substr($str, 1, -1); $chrs = $this->reduce_string($chrs); if ($chrs == '') { if (reset($stk) == SERVICES_JSON_IN_ARR) { return $arr; } else { return $obj; } } $strlen_chrs = strlen($chrs); for ($c = 0; $c <= $strlen_chrs; ++$c) { $top = end($stk); $substr_chrs_c_2 = substr($chrs, $c, 2); if (($c == $strlen_chrs) || (($chrs{$c} == ',') && ($top['what'] == SERVICES_JSON_SLICE))) { $slice = substr($chrs, $top['where'], ($c - $top['where'])); array_push($stk, array('what' => SERVICES_JSON_SLICE, 'where' => ($c + 1), 'delim' => false)); if (reset($stk) == SERVICES_JSON_IN_ARR) { array_push($arr, $this->decode($slice)); } elseif (reset($stk) == SERVICES_JSON_IN_OBJ) { $parts = array(); if (preg_match('/^\s*(["\'].*[^\\\]["\'])\s*:\s*(\S.*),?$/Uis', $slice, $parts)) { $key = $this->decode($parts[1]); $val = $this->decode($parts[2]); if ($this->use & SERVICES_JSON_LOOSE_TYPE) { $obj[$key] = $val; } else { $obj->$key = $val; } } elseif (preg_match('/^\s*(\w+)\s*:\s*(\S.*),?$/Uis', $slice, $parts)) { $key = $parts[1]; $val = $this->decode($parts[2]); if ($this->use & SERVICES_JSON_LOOSE_TYPE) { $obj[$key] = $val; } else { $obj->$key = $val; } } } } elseif ((($chrs{$c} == '"') || ($chrs{$c} == "'")) && ($top['what'] != SERVICES_JSON_IN_STR)) { array_push($stk, array('what' => SERVICES_JSON_IN_STR, 'where' => $c, 'delim' => $chrs{$c})); } elseif (($chrs{$c} == $top['delim']) && ($top['what'] == SERVICES_JSON_IN_STR) && ((strlen(substr($chrs, 0, $c)) - strlen(rtrim(substr($chrs, 0, $c), '\\'))) % 2 != 1)) { array_pop($stk); } elseif (($chrs{$c} == '[') && in_array($top['what'], array(SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ))) { array_push($stk, array('what' => SERVICES_JSON_IN_ARR, 'where' => $c, 'delim' => false)); } elseif (($chrs{$c} == ']') && ($top['what'] == SERVICES_JSON_IN_ARR)) { array_pop($stk); } elseif (($chrs{$c} == '{') && in_array($top['what'], array(SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ))) { array_push($stk, array('what' => SERVICES_JSON_IN_OBJ, 'where' => $c, 'delim' => false)); } elseif (($chrs{$c} == '}') && ($top['what'] == SERVICES_JSON_IN_OBJ)) { array_pop($stk); } elseif (($substr_chrs_c_2 == '/*') && in_array($top['what'], array(SERVICES_JSON_SLICE, SERVICES_JSON_IN_ARR, SERVICES_JSON_IN_OBJ))) { array_push($stk, array('what' => SERVICES_JSON_IN_CMT, 'where' => $c, 'delim' => false)); $c++; } elseif (($substr_chrs_c_2 == '*/') && ($top['what'] == SERVICES_JSON_IN_CMT)) { array_pop($stk); $c++; for ($i = $top['where']; $i <= $c; ++$i) $chrs = substr_replace($chrs, ' ', $i, 1); } } if (reset($stk) == SERVICES_JSON_IN_ARR) { return $arr; } elseif (reset($stk) == SERVICES_JSON_IN_OBJ) { return $obj; } } } } function isError($data, $code = null) { if (class_exists('pear')) { return PEAR::isError($data, $code); } elseif (is_object($data) && (get_class($data) == 'services_json_error' || is_subclass_of($data, 'services_json_error'))) { return true; } return false; } } if (class_exists('PEAR_Error')) { class Services_JSON_Error extends PEAR_Error { function Services_JSON_Error($message = 'unknown error', $code = null, $mode = null, $options = null, $userinfo = null) { parent::PEAR_Error($message, $code, $mode, $options, $userinfo); } } } else { class Services_JSON_Error { function Services_JSON_Error($message = 'unknown error', $code = null, $mode = null, $options = null, $userinfo = null) { } } }   define( 'TAG_START_MARKER', '<' ); define( 'TAG_START_END_MARKER', '>' ); define( 'TAG_END_START_MARKER', '</' ); define( 'TAG_END_MARKER', '/>' ); class Replace { static public $tagReplaceCount = 0; static public $elementReplaceCount = 0; private $tag = null; private $handler = null; private $handlerMethods = null; public function setHandler( $handler ) { if( !is_object( $handler ) ) return false; $this->handler = $handler; $this->handlerMethods = get_class_methods( $this->handler ); return true; } public function tag( $xml, $tagName=null, $argsAsArray=false ) { while( true ) { if( !$this->handler || !$tagName && !$this->getTagName() ) return $xml; if( $tagName ) $this->setTagName( $tagName ); $start = strpos( $xml, TAG_START_MARKER.$this->getTagName() ); if( $start === false ) return $xml; $end = strpos( $xml, TAG_END_MARKER, $start ) + strlen( TAG_END_MARKER ); if( $end < $start ) return $xml; $tag = substr( $xml, $start, $end-$start ); $args = $this->getTagArgs( $tag ); $xml = str_replace( $tag, $this->call( $this->getTagName(), $args, $argsAsArray ), $xml ); self::$tagReplaceCount++; } } public function element( $xml, $tagName=null, $argsAsArray=false ) { while( true ) { if( !$this->handler || !$tagName && !$this->getTagName() ) return $xml; if( $tagName ) $this->setTagName( $tagName ); $startMarker = TAG_START_MARKER.$this->getTagName(); $endMarker = TAG_END_START_MARKER.$this->getTagName().TAG_START_END_MARKER; $start = strpos( $xml, $startMarker ); if( $start === false ) return $xml; $endTag = strpos( $xml, TAG_START_END_MARKER, $start ) + strlen( TAG_START_END_MARKER ); if( $endTag < $start ) return $xml; $end = strpos( $xml, $endMarker, $start ) + strlen( $endMarker ); if( $end < $start ) return $xml; $tag = substr( $xml, $start, $endTag-$start ); $args = $this->getTagArgs( $tag ); $element = substr( $xml, $start, $end-$start ); $content = $this->getElementContent( $element, $tag ); $args = array_merge( array( 'content'=>$content ), $args ); $xml = str_replace( $element, $this->call( $this->getTagName(), $args, $argsAsArray ), $xml ); self::$elementReplaceCount++; } } private function getTagArgs( $tag ) { $tag = str_replace( TAG_START_MARKER.$this->getTagName(), '', $tag ); $tag = str_replace( TAG_END_MARKER, '', $tag ); $tag = str_replace( TAG_START_END_MARKER, '', $tag ); $result = array(); $join = ''; $args = explode( ' ', $tag ); foreach( $args as $arg ) { if( $join ) $arg = $join.' '.$arg; if( trim( $arg ) && strpos( $arg, '=' ) !== false ) { list( $key, $value ) = explode( '=', $arg, 2 ); if( substr( $value, -1 ) != '"' ) { $join = $key.'='.$value; } else { $result[$key] = str_replace( '"', '', $value ); $join = ''; } } } return $result; } private function getElementContent( $element, $tag ) { $element = str_replace( $tag, '', $element ); $element = str_replace( TAG_END_START_MARKER.$this->getTagName().TAG_START_END_MARKER, '', $element ); return $element; } private function call( $method, $args=array(), $argsAsArray=false ) { $method = str_replace( ':', '_', $method ); if( $argsAsArray ) $args = array( $args ); return call_user_func_array( array( $this->handler, $method ), $args ); } private function setTagName( $tag ){ $this->tag = $tag; } private function getTagName(){ return $this->tag; } }   define('CONFIG_PATH_SEPARATOR','.'); define('CONFIG_FILE_NOT_FOUND','__file_not_found__'); class Config { static private $accessCount = 0; static private $config = null; static private $cfgBasket = array(); static private $history = array( CONFIG_FILE_NOT_FOUND => array() ); private $codeType = null; private $textType = null; private function getCodeType(){ return $this->codeType; } private function setCodeType($type){ $this->codeType = $type; } private function getTextType(){ return $this->textType; } private function setTextType($type){ $this->textType = $type; } static public function getInstance(){ if (self::$config) return self::$config; self::$config = new Config(); return self::$config; } static public function getConfig(){ return self::$cfgBasket; } static public function getHistory(){ return self::$history; } static public function getAccessCount(){ return self::$accessCount; } public function getParam($key, $default = null){ $path = explode(CONFIG_PATH_SEPARATOR, $key); $tmpArray = & self::$cfgBasket; foreach ($path as $key){ if (!isset($tmpArray[$key])) return $default; $tmpArray = & $tmpArray[$key]; self::$accessCount++; } return $tmpArray; } public function setParam($key, $value){ $path = explode(CONFIG_PATH_SEPARATOR,$key); $tmpArray = & self::$cfgBasket; foreach ($path as $key){ if (!isset($tmpArray[$key])) $tmpArray[$key] = ''; $tmpArray = & $tmpArray[$key]; self::$accessCount++; } $tmpArray = $value; return $this; } public function includeText($path){ $handler = @fopen($path,"r"); if (!$handler){ self::$history[CONFIG_FILE_NOT_FOUND][$path] = $path; return false; } while (!feof($handler)) { $buffer = fgets($handler,4096); $buffer = rtrim($buffer); if (substr($buffer,0,2)!='//' && strpos($buffer,'=')>0){ list($key, $value) = explode('=',$buffer,2); $this->setParam(trim($key),trim($value)); } } } public function includePath($path){ $fileType = substr($path,-3); if (isset(self::$history[$path])) return true; if ($fileType == $this->getCodeType()){ if (!@include($path)){ self::$history[CONFIG_FILE_NOT_FOUND][$path] = $path; return false; } } if ($fileType == $this->getTextType()){ if ($this->includeText($path)) return false; } self::$history[$path] = $path; return true; } private function includeDir($path){ if (isset(self::$history[$path])) return true; if (!is_dir($path)) return $this->includePath($path); if ($handler = opendir($path)){ while (false !== ($file = readdir($handler))){ if (substr($file,-3) == $this->getCodeType() || substr($file,-3)== $this->getTextType()){ $this->includePath($path.DIRECTORY_SEPARATOR.$file); } } closedir($handler); self::$history[$path] = $path; return true; } return true; } private function includeTree($tree, $path){ foreach ($tree as $dir){ $path.=DIRECTORY_SEPARATOR.$dir; if (!$this->includeDir($path)) return; } } public function loadConfig($path, $root='', $code='php', $text='ini'){ $this->setCodeType($code); $this->setTextType($text); if (is_array($path)){ $this->includeTree($path,$root); }elseif (is_string($path)){ $this->includeDir($root.$path); } } } function config( $key, $value=null ) { if( substr( $key, 0, 1 ) == CONFIG_PATH_SEPARATOR ) Config::getInstance()->setParam( substr( $key, 1 ), $value ); else return Config::getInstance()->getParam( $key, $value ); }   use Doctrine\Common\ClassLoader, Doctrine\ORM\Configuration, Doctrine\ORM\EntityManager, Doctrine\Common\Cache\ArrayCache, Doctrine\DBAL\Event\Listeners\MysqlSessionInit; use Doctrine\Common\Annotations\AnnotationReader; use Doctrine\Common\Annotations\AnnotationRegistry; use Doctrine\Common\Annotations\CachedReader; use Doctrine\Common\Cache\ApcCache; class izDoctrine extends Object { static private $connections = array(); static private $classLoader = null; static private $entityLoader = null; private $config = null; private $cache = null; private $em = null; private $signature = null; public function init($dbConfig) { global $ds; $this->signature = md5(serialize($dbConfig)); if (!empty(self::$connections[$this->signature])) return self::$connections[$this->signature]; if (!self::$entityLoader) { self::$entityLoader = new ClassLoader('Entity', config('root.abs')); self::$entityLoader->register(); } $this->config = new Configuration; if(ENVIRONMENT == 'development') $cache = new \Doctrine\Common\Cache\ArrayCache; else $cache = new \Doctrine\Common\Cache\ApcCache; $reader = new CachedReader( new AnnotationReader(), $cache, $debug = true ); AnnotationRegistry::registerFile(realpath(__DIR__."/../../../libs/doctrine2/lib/Doctrine/ORM/Mapping/Driver/DoctrineAnnotations.php")); AnnotationRegistry::registerAutoloadNamespace( 'Gedmo\\Mapping\\Annotation', realpath(__DIR__.'/../../../libs/gedmo/lib') ); $chain = new \Doctrine\ORM\Mapping\Driver\DriverChain(); $annotationDriver = new Doctrine\ORM\Mapping\Driver\AnnotationDriver($reader, array( realpath(__DIR__."/../../../Entity"), realpath(__DIR__."/../../../libs/gedmo/lib/Gedmo/Translatable/Entity"), realpath(__DIR__."/../../../libs/gedmo/lib/Gedmo/Loggable/Entity"), realpath(__DIR__."/../../../libs/gedmo/lib/Gedmo/Tree/Entity") )); $chain->addDriver($annotationDriver, 'Gedmo\\Translatable\\Entity'); $chain->addDriver($annotationDriver, 'Gedmo\\Loggable\\Entity'); $chain->addDriver($annotationDriver, 'Gedmo\\Tree\\Entity'); $chain->addDriver($annotationDriver, 'Entity'); $this->config->setMetadataCacheImpl($cache); $this->config->setMetadataDriverImpl($chain); $this->config->setQueryCacheImpl($cache); $this->config->setProxyDir(config('root.abs').config('root.proxy_folder') . DIRECTORY_SEPARATOR); $this->config->setProxyNamespace('Proxies'); $this->config->setAutoGenerateProxyClasses(ENVIRONMENT == 'development'); $evm = new \Doctrine\Common\EventManager(); $evm->addEventSubscriber(new \Gedmo\Timestampable\TimestampableListener()); $evm->addEventSubscriber(new \Gedmo\Tree\TreeListener()); $evm->addEventSubscriber(new \Gedmo\Sluggable\SluggableListener()); $loggableListener = new \Gedmo\Loggable\LoggableListener(); $loggableListener->setUsername('admin'); $evm->addEventSubscriber($loggableListener); $translatableListener = new \Gedmo\Translatable\TranslationListener(); $translatableListener->setTranslatableLocale(config('root.default_lang')); $translatableListener->setDefaultLocale(config('root.default_lang')); $evm->addEventSubscriber($translatableListener); $this->em = EntityManager::create($dbConfig, $this->config, $evm); $this->em->getEventManager()->addEventSubscriber(new MysqlSessionInit('utf8', 'utf8_unicode_ci')); self::$connections[$this->signature] = $this; return $this; } public function getEntityManager() { $conn = self::$connections[$this->signature]; return $conn->em; } public function getConfig() { $conn = self::$connections[$this->signature]; return $conn->config; } }    define( 'LOCALE_FILE_NOT_FOUND', '__file_not_found__'); class izLocale { static private $locale = null; static private $history = array( LOCALE_FILE_NOT_FOUND => array() ); private $defaultLocale = null; private $currentLocale = null; private $localeFolder = null; private $localePath = null; private $localeUrl = null; private $localeAppFolders = array(''); static public function getInstance() { if( self::$locale ) return self::$locale; self::$locale = new izLocale(); return self::$locale; } public function setLocaleDefault( $defaultLocale ) { $this->defaultLocale = $defaultLocale; } public function setLocaleCurrent( $currentLocale ) { $this->currentLocale = $currentLocale; } public function setLocaleFolder( $localeFolder ) { $this->localeFolder = $localeFolder; } public function setLocalePath( $path ) { $this->localePath = $path; } public function setLocaleUrl( $url ) { $this->localeUrl = $url; } public function setLocaleAppFolders( $folders ) { $this->localeAppFolders = $folders; } public function getLocaleCurrent() { return $this->currentLocale; } public function getLocaleDefault() { return $this->defaultLocale; } public function getLocaleFolder() { return $this->localeFolder; } public function getLocalePath() { return $this->localePath; } public function getLocaleUrl() { return $this->localeUrl; } public function getLocaleAppFolders() { return $this->localeAppFolders; } public function localePathUrl( $localePath, $locale=null ) { return $this->localePath( $localePath, $locale, true ); } public function localePath( $localePath, $locale=null, $isUrl=false ) { if( !$locale ) $locale = $this->getLocaleCurrent() ? $this->getLocaleCurrent() : $this->getLocaleDefault(); $key = $localePath.$locale.$isUrl; if( isset( self::$history[$key] ) ) return self::$history[$key]; if( isset( self::$history[LOCALE_FILE_NOT_FOUND][$key] ) ) return null; $locales = array( $locale, $this->getLocaleDefault() ); $appFolders = $this->getLocaleAppFolders(); foreach( $appFolders as $folder ) { foreach( $locales as $locale ) { if( strlen( $folder ) && (substr($folder, strlen($folder)-1) !== DIRECTORY_SEPARATOR)) $folder.= DIRECTORY_SEPARATOR; $path = $folder.$this->getLocaleFolder().DIRECTORY_SEPARATOR.strtolower( $locale ).DIRECTORY_SEPARATOR.$localePath; if( is_readable( $this->getLocalePath().$path ) ) { if( $isUrl ) return self::$history[$key] = $this->getLocaleUrl().str_replace( '\\', '/', $path ); return self::$history[$key] = $this->getLocalePath().$path; } } } self::$history[LOCALE_FILE_NOT_FOUND][$key] = $locale.DIRECTORY_SEPARATOR.$localePath; return null; } static public function getHistory() { return self::$history; } } function locale( $path, $url=false, $locale=null ) { return izLocale::getInstance()->localePath( $path, $locale, $url ); }   define( 'IMPORT_PATH_SEPARATOR', '.'); define( 'IMPORT_FILE_NOT_FOUND', '__file_not_found__'); class Import{ static private $import = null; static private $history = array( IMPORT_FILE_NOT_FOUND => array() ); private $root = null; static public function getInstance(){ if (self::$import) return self::$import; self::$import = new Import(); return self::$import; } public function setImportRoot($root){ $this->root = $root; } public function getImportRoot(){ return $this->root; } public function importPath($path){ $class = $this->getPathClass($path); if ($class=='*' || !class_exists($class)){ $this->loadPath( $this->getRealPath( $path ), ( $class == '*' ) ); } } private function getPathClass($path){ $route = explode(IMPORT_PATH_SEPARATOR,$path); return $route[count($route)-1]; } private function getRealPath($path){ return $this->getImportRoot().str_replace(IMPORT_PATH_SEPARATOR,DIRECTORY_SEPARATOR,$path); } private function loadPath($path, $isFolder = false){ if (!$isFolder && @include_once($path.'.php')){ return $this->logImport($path.'.php'); } elseif (!$isFolder){ return $this->logImport($path.'.php',true); } $this->includeFolder(str_replace('*','',$path)); } public function includeFolder($path){ if (isset(self::$history[$path]) || isset(self::$history[IMPORT_FILE_NOT_FOUND][$path])) return; if (!is_dir($path) || !$handler=opendir($path)) return; while ( false !== ( $file = readdir( $handler ) ) ){ if (substr($file,-4)=='.php' || substr($file,-4)=='.inc'){ if (@include_once($path.$file)){ $this->logImport($path.$file); }else{ $this->logImport($path.$file,true); } } } closedir($handler); self::$history[$path]=$path; } private function logImport($path, $fail = false){ if ($fail){ self::$history[IMPORT_FILE_NOT_FOUND][$path] = $path; }else { self::$history[$path] = $path; } } static public function getHistory(){ return self::$history; } } function import( $path ) { return Import::getInstance()->importPath( $path ); }     class Lambda { private $aop = true; private $class = null; private $method = null; private $args = array(); public function call( $args=array(), $aop=true ) { $this->args = $args; $this->aop = $aop; $result = $this->get(); $this->args = array(); return $result; } public function set() { $args = func_get_args(); if( is_object( @$args[0] ) || class_exists( @$args[0] ) ) { $this->class = @$args[0]; $this->method = @$args[1]; $this->args = array_slice( $args, 2 ); } else { $this->method = @$args[0]; $this->args = array_slice( $args, 1 ); } return $this; } public function get() { foreach( range( 0, count( $this->args )-1 ) as $pos ) { if( @$this->args[$pos] instanceof Lambda ) { $this->args[$pos] = $this->args[$pos]->get(); } } $this->aopBefore(); if( $this->class ) { return $this->aopAfter( call_user_func_array( array( $this->class, $this->method ), $this->args ) ); } else { return $this->aopAfter( call_user_func_array( $this->method, $this->args ) ); } } private function aopBefore() { if( !$this->aop || !function_exists( 'aop' ) ) return null; return aop()->before( $this->class, $this->method, &$this->args ); } private function aopAfter( $result=null ) { if( !$this->aop || !function_exists( 'aop' ) ) return $result; return aop()->after( $this->class, $this->method, &$this->args, &$result ); } } function lambda() { $args = func_get_args(); return call_user_func_array( array( object( 'Lambda' ), 'set' ), $args ); }   use Doctrine\Common\ClassLoader; global $abs,$ds; require ($abs.'libs'.$ds.'doctrine2'.$ds.'lib'.$ds.'vendor'.$ds.'doctrine-common'.$ds.'lib'.$ds.'Doctrine'.$ds.'Common'.$ds.'ClassLoader.php'); $classLoader = new ClassLoader('Doctrine\Common',$abs.'libs'.$ds.'doctrine2'.$ds.'lib'.$ds.'vendor'.$ds.'doctrine-common'.$ds.'lib'); $classLoader->register(); $classLoader = new ClassLoader('Doctrine\DBAL',$abs.'libs'.$ds.'doctrine2'.$ds.'lib'.$ds.'vendor'.$ds.'doctrine-dbal'.$ds.'lib'); $classLoader->register(); $classLoader = new ClassLoader('Gedmo', $abs.'libs'.$ds.'gedmo'. $ds. 'lib'); $classLoader->register(); $classLoader = new ClassLoader('Doctrine\ORM',$abs.'libs'.$ds.'doctrine2'.$ds.'lib'); $classLoader->register(); $classLoader = new ClassLoader("Entity", config('root.abs')); $classLoader->register();    class Object { private $properties = array(); protected $lambdas = array(); private $prototype = null; private $__proto__ = null; private $__protoProperty__ = true; private $__protoMethod__ = true; private $__lambdaMethod__ = true; public function __construct( $object=null ) { if( is_array( $object ) ) { $this->properties( $object ); } if( $object instanceof Object ) { $this->prototype = $object; } } public function __set( $key, $value ) { $method = 'set'.ucfirst( $key ); $key = strtolower( $key ); if( !$this->__lambdaMethod__ && $this->__protoObject() ) { $this->__protoObject()->__lambdaMethod( false ); $this->__protoObject()->__set( $key, $value ); $this->__protoObject()->__lambdaMethod( true ); } elseif( $this->__lambdaMethod__ && $value instanceof Lambda ) { $this->lambdas[$key] = $value; } else { $aopArray = array( $value ); $this->aopBefore( $method, &$aopArray ); $this->properties[$key] = $aopArray[0]; $this->aopAfter( $method, &$aopArray, $this ); } return $this; } public function __get( $key ) { $value = null; $method = 'get'.ucfirst( $key ); $key = strtolower( $key ); if( $this->__protoObject() && $this->__protoProperty__ ) { $value = $this->__protoObject()->__get( $key ); } elseif( $this->hasOwnProperty( $key ) ) { $this->aopBefore( $method ); $value = $this->properties[$key]; $value = $this->aopAfter( $method, array(), &$value ); } elseif( $this->prototype ) { $this->prototype()->__protoProperty( false ); $value = $this->prototype()->__get( $key ); $this->prototype()->__protoProperty( true ); } return $value; } public function __call( $method, $args=array() ) { $control = substr( $method, 0, 3 ); if( $this->__protoObject() && $this->__protoMethod__ ) { return call_user_func_array( array( $this->__protoObject(), $method ), $args ); } elseif( isset( $this->lambdas[strtolower( $method )] ) ) { $this->aopBefore( $method, $args ); $result = $this->lambdas[strtolower( $method )]->call( $args ); return $this->aopAfter( $method, $args, $result ); } elseif( $this->prototype() ) { $this->prototype()->__proto( $this ); $this->prototype()->__protoMethod( false ); if( method_exists( $this->prototype(), $method ) ) $this->prototype()->aopBefore( $method, $args ); $result = call_user_func_array( array( $this->prototype(), $method ), $args ); if( method_exists( $this->prototype(), $method ) ) $result = $this->prototype()->aopAfter( $method, $args, $result ); $this->prototype()->__protoMethod( true ); $this->prototype()->__proto( null ); return $result; } elseif( $control == 'set' ) { $property = substr( $method, 3 ); $this->__lambdaMethod( false ); $this->__set( $property, $args[0] ); $this->__lambdaMethod( true ); return $this; } elseif( $control == 'get' ) { $property = substr( $method, 3 ); $result = $this->$property; if( !$result && isset( $args[0] ) ) { $result = $args[0]; } if( $result instanceof Lambda ) { while( $result instanceof Lambda ) { $result = $result->get(); } $this->__set( $property, $result ); } return $result; } trigger_error( 'Call to undefined method '.get_class( $this ).'::'.$method, E_USER_ERROR ); } public function __proto( $object=null ) { if( $object instanceof Object ) { $this->__proto__ = $object; } else { $this->__proto__ = null; } return $this; } public function __protoObject() { return $this->__proto__; } public function __protoProperty( $flag=true ) { $this->__protoProperty__ = $flag; return $this; } public function __protoMethod( $flag=true ) { $this->__protoMethod__ = $flag; return $this; } public function __lambdaMethod( $flag=true ) { $this->__lambdaMethod__ = $flag; return $this; } public function __lambda( $lambda ) { if( isset( $this->lambdas[$lambda] ) ) { return $this->lambdas[$lambda]; } return null; } static public function maker() { $class = 'Object'; $object = null; $args = func_get_args(); foreach( $args as $value ) { if( is_string( $value ) ) { $class = $value; } elseif( $value instanceof Object || is_array( $value ) ) { $object = $value; } } if( class_exists( $class ) ) { return new $class( $object ); } if( isset( $this ) ) { $extends = $this->toString(); } else { $extends = __CLASS__; } preg_match( '/[A-Z_]+/i', $class, $match ); if( strlen( $class ) > 0 && strlen( $match[0] ) === strlen( $class ) ) { eval( "class {$class} extends {$extends}{}" ); } else { trigger_error( "Object '{$class}' could not be Created or Found.", E_USER_ERROR ); } return self::maker( $class, $object ); } public function hasOwnProperty( $key ) { return isset( $this->properties[$key] ); } public function remove( $key ) { unset( $this->properties[$key] ); return $this; } public function copy( $empty=false ) { $clone = clone( $this ); if( $empty ) { $clone->properties = array(); } return $clone; } public function equals( $object ) { return $object == $this && $this->properties() == $object->properties(); } public function toString() { if( $this->__protoObject() ) { return $this->__protoObject()->toString(); } return get_class( $this ); } public function properties( $value=null ) { if( $value === true && $this->__protoObject() && $this->__protoProperty__ ) { return $this->__protoObject()->properties( $value ); } elseif( $value === true && $this->prototype() ) { $this->prototype()->__protoProperty( false ); $array = $this->prototype()->properties( $value ); $this->prototype()->__protoProperty( true ); return array_merge( $array, $this->properties ); } elseif( is_array( $value ) ) { foreach( $value as $key => $data ) { $this->__set( $key, $data ); } } return $this->properties; } public function prototype( $object=null ) { if( !( $object instanceof Object ) ) { return $this->prototype; } $this->prototype = $object; return $this; } private function aopBefore( $method, $args=array() ) { if( !function_exists( 'aop' ) ) return null; return aop()->before( $this, $method, &$args ); } private function aopAfter( $method, $args=array(), $result=null ) { if( !function_exists( 'aop' ) ) return $result; return aop()->after( $this, $method, &$args, &$result ); } public function Services_JSON() { return $this->properties(); } } function object() { $agrs = func_get_args(); return call_user_func_array( array( 'Object', 'maker' ), $agrs ); }   class Benchmark { private $markers = array(); private $memory = array(); static private $self = null; static public function getInstance() { if( self::$self ) return self::$self; self::$self = new Benchmark(); return self::$self; } public function getAll() { return $this->markers; } public function setMark( $marker ) { $this->markers[$marker] = microtime( true ); $this->setMemory( $marker ); return $this->markers[$marker]; } public function getTime( $from, $to, $round=4 ) { $start = isset( $this->markers[$from] ) ? $this->markers[$from] : $this->setMark( $from ); $end = isset( $this->markers[$to] ) ? $this->markers[$to] : $this->setMark( $to ); return round( ( $end-$start ), $round ); } public function getMemory( $from, $to=null, $asBytes=true ) { $start = isset( $this->memory[$from] ) ? $this->memory[$from] : $this->setMemory( $from ); $end = isset( $this->memory[$to] ) ? $this->memory[$to] : ( is_string( $to ) ? $this->setMemory( $to ) : null ); $result = $end ? $end-$start : $start; return ( is_bool( $to ) && !$to ) || !$asBytes ? $result/1048576 : $result; } private function setMemory( $marker ) { return $this->memory[$marker] = memory_get_usage( true ); } } function benchmark( $marker=null, $to=null, $round=4 ) { if( !$marker ) return Benchmark::getInstance(); if( $to ) return Benchmark::getInstance()->getTime( $marker, $to, $round ); return Benchmark::getInstance()->setMark( $marker ); }   class Cache extends Object { public function fetch($cacheFile) { if (file_exists($cacheFile) and ((time()-filemtime($cacheFile)) < $this->getRefresh_seconds())){ $cacheContent = file_get_contents($cacheFile); } return $cacheContent; } public function save() { return $this->saveToFile(); } private function saveToFile() { $file = fopen($this->getCache_file(),'w'); fwrite($file, $this->getContent()); fclose($file); return true; } } class acmeCache extends Object { public function fetch($name, $refreshSeconds = 0){ if(!$GLOBALS['cache_active']) return false; if(!$refreshSeconds) $refreshSeconds = 60; $cacheFile = acmeCache::cachePath($name); if(file_exists($cacheFile) and ((time()-filemtime($cacheFile))< $refreshSeconds)) $cacheContent = file_get_contents($cacheFile); return $cacheContent; } public function save($name, $cacheContent){ if(!$GLOBALS['cache_active']) return; $cacheFile = acmeCache::cachePath($name); acmeCache::savetofile($cacheFile, $cacheContent); } function cachePath($name){ $cacheFolder = $GLOBALS['cache_folder']; if(!$cacheFolder) $cacheFolder = trim($_SERVER['DOCUMENT_ROOT'],'/').'/cache/'; return $cacheFolder . md5(strtolower(trim($name))) . '.cache'; } function savetofile($filename, $data){ $dir = trim(dirname($filename),'/').'/'; acmeCache::forceDirectory($dir); $file = fopen($filename, 'w'); fwrite($file, $data); fclose($file); } function forceDirectory($dir){ return is_dir($dir) or (acmeCache::forceDirectory(dirname($dir)) and mkdir($dir, 0777)); } }    class Cookie extends Object { private $stored = false; private $instance = 'object-cookie-root'; private $lifeTime = null; private $path = '/'; private $domain = null; private $secure = null; public function setCookieControls( $lifeTime, $path='/', $domain=null, $secure=null ) { if( $this->stored ) trigger_error( 'Cookie ERROR, cannot set Cookie Controls after "Cookie::store()" has been called', E_USER_ERROR ); $this->lifeTime = $lifeTime; $this->path = $path; $this->domain = $domain; $this->secure = $secure; return $this; } public function instance( $instance=null ) { if( !$instance ) return $this->instance; if( $this->stored ) trigger_error( 'Cookie ERROR, cannot set Instance after "Cookie::store()" has been called', E_USER_ERROR ); $this->instance = $instance; if( !isset( $_COOKIE[$this->instance()] ) ) return; $this->properties( $this->decode( $_COOKIE[$this->instance()] ) ); return $this; } public function store() { if( $this->stored ) return; if( headers_sent() ) trigger_error( 'Cookie ERROR, cannot call "Cookie::store()" after HTTP Headers have been sent.', E_USER_ERROR ); $ret = setrawcookie( $this->instance(), $this->encode( $this->properties() ), $this->lifeTime, $this->path, $this->domain, $this->secure ); if ($ret) izlog('Cookie set for '.$this->instance); $this->stored = true; return $this; } public function kill() { if( headers_sent() ) trigger_error( 'Cookie ERROR, cannot call "Cookie::kill()" after HTTP Headers have been sent.', E_USER_ERROR ); setrawcookie( $this->instance(), '', time()-42000, $this->path, $this->domain, $this->secure ); $this->properties( array() ); $this->stored = true; return $this; } protected function encode( $data ) { $data = $this->http_build_query( $data ); $data = base64_encode( $data ); return $data; } protected function decode( $data ) { $data = base64_decode( $data ); parse_str( $data, $result ); return $result; } public function __set( $key, $value ) { if( $value && !is_scalar( $value ) ) trigger_error( 'Cookie ERROR, Cookie can only contain integer, float, string or boolean values.', E_USER_ERROR ); if( $this->stored ) trigger_error( 'Cookie ERROR, cannot set data after "Cookie::store()" has been called', E_USER_ERROR ); parent::__set( $key, $value ); } function http_build_query( $formdata, $numeric_prefix = null, $key = null ) { $res = array(); foreach ((array)$formdata as $k=>$v) { $tmp_key = urlencode(is_int($k) ? $numeric_prefix.$k : $k); if ($key) { $tmp_key = $key.'['.$tmp_key.']'; } if ( is_array($v) || is_object($v) ) { $res[] = http_build_query($v, null, $tmp_key); } else { $res[] = $tmp_key."=".urlencode($v); } } return implode("&", $res); } }     class Curl extends Object { private $handle = null; private $count = 0; private $stack = array(); public function get( $url, $type='string' ) { return $this->post( $url, null, $type ); } public function post( $url, $postArgs=null, $type='string' ) { $args = func_get_args(); $curlKey = implode( '', $args ); if( !$this->hasCurlKey( $curlKey ) ) { $curl = curl_init(); curl_setopt( $curl, CURLOPT_URL, $url ); curl_setopt( $curl, CURLOPT_HEADER, false ); curl_setopt( $curl, CURLOPT_RETURNTRANSFER, true ); curl_setopt( $curl, CURLOPT_FOLLOWLOCATION, true ); curl_setopt( $curl, CURLOPT_MAXREDIRS, 3 ); if( $postArgs ) { curl_setopt( $curl, CURLOPT_POST, true ); curl_setopt( $curl, CURLOPT_POSTFIELDS, $postArgs ); } $this->addCurlKey( $curlKey, $curl ); } return lambda( $this, 'call', $curlKey, $type ); } public function call( $curlKey, $type ) { if( is_resource( $this->stack[$curlKey] ) ) $this->process(); return $this->parse( $this->stack[$curlKey], $type ); } private function process() { $active = null; do { $mrc = curl_multi_exec( $this->gethandle(), $active ); } while( $mrc == CURLM_CALL_MULTI_PERFORM ); while( $active && $mrc == CURLM_OK ) { if( curl_multi_select( $this->gethandle() ) != -1 ) { do { $mrc = curl_multi_exec( $this->gethandle(), $active ); } while( $mrc == CURLM_CALL_MULTI_PERFORM ); } } foreach( $this->getStack() as $curlKey => $curl ) { if( is_resource( $curl ) ) $this->getContent( $curlKey, $curl ); } } private function getContent( $curlKey, $curl ) { $this->stack[$curlKey] = curl_multi_getcontent( $curl ); curl_multi_remove_handle( $this->handle, $curl ); $this->count--; if( $this->count == 0 ) curl_multi_close( $this->handle ); } private function getStack() { return $this->stack; } private function gethandle() { return $this->handle; } private function hasCurlKey( $curlKey ) { return isset( $this->stack[$curlKey] ); } private function addCurlKey( $curlKey, $curl ) { if( $this->count == 0 ) $this->handle = curl_multi_init(); curl_multi_add_handle( $this->handle, $curl ); $this->stack[$curlKey] = $curl; $this->count++; } private function parse( $data, $type='string' ) { switch( strtolower( $type ) ) { case 'sphp': return $this->unserializePhp( $data ); case 'json': return $this->unserializeJson( $data ); default: return $this->unserialize( $data ); } } public function unserializePhp( $data ) { if( $lambda = $this->__lambda( 'unserializephp' ) ) { return $lambda->call( $data ); } return @unserialize( $data ); } public function unserializeJson( $data ) { if( $lambda = $this->__lambda( 'unserializejson' ) ) { return $lambda->call( $data ); } return @json_decode( $data, true ); } public function unserialize( $data ) { if( $lambda = $this->__lambda( 'unserialize' ) ) { return $lambda->call( $data ); } return $data; } }   define( 'EVENTS_CALLED', '__events_called__'); class Event extends Object { static private $listeners = array(); static private $history = array( EVENTS_CALLED => array() ); static private $map = array(); public function addListener( $listener, $listenerId ) { $listenerId = intval( $listenerId ); self::$listeners[$listenerId] = $listener; if( !isset( self::$history[$listener->toString()] ) ) self::$history[$listener->toString()] = array(); ksort( self::$listeners ); return true; } static public function fire() { $args = func_get_args(); $method = @$args[0]; $args = array_slice( $args, 1 ); self::$history[EVENTS_CALLED][] = $method; $postion = 0; while( $postion < count( self::$listeners ) ) { $keys = array_keys( self::$listeners ); if( method_exists( self::$listeners[$keys[$postion]], $method ) ) { self::$history[self::$listeners[$keys[$postion]]->toString()][] = $method; call_user_func_array( array( self::$listeners[$keys[$postion]], $method ), $args ); } $postion++; } } static public function getHistory() { return self::$history; } static public function getEventMap() { return self::$map; } }     class http { var $log; var $dir; var $name; var $filename; var $url; var $port; var $verb; var $status; var $header; var $body; var $ttl; var $headers; var $postvars; var $xmlrequest; var $connect_timeout; var $data_ts; function http() { $this->log = "New http() object instantiated.<br />\n"; $this->connect_timeout = 30; $this->dir = realpath("./")."/"; $this->clean(); return true; } function fetch($url="", $ttl=0, $name="", $user="", $pwd="", $verb="GET") { $this->log .= "--------------------------------<br />fetch() called<br />\n"; $this->log .= "url: ".$url."<br />\n"; $this->status = ""; $this->header = ""; $this->body = ""; if (!$url) { $this->log .= "OOPS: You need to pass a URL!<br />"; return false; } $this->url = $url; $this->ttl = $ttl; $this->name = $name; $need_to_save = false; if ($this->ttl == "0") { if (!$fh = $this->getFromUrl($url, $user, $pwd, $verb)) { return false; } } else { if (strlen(trim($this->name)) == 0) { $this->name = MD5($url); } $this->filename = $this->dir."http_".$this->name; $this->log .= "Filename: ".$this->filename."<br />"; $this->getFile_ts(); if ($this->ttl == "daily") { if (date('Y-m-d',$this->data_ts) != date('Y-m-d',time())) { $this->log .= "cache has expired<br />"; if (!$fh = $this->getFromUrl($url, $user, $pwd, $verb)) { return false; } $need_to_save = true; if ($this->getFromUrl()) { return $this->saveToCache(); } } else { if (!$fh = $this->getFromCache()) { return false; } } } else { if ((time() - $this->data_ts) >= $this->ttl) { $this->log .= "cache has expired<br />"; if (!$fh = $this->getFromUrl($url, $user, $pwd)) { return false; } $need_to_save = true; } else { if (!$fh = $this->getFromCache()) { return false; } } } } $this->header = fgets($fh, 1024); $this->status = substr($this->header,9,3); while ((trim($line = fgets($fh, 1024)) != "") && (!feof($fh))) { $this->header .= $line; if ($this->status=="401" and strpos($line,"WWW-Authenticate: Basic realm=\"")===0) { fclose($fh); $this->log .= "Could not authenticate<br />\n"; return FALSE; } } while (!feof($fh)) { $this->body .= fgets($fh, 1024); } fclose($fh); if ($need_to_save) { $this->saveToCache(); } return $this->status; } function getFromUrl($url, $user="", $pwd="", $verb="GET") { $this->log .= "getFromUrl() called<br />"; preg_match("~([a-z]*://)?([^:^/]*)(:([0-9]{1,5}))?(/.*)?~i", $url, $parts); $protocol = $parts[1]; $server = $parts[2]; $port = $parts[4]; $path = $parts[5]; if ($port == "") { if (strtolower($protocol) == "https://") { $port = "443"; } else { $port = "80"; } } if ($path == "") { $path = "/"; } if (!$sock = @fsockopen(((strtolower($protocol) == "https://")?"ssl://":"").$server, $port, $errno, $errstr, $this->connect_timeout)) { $this->log .= "Could not open connection. Error " .$errno.": ".$errstr."<br />\n"; return false; } $this->headers["Host"] = $server.":".$port; if ($user != "" && $pwd != "") { $this->log .= "Authentication will be attempted<br />\n"; $this->headers["Authorization"] = "Basic ".base64_encode($user.":".$pwd); } if (count($this->postvars) > 0) { $this->log .= "Variables will be POSTed<br />\n"; $request = "POST ".$path." HTTP/1.0\r\n"; $post_string = ""; foreach ($this->postvars as $key=>$value) { $post_string .= "&".urlencode($key)."=".urlencode($value); } $post_string = substr($post_string,1); $this->headers["Content-Type"] = "application/x-www-form-urlencoded"; $this->headers["Content-Length"] = strlen($post_string); } elseif (strlen($this->xmlrequest) > 0) { $this->log .= "XML request will be sent<br />\n"; $request = $verb." ".$path." HTTP/1.0\r\n"; $this->headers["Content-Length"] = strlen($this->xmlrequest); } else { $request = $verb." ".$path." HTTP/1.0\r\n"; } if (fwrite($sock, $request) === FALSE) { fclose($sock); $this->log .= "Error writing request type to socket<br />\n"; return false; } foreach ($this->headers as $key=>$value) { if (fwrite($sock, $key.": ".$value."\r\n") === FALSE) { fclose($sock); $this->log .= "Error writing headers to socket<br />\n"; return false; } } if (fwrite($sock, "\r\n") === FALSE) { fclose($sock); $this->log .= "Error writing end-of-line to socket<br />\n"; return false; } if (count($this->postvars) > 0) { if (fwrite($sock, $post_string."\r\n") === FALSE) { fclose($sock); $this->log .= "Error writing POST string to socket<br />\n"; return false; } } elseif (strlen($this->xmlrequest) > 0) { if (fwrite($sock, $this->xmlrequest."\r\n") === FALSE) { fclose($sock); $this->log .= "Error writing xml request string to socket<br />\n"; return false; } } return $sock; } function clean() { $this->status = ""; $this->header = ""; $this->body = ""; $this->headers = array(); $this->postvars = array(); if (isset($_SERVER['HTTP_USER_AGENT'])) { $this->headers["User-Agent"] = $_SERVER['HTTP_USER_AGENT']; } else { $this->headers["User-Agent"] = "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"; } if (substr($_SERVER['SERVER_PROTOCOL'],0,5) == "HTTPS") { $this->headers["Referer"] = "https://".$_SERVER['HTTP_HOST'].$_SERVER['REQUEST_URI']; } else { $this->headers["Referer"] = "http://".$_SERVER['HTTP_HOST'].$_SERVER['REQUEST_URI']; } } function getFromCache() { $this->log .= "getFromCache() called<br />"; if (!$fp=@fopen($this->filename,"r")) { $this->log .= "Could not open ".$this->filename."<br />"; return false; } return $fp; } function saveToCache() { $this->log .= "saveToCache() called<br />"; if (!$fp=@fopen($this->filename,"w")) { $this->log .= "Could not open ".$this->filename."<br />"; return false; } if (!@fwrite($fp,$this->header."\r\n".$this->body)) { $this->log .= "Could not write to ".$this->filename."<br />"; fclose($fp); return false; } fclose($fp); return true; } function getFile_ts() { $this->log .= "getFile_ts() called<br />"; if (!file_exists($this->filename)) { $this->data_ts = 0; $this->log .= $this->filename." does not exist<br />"; return false; } $this->data_ts = filemtime($this->filename); return true; } function table_into_array($rawHTML,$needle="",$needle_within=0,$allowed_tags="") { $upperHTML = strtoupper($rawHTML); $idx = 0; if (strlen($needle) > 0) { $needle = strtoupper($needle); $idx = strpos($upperHTML,$needle); if ($idx === false) { return false; } if ($needle_within == 1) { $cnt = 0; while(($cnt < 100) && (substr($upperHTML,$idx,6) != "<TABLE")) { $idx = strrpos(substr($upperHTML,0,$idx-1),"<"); $cnt++; } } } $aryData = array(); $rowIdx = 0; $tmp = strpos($upperHTML,"<TR",$idx); if ($tmp === false) { return false; } $tmp2 = strpos($upperHTML,"</TR>",$tmp); if ($tmp2 === false) { return false; } $row = substr($rawHTML,$tmp,$tmp2-$tmp); $pattern = "/<TH>|<TH\ |<TD>|<TD\ /"; preg_match($pattern,strtoupper($row),$matches); $hdrTag = $matches[0]; while ($tmp = strpos(strtoupper($row),$hdrTag) !== false) { $tmp = strpos(strtoupper($row),">",$tmp); if ($tmp === false) { return false; } $tmp++; $tmp2 = strpos(strtoupper($row),"</T"); $aryData[$rowIdx][] = trim(strip_tags(substr($row,$tmp,$tmp2-$tmp),$allowed_tags)); $row = substr($row,$tmp2+5); preg_match($pattern,strtoupper($row),$matches); $hdrTag = $matches[0]; } $idx = strpos($upperHTML,"</TR>",$idx)+5; $rowIdx++; $tmp = strpos($upperHTML,"<TR",$idx); if ($tmp === false) { return false; } $tmp2 = strpos($upperHTML,"</TABLE>",$idx); if ($tmp2 === false) { return false; } $table = substr($rawHTML,$tmp,$tmp2-$tmp); while ($tmp = strpos(strtoupper($table),"<TR") !== false) { $tmp2 = strpos(strtoupper($table),"</TR"); if ($tmp2 === false) { return false; } $row = substr($table,$tmp,$tmp2-$tmp); while ($tmp = strpos(strtoupper($row),"<TD") !== false) { $tmp = strpos(strtoupper($row),">",$tmp); if ($tmp === false) { return false; } $tmp++; $tmp2 = strpos(strtoupper($row),"</TD"); $aryData[$rowIdx][] = trim(strip_tags(substr($row,$tmp,$tmp2-$tmp),$allowed_tags)); $row = substr($row,$tmp2+5); } $table = substr($table,strpos(strtoupper($table),"</TR>")+5); $rowIdx++; } return $aryData; } function table_into_xml($rawHTML,$needle="",$needle_within=0,$allowedTags="") { if (!$aryTable = http::table_into_array($rawHTML,$needle,$needle_within,$allowedTags)) { return false; } $xml = "<?xml version=\"1.0\" standalone=\"yes\" \?\>\n"; $xml .= "<TABLE>\n"; $rowIdx = 0; foreach ($aryTable as $row) { $xml .= "\t<ROW id=\"".$rowIdx."\">\n"; $colIdx = 0; foreach ($row as $col) { $xml .= "\t\t<COL id=\"".$colIdx."\">".trim(utf8_encode(htmlspecialchars($col)))."</COL>\n"; $colIdx++; } $xml .= "\t</ROW>\n"; $rowIdx++; } $xml .= "</TABLE>"; return $xml; } }    abstract class SeverityLevel { const EMERGENCY = 0; const ALERT = 1; const CRITICAL = 2; const ERROR = 3; const WARNING = 4; const NOTICE = 5; const INFORMATIONAL = 6; const DEBUG = 7; } class IzLogger extends Object { static private $logger = null; static public function getInstance(){ if (!self::$logger) { self::$logger = object('IzLogger'); self::$logger->setFilePath(config('root.abs').config('root.log_folder').DIRECTORY_SEPARATOR.'izomi.log'); } return self::$logger; } public function log($message, $severity = SeverityLevel::INFORMATIONAL, $module = null, $info = null){ $time = izDateTime::timeStampToString(); $ip = $_SERVER['REMOTE_ADDR']; $data = "{$ip}\t{$time}\t{$severity}\t{$message}\t{$module}\t{$info}"; file_put_contents(self::$logger->getFilePath(), "\n".$data, FILE_APPEND); } } class izLogging extends Object { static private $logger = null; static public function getInstance(){ if (!self::$logger) { self::$logger = object('izLogging'); self::$logger->setFilePath(config('root.abs').config('root.log_folder').DIRECTORY_SEPARATOR.'izomi.log'); } return self::$logger; } public function log($data){ @file_put_contents(self::$logger->getFilePath(), "\n".$data, FILE_APPEND); } } function izlog($data) { if (!is_string($data) && is_array($data)) $data = print_r($data, true); izLogging::getInstance()->log($data); } function logging($message, $severity = SeverityLevel::INFORMATIONAL, $module = null, $info = null) { if (!is_string($info) && is_array($info)){ $json = new Services_JSON; $info = $json->encode($info); } IzLogger::getInstance()->log($message, $severity, $module, $info); }     define( 'IZ_SESSION_ACTIVE', 'IZ_SESSION_ACTIVE' ); class Session extends Object { static private $stored = false; private $instance = 'object-session-root'; public function setCookieControls( $lifeTime, $path='/', $domain=null, $secure=null ) { if( @$_SESSION[IZ_SESSION_ACTIVE] ) trigger_error( 'Session ERROR, cannot set Cookie Controls after "Session::store()" has been called', E_USER_ERROR ); session_set_cookie_params( $lifeTime, $path, $domain, $secure ); } public function instance( $instance=null ) { if( !$instance ) return $this->instance; $this->instance = $instance; return $this; } public function store() { session_write_close(); self::$stored = true; $_SESSION[IZ_SESSION_ACTIVE] = 0; return $this; } public function kill( $all=false ) { $this->sessionStart(); unset( $_SESSION[$this->instance()] ); if( !$all ) return; $_SESSION = array(); if( isset( $_COOKIE[$this->getSessionName()] ) ) setcookie( $this->getSessionName(), '', time()-42000, '/' ); unset( $_REQUEST[$this->getSessionName()] ); unset( $_COOKIE[$this->getSessionName()] ); unset( $_POST[$this->getSessionName()] ); unset( $_GET[$this->getSessionName()] ); session_unset(); session_destroy(); return $this; } public function __set( $key, $value ) { $this->sessionStart(); $_SESSION[$this->instance()][$key] = $value; return $this; } public function __get( $key ) { $this->sessionStart(); if( isset( $_SESSION[$this->instance()] ) && isset( $_SESSION[$this->instance()][$key] ) ) return $_SESSION[$this->instance()][$key]; return parent::__get( $key ); } public function hasOwnProperty( $key ) { return isset( $_SESSION[$this->instance()] ) && isset( $_SESSION[$this->instance()][$key] ); } public function setSessionHandler( $handler ) { if( !is_subclass_of( $handler, 'SessionHandlerInterface' ) ) trigger_error( 'Session ERROR, "Session Handler" must use SessionHandlerInterface', E_USER_ERROR ); if( $this->detectSession() ) trigger_error( 'Session ERROR, cannot set Session Handler after Session has been started', E_USER_ERROR ); return session_set_save_handler( $handler->open(), $handler->close(), $handler->read(), $handler->write(), $handler->destory(), $handler->gc() ); } public function setSessionId( $id=null ) { if( $this->detectSession() ) return $this->regenerateSessionId( $id ); if( $id ) session_id( $id ); else session_id( $this->makeSessionId() ); return $this; } private function regenerateSessionId( $id=null ) { if( $this->detectSession() === false ) trigger_error( 'Session ERROR, cannot Regenerate a Session Id before the Session has been started', E_USER_ERROR ); $_SESSION_COPY = $_SESSION; $this->kill( true ); $this->sessionStart( $id ); $_SESSION = $_SESSION_COPY; return $this; } public function setSessionName( $name ) { if( $this->detectSession() ) trigger_error( 'Session ERROR, cannot set Session Name after Session has been started', E_USER_ERROR ); session_name( $name ); return $this; } public function getSessionName() { return session_name(); } public function getSessionId() { return session_id(); } public function sessionStart( $id=null ) { if( @$_SESSION[IZ_SESSION_ACTIVE] ) return; if( $this->detectSession() === false ) $this->setSessionId( $id ); session_cache_limiter( 'nocache' ); session_start(); header( 'P3P: CP="NOI ADM DEV PSAi COM NAV OUR OTRo STP IND DEM"' ); $_SESSION[IZ_SESSION_ACTIVE] = 1; return $this; } private function detectSession() { if( isset( $_COOKIE[$this->getSessionName()] ) ) { return $_COOKIE[$this->getSessionName()]; } return false; } private function makeSessionId() { return md5( @$_SERVER['HTTP_USER_AGENT'].uniqid(rand()).microtime() ); } } interface SessionHandlerInterface { public function open( $save_path, $session_name ); public function close(); public function read( $id ); public function write( $id, $sess_data ); public function destory( $id ); public function gc( $maxlifetime ); }     class Uri extends Object { public function __construct( $uri=null ) { if( $uri ) $this->set( $uri ); } public function getUserinfo() { return $this->user ? $this->user.':'.$this->pass : null; } public function getHostname() { return $this->host; } public function setHostname( $hostname ) { $this->host = $hostname; return $this; } public function getParameter( $key=null, $default=null ) { if( $key ) { return isset( $this->parameters[$key] ) ? $this->parameters[$key] : $default; } return $this->parameter; } public function getQuery( $key=null, $default=null ) { if( $key ) { return isset( $this->queries[$key] ) ? $this->queries[$key] : $default; } return $this->query; } public function setQuery( $query='' ) { $this->query = $query; $queries = array(); mb_parse_str( $this->query, $queries ); $this->queries = $queries; return $this; } public function getAuthority() { $authority = null; $authority = $this->getUserinfo() ? $this->getUserinfo().'@' : null; $authority.= $this->host; $authority.= $this->port ? ':'.$this->port : null; return $authority; } public function get() { $uri = null; $uri.= $this->scheme ? $this->scheme.':/'.'/' : null; $uri.= $this->getAuthority().$this->path.'/'; $uri.= $this->filename ? $this->filename : null; $uri.= $this->extension ? '.'.$this->extension : null; $uri.= $this->parameter ? ';'.$this->parameter : null; $uri.= $this->query ? '?'.$this->query : null; $uri.= $this->fragment ? '#'.$this->fragment : null; return $uri; } public function current() { $ssl = !empty( $_SERVER['HTTPS'] ) ? $_SERVER['HTTPS'] : 'off'; $uri = (($ssl == 'on') ? 'https' : 'http') . ':/'.'/'; $uri.= isset( $_SERVER['PHP_AUTH_USER'] ) ? $_SERVER['PHP_AUTH_USER'].':'.$_SERVER['PHP_AUTH_PW'].'@' : ''; $uri.= $_SERVER['SERVER_NAME']; $uri.= $_SERVER['SERVER_PORT'] != 80 ? ':'.$_SERVER['SERVER_PORT'] : ''; $uri.= $_SERVER['REQUEST_URI']; $this->set( $uri ); return $this; } public function set( $uri=null ) { $this->properties( parse_url( $uri ) ); $parts = explode( ';', basename( $this->path ), 2 ); $this->path = dirname( $this->path ); $this->filename = @$parts[0]; $this->parameter = @$parts[1]; $parts = pathinfo( $this->filename ); $this->filename = @$parts['filename']; $this->extension = @$parts['extension']; if( $this->filename && !$this->extension ) { $this->path.= '/'.$this->filename; $this->filename = ''; } $parameters = array(); mb_parse_str( str_replace( ';', '&', $this->parameter ), $parameters ); $this->parameters = $parameters; $this->setQuery( $this->query ); return $this; } static public function encode( $plainText ) { return strtr( base64_encode( $plainText ), '+/=', '-_,' ); } static public function decode( $base64url ) { return base64_decode( strtr( $base64url, '-_,', '+/=' ) ); } }    class UUID { const UUID_TIME = 1; const UUID_NAME_MD5 = 3; const UUID_RANDOM = 4; const UUID_NAME_SHA1 = 5; const FMT_FIELD = 100; const FMT_STRING = 101; const FMT_BINARY = 102; const FMT_QWORD = 1; const FMT_DWORD = 2; const FMT_WORD = 4; const FMT_SHORT = 8; const FMT_BYTE = 16; const FMT_DEFAULT = 16; static private $m_uuid_field = array( 'time_low' => 0, 'time_mid' => 0, 'time_hi' => 0, 'clock_seq_hi' => 0, 'clock_seq_low' => 0, 'node' => array() ); static private $m_generate = array( self::UUID_TIME => "generateTime", self::UUID_RANDOM => "generateRandom", self::UUID_NAME_MD5 => "generateNameMD5", self::UUID_NAME_SHA1 => "generateNameSHA1" ); static private $m_convert = array( self::FMT_FIELD => array( self::FMT_BYTE => "conv_field2byte", self::FMT_STRING => "conv_field2string", self::FMT_BINARY => "conv_field2binary" ), self::FMT_BYTE => array( self::FMT_FIELD => "conv_byte2field", self::FMT_STRING => "conv_byte2string", self::FMT_BINARY => "conv_byte2binary" ), self::FMT_STRING => array( self::FMT_BYTE => "conv_string2byte", self::FMT_FIELD => "conv_string2field", self::FMT_BINARY => "conv_string2binary" ), ); static private function swap32($x) { return (($x & 0x000000ff) << 24) | (($x & 0x0000ff00) << 8) | (($x & 0x00ff0000) >> 8) | (($x & 0xff000000) >> 24); } static private function swap16($x) { return (($x & 0x00ff) << 8) | (($x & 0xff00) >> 8); } static private function detectFormat($src) { if (is_string($src)) return self::FMT_STRING; else if (is_array($src)) { $len = count($src); if ($len == 1 || ($len % 2) == 0) return $len; else return (-1); } else return self::FMT_BINARY; } static public function generate($type, $fmt = self::FMT_BYTE, $node = "", $ns = "") { $func = self::$m_generate[$type]; if (!isset($func)) return null; $conv = self::$m_convert[self::FMT_FIELD][$fmt]; $uuid = self::$func($ns, $node); return self::$conv($uuid); } static public function convert($uuid, $from, $to) { $conv = self::$m_convert[$from][$to]; if (!isset($conv)) return ($uuid); return (self::$conv($uuid)); } static private function generateRandom($ns, $node) { $uuid = self::$m_uuid_field; $uuid['time_hi'] = (4 << 12) | (mt_rand(0, 0x1000)); $uuid['clock_seq_hi'] = (1 << 7) | mt_rand(0, 128); $uuid['time_low'] = mt_rand(0, 0xffff) + (mt_rand(0, 0xffff) << 16); $uuid['time_mid'] = mt_rand(0, 0xffff); $uuid['clock_seq_low'] = mt_rand(0, 255); for ($i = 0; $i < 6; $i++) $uuid['node'][$i] = mt_rand(0, 255); return ($uuid); } static private function generateName($ns, $node, $hash, $version) { $ns_fmt = self::detectFormat($ns); $field = self::convert($ns, $ns_fmt, self::FMT_FIELD); $field['time_low'] = self::swap32($field['time_low']); $field['time_mid'] = self::swap16($field['time_mid']); $field['time_hi'] = self::swap16($field['time_hi']); $raw = self::convert($field, self::FMT_FIELD, self::FMT_BINARY); $raw .= $node; $val = $hash($raw, true); $tmp = unpack('C16', $val); foreach (array_keys($tmp) as $key) $byte[$key - 1] = $tmp[$key]; $field = self::conv_byte2field($byte); $field['time_low'] = self::swap32($field['time_low']); $field['time_mid'] = self::swap16($field['time_mid']); $field['time_hi'] = self::swap16($field['time_hi']); $field['clock_seq_hi'] &= 0x3f; $field['clock_seq_hi'] |= (1 << 7); $field['time_hi'] &= 0x0fff; $field['time_hi'] |= ($version << 12); return ($field); } static private function generateNameMD5($ns, $node) { return self::generateName($ns, $node, "md5", self::UUID_NAME_MD5); } static private function generateNameSHA1($ns, $node) { return self::generateName($ns, $node, "sha1", self::UUID_NAME_SHA1); } static private function generateTime($ns, $node) { $uuid = self::$m_uuid_field; $tp = gettimeofday(); $time = ($tp['sec'] * 10000000) + ($tp['usec'] * 10) + 0x01B21DD213814000; $uuid['time_low'] = $time & 0xffffffff; $high = intval($time / 0xffffffff); $uuid['time_mid'] = $high & 0xffff; $uuid['time_hi'] = (($high >> 16) & 0xfff) | (self::UUID_TIME << 12); $uuid['clock_seq_hi'] = 0x80 | mt_rand(0, 64); $uuid['clock_seq_low'] = mt_rand(0, 255); for ($i = 0; $i < 6; $i++) $uuid['node'][$i] = ord(substr($node, $i, 1)); return ($uuid); } static private function conv_field2byte($src) { $uuid[0] = ($src['time_low'] & 0xff000000) >> 24; $uuid[1] = ($src['time_low'] & 0x00ff0000) >> 16; $uuid[2] = ($src['time_low'] & 0x0000ff00) >> 8; $uuid[3] = ($src['time_low'] & 0x000000ff); $uuid[4] = ($src['time_mid'] & 0xff00) >> 8; $uuid[5] = ($src['time_mid'] & 0x00ff); $uuid[6] = ($src['time_hi'] & 0xff00) >> 8; $uuid[7] = ($src['time_hi'] & 0x00ff); $uuid[8] = $src['clock_seq_hi']; $uuid[9] = $src['clock_seq_low']; for ($i = 0; $i < 6; $i++) $uuid[10+$i] = $src['node'][$i]; return ($uuid); } static private function conv_field2string($src) { $str = sprintf( '%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x', ($src['time_low']), ($src['time_mid']), ($src['time_hi']), $src['clock_seq_hi'], $src['clock_seq_low'], $src['node'][0], $src['node'][1], $src['node'][2], $src['node'][3], $src['node'][4], $src['node'][5]); return ($str); } static private function conv_field2binary($src) { $byte = self::conv_field2byte($src); return self::conv_byte2binary($byte); } static private function conv_byte2field($uuid) { $field = self::$m_uuid_field; $field['time_low'] = ($uuid[0] << 24) | ($uuid[1] << 16) | ($uuid[2] << 8) | $uuid[3]; $field['time_mid'] = ($uuid[4] << 8) | $uuid[5]; $field['time_hi'] = ($uuid[6] << 8) | $uuid[7]; $field['clock_seq_hi'] = $uuid[8]; $field['clock_seq_low'] = $uuid[9]; for ($i = 0; $i < 6; $i++) $field['node'][$i] = $uuid[10+$i]; return ($field); } static public function conv_byte2string($src) { $field = self::conv_byte2field($src); return self::conv_field2string($field); } static private function conv_byte2binary($src) { $raw = pack('C16', $src[0], $src[1], $src[2], $src[3], $src[4], $src[5], $src[6], $src[7], $src[8], $src[9], $src[10], $src[11], $src[12], $src[13], $src[14], $src[15]); return ($raw); } static private function conv_string2field($src) { $parts = sscanf($src, '%x-%x-%x-%x-%02x%02x%02x%02x%02x%02x'); $field = self::$m_uuid_field; $field['time_low'] = ($parts[0]); $field['time_mid'] = ($parts[1]); $field['time_hi'] = ($parts[2]); $field['clock_seq_hi'] = ($parts[3] & 0xff00) >> 8; $field['clock_seq_low'] = $parts[3] & 0x00ff; for ($i = 0; $i < 6; $i++) $field['node'][$i] = $parts[4+$i]; return ($field); } static private function conv_string2byte($src) { $field = self::conv_string2field($src); return self::conv_field2byte($field); } static private function conv_string2binary($src) { $byte = self::conv_string2byte($src); return self::conv_byte2binary($byte); } } function new_uuid() { return UUID::generate(UUID::UUID_RANDOM, UUID::FMT_STRING); }   class Validate extends Object { private $validate = array(); public function insertValidateRule( $key, $type='string', $canBeNull=true, $maxLength=0, $minLength=0 ) { if( $type instanceof ValidateRule ) $this->validate[$key] = $type; else $this->validate[$key] = new ValidateRule( $type, $canBeNull, $maxLength, $minLength ); } public function removeValidateRule( $key ) { if( isset( $this->validate[$key] ) ) unset( $this->validate[$key] ); } public function getValidateRule( $key ) { if( isset( $this->validate[$key] ) ) return $this->validate[$key]; return null; } public function isValid( $key=null ) { if( $key ) if( isset( $this->validate[$key] ) ) return $this->validate[$key]->validate( $this->__get( $key ) ); if( empty( $key ) ) foreach( $this->validate as $key => $rule ) if( !$rule->validate( $this->__get( $key ) ) ) return false; return true; } } class ValidateRule { private $type = null; private $canBeNull = null; private $maxLength = null; private $minLength = null; public function __construct( $type='string', $canBeNull=true, $maxLength=0, $minLength=0 ) { $this->setType( $type ); $this->setCanBeNull( $canBeNull ); $this->setMaxLength( $maxLength ); $this->setMinLength( $minLength ); } public function validate( $value ) { if( empty( $value ) && $this->getCanBeNull() ) return true; if( empty( $value ) && !$this->getCanBeNull() ) return false; $type = strtoupper( $this->getType() ); switch( $type ) { case 'INT': case 'INTEGER': $result = strcmp( $value, intval( $value ) ) === 0 ? true : false; break; case 'FLOAT': case 'DOUBLE': $result = strcmp( $value, floatval( $value ) ) === 0 ? true : false; break; case 'BOOL': case 'BOOLEAN': $result = strcmp( strtolower( $value ), 'true' ) === 0 || strcmp( strtolower( $value ), 'false' ) === 0 || $value == 1 || $value == 0 ? true : false; break; case 'ARRAY': $result = is_array( $value ); break; case 'STRING': $result = is_string( $value ); break; case 'CHARS': preg_match_all( '/[A-Z0-9_-]/i', $value, $match ); $match = implode( '', $match[0] ); $result = strcmp( $match, $value ) == 0 ? true : false; break; case 'DOMAIN': preg_match_all( '/[A-Z0-9._-]/i', $value, $match ); $match = implode( '', $match[0] ); $result = strcmp( $match, $value ) == 0 ? true : false; break; case 'EMAIL': preg_match_all( '/^[A-Z0-9._-]+@[A-Z0-9][A-Z0-9.-]{0,61}[A-Z0-9]\.[A-Z.]{2,6}$/i', $value, $match ); $match = implode( '', $match[0] ); $result = strcmp( $match, $value ) == 0 ? true : false; break; case 'OBJECT': $result = is_object( $value ); break; case 'CAPTCHA': session_start(); $result = strcmp(@$_SESSION['captcha'], $value) == 0 ? true : false; break; default: $result = true; break; } if( $result === false ) return false; if( $this->getMaxLength() > 0 && strlen( $value ) > $this->getMaxLength() ) return false; if( $this->getMinLength() > 0 && strlen( $value ) < $this->getMinLength() ) return false; return true; } public function setType( $type ){ $this->type = $type; } public function setCanBeNull( $canBeNull ){ $this->canBeNull = $canBeNull; } public function setMaxLength( $maxLength ){ $this->maxLength = $maxLength; } public function setMinLength( $minLength ){ $this->minLength = $minLength; } public function getType(){ return $this->type; } public function getCanBeNull(){ return $this->canBeNull; } public function getMaxLength(){ return $this->maxLength; } public function getMinLength(){ return $this->minLength; } }   class izAction extends Object { public function getContent(){ if (!$this->content && $this->getObject() instanceof izRender) { return $this->getObject()->render(); } return $this->content; } }   class izController extends Object { public function call ($method, $args=array()){ if (!$this->getMethods()) { $list = get_class_methods($this->__protoObject()); $listHidden = get_class_methods($this); $list = array_diff($list, $listHidden); $methods = array(); foreach ($list as $item){ $methods[strtolower($item)] = $item; } $this->setMethods($methods); } if (!$this->isMethodCallable($method)||$method == 'call'){ if (method_exists($this->__protoObject(), 'defaultCall')){ $method = 'defaultCall'; }else{ $args = $method; $method = 'content'; } } else{ $method = $this->getMethodName($method); } $module = $this->__protoObject(); return call_user_func_array(array($module,$method), ((is_array($args)) ? $args : array($args))); } public function content($template='default'){ $template = $this->getTemplate($template); if (!$template->getIzPath() && !config('root.development')){ Event::fire('httpPage',404); } return $template; } private function isMethodCallable($method){ $methods = $this->getMethods(); return isset($methods[strtolower($method)]); } private function getMethodName($method){ $methods = $this->getMethods(); return $methods[strtolower($method)]; } public function getTemplate($name, $module=null){ $template = object('izRender',object('izLocale')); $template->setIzPath($this->getTemplatePath($name,$module)); $template->setIzLocalePath($this->getLocalePath()); return $template; } public function getTemplatePath($name, $module=null){ $name = str_replace('.',DIRECTORY_SEPARATOR,$name); if (!$module){ $module = $this->getModuleName(); }else { $module = strtolower($module); } return locale($module.DIRECTORY_SEPARATOR.$name.'.html'); } public function getLocalePath(){ return locale( $this->getModuleName().DIRECTORY_SEPARATOR, true ); } }   class izManager extends Object { protected $reader = null; protected $writer = null; public function __call($method, $args){ switch (substr($method, 0, 6)){ case 'select': return call_user_func_array(array($this->getReader(),'selectRecords'),$args); case 'counts': return call_user_func_array( array( $this->getReader(), 'countsRecords' ), $args ); case 'choose': return call_user_func_array( array( $this->getReader(), 'chooseRecord' ), $args ); case 'insert': return call_user_func_array( array( $this->getWriter(), 'insertRecord' ), $args ); case 'update': return call_user_func_array( array( $this->getWriter(), 'updateRecord' ), $args ); case 'delete': return call_user_func_array( array( $this->getWriter(), 'deleteRecord' ), $args ); } return parent::__call($method, $args); } public function getReader(){ if ($this->reader==null){ if (class_exists($this->toString().'Reader')){ $class = $this->toString().'Reader'; }else{ $class = config("{$this->toString()}.data_reader",config('root.data_reader')); } $string = config("{$this->toString()}.data_reader_string",config('root.data_reader_string')); if (!$class) trigger_error("Cannot load Reader for {$this->toString()}",E_USER_ERROR); $this->reader = $this->loadDataSource($class,$string); } return $this->reader; } public function getWriter(){ if ($this->writer == null){ if (class_exists($this->toString().'Writer')){ $class = $this->toString().'Writer'; }else{ $class = config("{$this->toString()}.data_writer",config('root.data_writer')); } $string = config( "{$this->toString()}.data_writer_string", config( 'root.data_writer_string' ) ); if( !$class ) trigger_error( "Cannot load Writer for {$this->toString()}", E_USER_ERROR ); $this->writer = $this->loadDataSource( $class, $string ); } return $this->writer; } private function loadDataSource($class, $string){ $object = object($class); $object->init($string); return $object; } }     import('core.lib.openid.auth.openid.CryptUtil'); import('core.lib.openid.auth.openid.KVForm'); import('core.lib.openid.auth.openid.HMAC'); class Auth_OpenID_Association { var $SIG_LENGTH = 20; var $assoc_keys = array( 'version', 'handle', 'secret', 'issued', 'lifetime', 'assoc_type' ); var $_macs = array( 'HMAC-SHA1' => 'Auth_OpenID_HMACSHA1', 'HMAC-SHA256' => 'Auth_OpenID_HMACSHA256' ); function fromExpiresIn($expires_in, $handle, $secret, $assoc_type) { $issued = time(); $lifetime = $expires_in; return new Auth_OpenID_Association($handle, $secret, $issued, $lifetime, $assoc_type); } function Auth_OpenID_Association( $handle, $secret, $issued, $lifetime, $assoc_type) { if (!in_array($assoc_type, Auth_OpenID_getSupportedAssociationTypes())) { $fmt = 'Unsupported association type (%s)'; trigger_error(sprintf($fmt, $assoc_type), E_USER_ERROR); } $this->handle = $handle; $this->secret = $secret; $this->issued = $issued; $this->lifetime = $lifetime; $this->assoc_type = $assoc_type; } function getExpiresIn($now = null) { if ($now == null) { $now = time(); } return max(0, $this->issued + $this->lifetime - $now); } function equal($other) { return ((gettype($this) == gettype($other)) && ($this->handle == $other->handle) && ($this->secret == $other->secret) && ($this->issued == $other->issued) && ($this->lifetime == $other->lifetime) && ($this->assoc_type == $other->assoc_type)); } function serialize() { $data = array( 'version' => '2', 'handle' => $this->handle, 'secret' => base64_encode($this->secret), 'issued' => strval(intval($this->issued)), 'lifetime' => strval(intval($this->lifetime)), 'assoc_type' => $this->assoc_type ); assert(array_keys($data) == $this->assoc_keys); return Auth_OpenID_KVForm::fromArray($data, $strict = true); } function deserialize($class_name, $assoc_s) { $pairs = Auth_OpenID_KVForm::toArray($assoc_s, $strict = true); $keys = array(); $values = array(); foreach ($pairs as $key => $value) { if (is_array($value)) { list($key, $value) = $value; } $keys[] = $key; $values[] = $value; } $class_vars = get_class_vars($class_name); $class_assoc_keys = $class_vars['assoc_keys']; sort($keys); sort($class_assoc_keys); if ($keys != $class_assoc_keys) { trigger_error('Unexpected key values: ' . var_export($keys, true), E_USER_WARNING); return null; } $version = $pairs['version']; $handle = $pairs['handle']; $secret = $pairs['secret']; $issued = $pairs['issued']; $lifetime = $pairs['lifetime']; $assoc_type = $pairs['assoc_type']; if ($version != '2') { trigger_error('Unknown version: ' . $version, E_USER_WARNING); return null; } $issued = intval($issued); $lifetime = intval($lifetime); $secret = base64_decode($secret); return new $class_name( $handle, $secret, $issued, $lifetime, $assoc_type); } function sign($pairs) { $kv = Auth_OpenID_KVForm::fromArray($pairs); $callback = $this->_macs[$this->assoc_type]; return call_user_func_array($callback, array($this->secret, $kv)); } function signMessage($message) { if ($message->hasKey(Auth_OpenID_OPENID_NS, 'sig') || $message->hasKey(Auth_OpenID_OPENID_NS, 'signed')) { return null; } $extant_handle = $message->getArg(Auth_OpenID_OPENID_NS, 'assoc_handle'); if ($extant_handle && ($extant_handle != $this->handle)) { return null; } $signed_message = $message; $signed_message->setArg(Auth_OpenID_OPENID_NS, 'assoc_handle', $this->handle); $message_keys = array_keys($signed_message->toPostArgs()); $signed_list = array(); $signed_prefix = 'openid.'; foreach ($message_keys as $k) { if (strpos($k, $signed_prefix) === 0) { $signed_list[] = substr($k, strlen($signed_prefix)); } } $signed_list[] = 'signed'; sort($signed_list); $signed_message->setArg(Auth_OpenID_OPENID_NS, 'signed', implode(',', $signed_list)); $sig = $this->getMessageSignature($signed_message); $signed_message->setArg(Auth_OpenID_OPENID_NS, 'sig', $sig); return $signed_message; } function _makePairs(&$message) { $signed = $message->getArg(Auth_OpenID_OPENID_NS, 'signed'); if (!$signed || Auth_OpenID::isFailure($signed)) { return null; } $signed_list = explode(',', $signed); $pairs = array(); $data = $message->toPostArgs(); foreach ($signed_list as $field) { $pairs[] = array($field, Auth_OpenID::arrayGet($data, 'openid.' . $field, '')); } return $pairs; } function getMessageSignature(&$message) { $pairs = $this->_makePairs($message); return base64_encode($this->sign($pairs)); } function checkMessageSignature(&$message) { $sig = $message->getArg(Auth_OpenID_OPENID_NS, 'sig'); if (!$sig || Auth_OpenID::isFailure($sig)) { return false; } $calculated_sig = $this->getMessageSignature($message); return $calculated_sig == $sig; } } function Auth_OpenID_getSecretSize($assoc_type) { if ($assoc_type == 'HMAC-SHA1') { return 20; } else if ($assoc_type == 'HMAC-SHA256') { return 32; } else { return null; } } function Auth_OpenID_getAllAssociationTypes() { return array('HMAC-SHA1', 'HMAC-SHA256'); } function Auth_OpenID_getSupportedAssociationTypes() { $a = array('HMAC-SHA1'); if (Auth_OpenID_HMACSHA256_SUPPORTED) { $a[] = 'HMAC-SHA256'; } return $a; } function Auth_OpenID_getSessionTypes($assoc_type) { $assoc_to_session = array( 'HMAC-SHA1' => array('DH-SHA1', 'no-encryption')); if (Auth_OpenID_HMACSHA256_SUPPORTED) { $assoc_to_session['HMAC-SHA256'] = array('DH-SHA256', 'no-encryption'); } return Auth_OpenID::arrayGet($assoc_to_session, $assoc_type, array()); } function Auth_OpenID_checkSessionType($assoc_type, $session_type) { if (!in_array($session_type, Auth_OpenID_getSessionTypes($assoc_type))) { return false; } return true; } function Auth_OpenID_getDefaultAssociationOrder() { $order = array(); if (!Auth_OpenID_noMathSupport()) { $order[] = array('HMAC-SHA1', 'DH-SHA1'); if (Auth_OpenID_HMACSHA256_SUPPORTED) { $order[] = array('HMAC-SHA256', 'DH-SHA256'); } } $order[] = array('HMAC-SHA1', 'no-encryption'); if (Auth_OpenID_HMACSHA256_SUPPORTED) { $order[] = array('HMAC-SHA256', 'no-encryption'); } return $order; } function Auth_OpenID_getOnlyEncryptedOrder() { $result = array(); foreach (Auth_OpenID_getDefaultAssociationOrder() as $pair) { list($assoc, $session) = $pair; if ($session != 'no-encryption') { if (Auth_OpenID_HMACSHA256_SUPPORTED && ($assoc == 'HMAC-SHA256')) { $result[] = $pair; } else if ($assoc != 'HMAC-SHA256') { $result[] = $pair; } } } return $result; } function &Auth_OpenID_getDefaultNegotiator() { $x = new Auth_OpenID_SessionNegotiator( Auth_OpenID_getDefaultAssociationOrder()); return $x; } function &Auth_OpenID_getEncryptedNegotiator() { $x = new Auth_OpenID_SessionNegotiator( Auth_OpenID_getOnlyEncryptedOrder()); return $x; } class Auth_OpenID_SessionNegotiator { function Auth_OpenID_SessionNegotiator($allowed_types) { $this->allowed_types = array(); $this->setAllowedTypes($allowed_types); } function setAllowedTypes($allowed_types) { foreach ($allowed_types as $pair) { list($assoc_type, $session_type) = $pair; if (!Auth_OpenID_checkSessionType($assoc_type, $session_type)) { return false; } } $this->allowed_types = $allowed_types; return true; } function addAllowedType($assoc_type, $session_type = null) { if ($this->allowed_types === null) { $this->allowed_types = array(); } if ($session_type === null) { $available = Auth_OpenID_getSessionTypes($assoc_type); if (!$available) { return false; } foreach ($available as $session_type) { $this->addAllowedType($assoc_type, $session_type); } } else { if (Auth_OpenID_checkSessionType($assoc_type, $session_type)) { $this->allowed_types[] = array($assoc_type, $session_type); } else { return false; } } return true; } function isAllowed($assoc_type, $session_type) { $assoc_good = in_array(array($assoc_type, $session_type), $this->allowed_types); $matches = in_array($session_type, Auth_OpenID_getSessionTypes($assoc_type)); return ($assoc_good && $matches); } function getAllowedType() { if (!$this->allowed_types) { return array(null, null); } return $this->allowed_types[0]; } }    import('core.lib.openid.auth.openid.Extension'); import('core.lib.openid.auth.openid.Message'); import('core.lib.openid.auth.openid.TrustRoot'); define('Auth_OpenID_AX_NS_URI', 'http://openid.net/srv/ax/1.0'); define('Auth_OpenID_AX_UNLIMITED_VALUES', 'unlimited'); define('Auth_OpenID_AX_MINIMUM_SUPPORTED_ALIAS_LENGTH', 32); class Auth_OpenID_AX { function isError($thing) { return is_a($thing, 'Auth_OpenID_AX_Error'); } } function Auth_OpenID_AX_checkAlias($alias) { if (strpos($alias, ',') !== false) { return new Auth_OpenID_AX_Error(sprintf( "Alias %s must not contain comma", $alias)); } if (strpos($alias, '.') !== false) { return new Auth_OpenID_AX_Error(sprintf( "Alias %s must not contain period", $alias)); } return true; } class Auth_OpenID_AX_Error { function Auth_OpenID_AX_Error($message=null) { $this->message = $message; } } class Auth_OpenID_AX_Message extends Auth_OpenID_Extension { var $ns_alias = 'ax'; var $mode = null; var $ns_uri = Auth_OpenID_AX_NS_URI; function _checkMode($ax_args) { $mode = Auth_OpenID::arrayGet($ax_args, 'mode'); if ($mode != $this->mode) { return new Auth_OpenID_AX_Error( sprintf( "Expected mode '%s'; got '%s'", $this->mode, $mode)); } return true; } function _newArgs() { return array('mode' => $this->mode); } } class Auth_OpenID_AX_AttrInfo { function Auth_OpenID_AX_AttrInfo($type_uri, $count, $required, $alias) { $this->required = $required; $this->count = $count; $this->type_uri = $type_uri; $this->alias = $alias; } function make($type_uri, $count=1, $required=false, $alias=null) { if ($alias !== null) { $result = Auth_OpenID_AX_checkAlias($alias); if (Auth_OpenID_AX::isError($result)) { return $result; } } return new Auth_OpenID_AX_AttrInfo($type_uri, $count, $required, $alias); } function wantsUnlimitedValues() { return $this->count === Auth_OpenID_AX_UNLIMITED_VALUES; } } function Auth_OpenID_AX_toTypeURIs(&$namespace_map, $alias_list_s) { $uris = array(); if ($alias_list_s) { foreach (explode(',', $alias_list_s) as $alias) { $type_uri = $namespace_map->getNamespaceURI($alias); if ($type_uri === null) { return new Auth_OpenID_AX_Error( sprintf('No type is defined for attribute name %s', $alias) ); } else { $uris[] = $type_uri; } } } return $uris; } class Auth_OpenID_AX_FetchRequest extends Auth_OpenID_AX_Message { var $mode = 'fetch_request'; function Auth_OpenID_AX_FetchRequest($update_url=null) { $this->requested_attributes = array(); $this->update_url = $update_url; } function add($attribute) { if ($this->contains($attribute->type_uri)) { return new Auth_OpenID_AX_Error( sprintf("The attribute %s has already been requested", $attribute->type_uri)); } $this->requested_attributes[$attribute->type_uri] = $attribute; return true; } function getExtensionArgs() { $aliases = new Auth_OpenID_NamespaceMap(); $required = array(); $if_available = array(); $ax_args = $this->_newArgs(); foreach ($this->requested_attributes as $type_uri => $attribute) { if ($attribute->alias === null) { $alias = $aliases->add($type_uri); } else { $alias = $aliases->addAlias($type_uri, $attribute->alias); if ($alias === null) { return new Auth_OpenID_AX_Error( sprintf("Could not add alias %s for URI %s", $attribute->alias, $type_uri )); } } if ($attribute->required) { $required[] = $alias; } else { $if_available[] = $alias; } if ($attribute->count != 1) { $ax_args['count.' . $alias] = strval($attribute->count); } $ax_args['type.' . $alias] = $type_uri; } if ($required) { $ax_args['required'] = implode(',', $required); } if ($if_available) { $ax_args['if_available'] = implode(',', $if_available); } return $ax_args; } function getRequiredAttrs() { $required = array(); foreach ($this->requested_attributes as $type_uri => $attribute) { if ($attribute->required) { $required[] = $type_uri; } } return $required; } function &fromOpenIDRequest($request) { $m = $request->message; $obj = new Auth_OpenID_AX_FetchRequest(); $ax_args = $m->getArgs($obj->ns_uri); $result = $obj->parseExtensionArgs($ax_args); if (Auth_OpenID_AX::isError($result)) { return $result; } if ($obj->update_url) { $realm = $m->getArg(Auth_OpenID_OPENID_NS, 'realm', $m->getArg( Auth_OpenID_OPENID_NS, 'return_to')); if (!$realm) { $obj = new Auth_OpenID_AX_Error( sprintf("Cannot validate update_url %s " . "against absent realm", $obj->update_url)); } else if (!Auth_OpenID_TrustRoot::match($realm, $obj->update_url)) { $obj = new Auth_OpenID_AX_Error( sprintf("Update URL %s failed validation against realm %s", $obj->update_url, $realm)); } } return $obj; } function parseExtensionArgs($ax_args) { $result = $this->_checkMode($ax_args); if (Auth_OpenID_AX::isError($result)) { return $result; } $aliases = new Auth_OpenID_NamespaceMap(); foreach ($ax_args as $key => $value) { if (strpos($key, 'type.') === 0) { $alias = substr($key, 5); $type_uri = $value; $alias = $aliases->addAlias($type_uri, $alias); if ($alias === null) { return new Auth_OpenID_AX_Error( sprintf("Could not add alias %s for URI %s", $alias, $type_uri) ); } $count_s = Auth_OpenID::arrayGet($ax_args, 'count.' . $alias); if ($count_s) { $count = Auth_OpenID::intval($count_s); if (($count === false) && ($count_s === Auth_OpenID_AX_UNLIMITED_VALUES)) { $count = $count_s; } } else { $count = 1; } if ($count === false) { return new Auth_OpenID_AX_Error( sprintf("Integer value expected for %s, got %s", 'count.' . $alias, $count_s)); } $attrinfo = Auth_OpenID_AX_AttrInfo::make($type_uri, $count, false, $alias); if (Auth_OpenID_AX::isError($attrinfo)) { return $attrinfo; } $this->add($attrinfo); } } $required = Auth_OpenID_AX_toTypeURIs($aliases, Auth_OpenID::arrayGet($ax_args, 'required')); foreach ($required as $type_uri) { $attrib =& $this->requested_attributes[$type_uri]; $attrib->required = true; } $if_available = Auth_OpenID_AX_toTypeURIs($aliases, Auth_OpenID::arrayGet($ax_args, 'if_available')); $all_type_uris = array_merge($required, $if_available); foreach ($aliases->iterNamespaceURIs() as $type_uri) { if (!in_array($type_uri, $all_type_uris)) { return new Auth_OpenID_AX_Error( sprintf('Type URI %s was in the request but not ' . 'present in "required" or "if_available"', $type_uri)); } } $this->update_url = Auth_OpenID::arrayGet($ax_args, 'update_url'); return true; } function iterAttrs() { return array_values($this->requested_attributes); } function iterTypes() { return array_keys($this->requested_attributes); } function contains($type_uri) { return in_array($type_uri, $this->iterTypes()); } } class Auth_OpenID_AX_KeyValueMessage extends Auth_OpenID_AX_Message { function Auth_OpenID_AX_KeyValueMessage() { $this->data = array(); } function addValue($type_uri, $value) { if (!array_key_exists($type_uri, $this->data)) { $this->data[$type_uri] = array(); } $values =& $this->data[$type_uri]; $values[] = $value; } function setValues($type_uri, &$values) { $this->data[$type_uri] =& $values; } function _getExtensionKVArgs(&$aliases) { if ($aliases === null) { $aliases = new Auth_OpenID_NamespaceMap(); } $ax_args = array(); foreach ($this->data as $type_uri => $values) { $alias = $aliases->add($type_uri); $ax_args['type.' . $alias] = $type_uri; $ax_args['count.' . $alias] = strval(count($values)); foreach ($values as $i => $value) { $key = sprintf('value.%s.%d', $alias, $i + 1); $ax_args[$key] = $value; } } return $ax_args; } function parseExtensionArgs($ax_args) { $result = $this->_checkMode($ax_args); if (Auth_OpenID_AX::isError($result)) { return $result; } $aliases = new Auth_OpenID_NamespaceMap(); foreach ($ax_args as $key => $value) { if (strpos($key, 'type.') === 0) { $type_uri = $value; $alias = substr($key, 5); $result = Auth_OpenID_AX_checkAlias($alias); if (Auth_OpenID_AX::isError($result)) { return $result; } $alias = $aliases->addAlias($type_uri, $alias); if ($alias === null) { return new Auth_OpenID_AX_Error( sprintf("Could not add alias %s for URI %s", $alias, $type_uri) ); } } } foreach ($aliases->iteritems() as $pair) { list($type_uri, $alias) = $pair; if (array_key_exists('count.' . $alias, $ax_args)) { $count_key = 'count.' . $alias; $count_s = $ax_args[$count_key]; $count = Auth_OpenID::intval($count_s); if ($count === false) { return new Auth_OpenID_AX_Error( sprintf("Integer value expected for %s, got %s", 'count. %s' . $alias, $count_s, Auth_OpenID_AX_UNLIMITED_VALUES) ); } $values = array(); for ($i = 1; $i < $count + 1; $i++) { $value_key = sprintf('value.%s.%d', $alias, $i); if (!array_key_exists($value_key, $ax_args)) { return new Auth_OpenID_AX_Error( sprintf( "No value found for key %s", $value_key)); } $value = $ax_args[$value_key]; $values[] = $value; } } else { $key = 'value.' . $alias; if (!array_key_exists($key, $ax_args)) { return new Auth_OpenID_AX_Error( sprintf( "No value found for key %s", $key)); } $value = $ax_args['value.' . $alias]; if ($value == '') { $values = array(); } else { $values = array($value); } } $this->data[$type_uri] = $values; } return true; } function getSingle($type_uri, $default=null) { $values = Auth_OpenID::arrayGet($this->data, $type_uri); if (!$values) { return $default; } else if (count($values) == 1) { return $values[0]; } else { return new Auth_OpenID_AX_Error( sprintf('More than one value present for %s', $type_uri) ); } } function get($type_uri) { if (array_key_exists($type_uri, $this->data)) { return $this->data[$type_uri]; } else { return new Auth_OpenID_AX_Error( sprintf("Type URI %s not found in response", $type_uri) ); } } function count($type_uri) { if (array_key_exists($type_uri, $this->data)) { return count($this->get($type_uri)); } else { return new Auth_OpenID_AX_Error( sprintf("Type URI %s not found in response", $type_uri) ); } } } class Auth_OpenID_AX_FetchResponse extends Auth_OpenID_AX_KeyValueMessage { var $mode = 'fetch_response'; function Auth_OpenID_AX_FetchResponse($update_url=null) { $this->Auth_OpenID_AX_KeyValueMessage(); $this->update_url = $update_url; } function getExtensionArgs($request=null) { $aliases = new Auth_OpenID_NamespaceMap(); $zero_value_types = array(); if ($request !== null) { foreach ($this->data as $type_uri => $unused) { if (!$request->contains($type_uri)) { return new Auth_OpenID_AX_Error( sprintf("Response attribute not present in request: %s", $type_uri) ); } } foreach ($request->iterAttrs() as $attr_info) { if ($attr_info->alias === null) { $aliases->add($attr_info->type_uri); } else { $alias = $aliases->addAlias($attr_info->type_uri, $attr_info->alias); if ($alias === null) { return new Auth_OpenID_AX_Error( sprintf("Could not add alias %s for URI %s", $attr_info->alias, $attr_info->type_uri) ); } } if (array_key_exists($attr_info->type_uri, $this->data)) { $values = $this->data[$attr_info->type_uri]; } else { $values = array(); $zero_value_types[] = $attr_info; } if (($attr_info->count != Auth_OpenID_AX_UNLIMITED_VALUES) && ($attr_info->count < count($values))) { return new Auth_OpenID_AX_Error( sprintf("More than the number of requested values " . "were specified for %s", $attr_info->type_uri) ); } } } $kv_args = $this->_getExtensionKVArgs($aliases); $ax_args = $this->_newArgs(); foreach ($zero_value_types as $attr_info) { $alias = $aliases->getAlias($attr_info->type_uri); $kv_args['type.' . $alias] = $attr_info->type_uri; $kv_args['count.' . $alias] = '0'; } $update_url = null; if ($request) { $update_url = $request->update_url; } else { $update_url = $this->update_url; } if ($update_url) { $ax_args['update_url'] = $update_url; } Auth_OpenID::update(&$ax_args, $kv_args); return $ax_args; } function parseExtensionArgs($ax_args) { $result = parent::parseExtensionArgs($ax_args); if (Auth_OpenID_AX::isError($result)) { return $result; } $this->update_url = Auth_OpenID::arrayGet($ax_args, 'update_url'); return true; } function fromSuccessResponse($success_response, $signed=true) { $obj = new Auth_OpenID_AX_FetchResponse(); if ($signed) { $ax_args = $success_response->getSignedNS($obj->ns_uri); } else { $ax_args = $success_response->message->getArgs($obj->ns_uri); } if ($ax_args === null || Auth_OpenID::isFailure($ax_args) || sizeof($ax_args) == 0) { return null; } $result = $obj->parseExtensionArgs($ax_args); if (Auth_OpenID_AX::isError($result)) { return null; } return $obj; } } class Auth_OpenID_AX_StoreRequest extends Auth_OpenID_AX_KeyValueMessage { var $mode = 'store_request'; function getExtensionArgs($aliases=null) { $ax_args = $this->_newArgs(); $kv_args = $this->_getExtensionKVArgs($aliases); Auth_OpenID::update(&$ax_args, $kv_args); return $ax_args; } } class Auth_OpenID_AX_StoreResponse extends Auth_OpenID_AX_Message { var $SUCCESS_MODE = 'store_response_success'; var $FAILURE_MODE = 'store_response_failure'; function &make($succeeded=true, $error_message=null) { if (($succeeded) && ($error_message !== null)) { return new Auth_OpenID_AX_Error('An error message may only be '. 'included in a failing fetch response'); } return new Auth_OpenID_AX_StoreResponse($succeeded, $error_message); } function Auth_OpenID_AX_StoreResponse($succeeded=true, $error_message=null) { if ($succeeded) { $this->mode = $this->SUCCESS_MODE; } else { $this->mode = $this->FAILURE_MODE; } $this->error_message = $error_message; } function succeeded() { return $this->mode == $this->SUCCESS_MODE; } function getExtensionArgs() { $ax_args = $this->_newArgs(); if ((!$this->succeeded()) && $this->error_message) { $ax_args['error'] = $this->error_message; } return $ax_args; } }    import('core.lib.openid.auth.openid.CryptUtil'); import('core.lib.openid.auth.OpenID'); class Auth_OpenID_MathLibrary { function longToBinary($long) { $cmp = $this->cmp($long, 0); if ($cmp < 0) { $msg = __FUNCTION__ . " takes only positive integers."; trigger_error($msg, E_USER_ERROR); return null; } if ($cmp == 0) { return "\x00"; } $bytes = array(); while ($this->cmp($long, 0) > 0) { array_unshift($bytes, $this->mod($long, 256)); $long = $this->div($long, pow(2, 8)); } if ($bytes && ($bytes[0] > 127)) { array_unshift($bytes, 0); } $string = ''; foreach ($bytes as $byte) { $string .= pack('C', $byte); } return $string; } function binaryToLong($str) { if ($str === null) { return null; } $bytes = array_merge(unpack('C*', $str)); $n = $this->init(0); if ($bytes && ($bytes[0] > 127)) { trigger_error("bytesToNum works only for positive integers.", E_USER_WARNING); return null; } foreach ($bytes as $byte) { $n = $this->mul($n, pow(2, 8)); $n = $this->add($n, $byte); } return $n; } function base64ToLong($str) { $b64 = base64_decode($str); if ($b64 === false) { return false; } return $this->binaryToLong($b64); } function longToBase64($str) { return base64_encode($this->longToBinary($str)); } function rand($stop) { static $duplicate_cache = array(); $rbytes = $this->longToBinary($stop); if (array_key_exists($rbytes, $duplicate_cache)) { list($duplicate, $nbytes) = $duplicate_cache[$rbytes]; } else { if ($rbytes[0] == "\x00") { $nbytes = Auth_OpenID::bytes($rbytes) - 1; } else { $nbytes = Auth_OpenID::bytes($rbytes); } $mxrand = $this->pow(256, $nbytes); $duplicate = $this->mod($mxrand, $stop); if (count($duplicate_cache) > 10) { $duplicate_cache = array(); } $duplicate_cache[$rbytes] = array($duplicate, $nbytes); } do { $bytes = "\x00" . Auth_OpenID_CryptUtil::getBytes($nbytes); $n = $this->binaryToLong($bytes); } while ($this->cmp($n, $duplicate) < 0); return $this->mod($n, $stop); } } class Auth_OpenID_BcMathWrapper extends Auth_OpenID_MathLibrary{ var $type = 'bcmath'; function add($x, $y) { return bcadd($x, $y); } function sub($x, $y) { return bcsub($x, $y); } function pow($base, $exponent) { return bcpow($base, $exponent); } function cmp($x, $y) { return bccomp($x, $y); } function init($number, $base = 10) { return $number; } function mod($base, $modulus) { return bcmod($base, $modulus); } function mul($x, $y) { return bcmul($x, $y); } function div($x, $y) { return bcdiv($x, $y); } function _powmod($base, $exponent, $modulus) { $square = $this->mod($base, $modulus); $result = 1; while($this->cmp($exponent, 0) > 0) { if ($this->mod($exponent, 2)) { $result = $this->mod($this->mul($result, $square), $modulus); } $square = $this->mod($this->mul($square, $square), $modulus); $exponent = $this->div($exponent, 2); } return $result; } function powmod($base, $exponent, $modulus) { if (function_exists('bcpowmod')) { return bcpowmod($base, $exponent, $modulus); } else { return $this->_powmod($base, $exponent, $modulus); } } function toString($num) { return $num; } } class Auth_OpenID_GmpMathWrapper extends Auth_OpenID_MathLibrary{ var $type = 'gmp'; function add($x, $y) { return gmp_add($x, $y); } function sub($x, $y) { return gmp_sub($x, $y); } function pow($base, $exponent) { return gmp_pow($base, $exponent); } function cmp($x, $y) { return gmp_cmp($x, $y); } function init($number, $base = 10) { return gmp_init($number, $base); } function mod($base, $modulus) { return gmp_mod($base, $modulus); } function mul($x, $y) { return gmp_mul($x, $y); } function div($x, $y) { return gmp_div_q($x, $y); } function powmod($base, $exponent, $modulus) { return gmp_powm($base, $exponent, $modulus); } function toString($num) { return gmp_strval($num); } } function Auth_OpenID_math_extensions() { $result = array(); if (!defined('Auth_OpenID_BUGGY_GMP')) { $result[] = array('modules' => array('gmp', 'php_gmp'), 'extension' => 'gmp', 'class' => 'Auth_OpenID_GmpMathWrapper'); } $result[] = array( 'modules' => array('bcmath', 'php_bcmath'), 'extension' => 'bcmath', 'class' => 'Auth_OpenID_BcMathWrapper'); return $result; } function Auth_OpenID_detectMathLibrary($exts) { $loaded = false; foreach ($exts as $extension) { if ($extension['extension'] && extension_loaded($extension['extension'])) { $loaded = true; } if (!$loaded) { foreach ($extension['modules'] as $module) { if (@dl($module . "." . PHP_SHLIB_SUFFIX)) { $loaded = true; break; } } } if ($loaded) { return $extension; } } return false; } function &Auth_OpenID_getMathLib() { static $lib = null; if (isset($lib)) { return $lib; } if (Auth_OpenID_noMathSupport()) { $null = null; return $null; } $ext = Auth_OpenID_detectMathLibrary(Auth_OpenID_math_extensions()); if ($ext === false) { $tried = array(); foreach (Auth_OpenID_math_extensions() as $extinfo) { $tried[] = $extinfo['extension']; } $triedstr = implode(", ", $tried); Auth_OpenID_setNoMathSupport(); $result = null; return $result; } $class = $ext['class']; $lib = new $class(); return $lib; } function Auth_OpenID_setNoMathSupport() { if (!defined('Auth_OpenID_NO_MATH_SUPPORT')) { define('Auth_OpenID_NO_MATH_SUPPORT', true); } } function Auth_OpenID_noMathSupport() { return defined('Auth_OpenID_NO_MATH_SUPPORT'); }     import('core.lib.openid.auth.OpenID'); import('core.lib.openid.auth.openid.Message'); import('core.lib.openid.auth.openid.HMAC'); import('core.lib.openid.auth.openid.Association'); import('core.lib.openid.auth.openid.CryptUtil'); import('core.lib.openid.auth.openid.DiffieHellman'); import('core.lib.openid.auth.openid.KVForm'); import('core.lib.openid.auth.openid.Nonce'); import('core.lib.openid.auth.openid.Discover'); import('core.lib.openid.auth.openid.URINorm'); import('core.lib.openid.auth.yadis.Manager'); import('core.lib.openid.auth.yadis.XRI'); define('Auth_OpenID_SUCCESS', 'success'); define('Auth_OpenID_CANCEL', 'cancel'); define('Auth_OpenID_FAILURE', 'failure'); define('Auth_OpenID_SETUP_NEEDED', 'setup needed'); define('Auth_OpenID_PARSE_ERROR', 'parse error'); class Auth_OpenID_Consumer { var $discoverMethod = 'Auth_OpenID_discover'; var $session_key_prefix = "_openid_consumer_"; var $_token_suffix = "last_token"; function Auth_OpenID_Consumer(&$store, $session = null, $consumer_cls = null) { if ($session === null) { $session = new Auth_Yadis_PHPSession(); } $this->session =& $session; if ($consumer_cls !== null) { $this->consumer =& new $consumer_cls($store); } else { $this->consumer =& new Auth_OpenID_GenericConsumer($store); } $this->_token_key = $this->session_key_prefix . $this->_token_suffix; } function getDiscoveryObject(&$session, $openid_url, $session_key_prefix) { return new Auth_Yadis_Discovery($session, $openid_url, $session_key_prefix); } function begin($user_url, $anonymous=false) { $openid_url = $user_url; $disco = $this->getDiscoveryObject($this->session, $openid_url, $this->session_key_prefix); $m = $disco->getManager(); $loader = new Auth_Yadis_ManagerLoader(); if ($m) { if ($m->stale) { $disco->destroyManager(); } else { $m->stale = true; $disco->session->set($disco->session_key, serialize($loader->toSession($m))); } } $endpoint = $disco->getNextService($this->discoverMethod, $this->consumer->fetcher); $m =& $disco->getManager(); if ($m) { $m->stale = false; $disco->session->set($disco->session_key, serialize($loader->toSession($m))); } if ($endpoint === null) { return null; } else { return $this->beginWithoutDiscovery($endpoint, $anonymous); } } function &beginWithoutDiscovery($endpoint, $anonymous=false) { $loader = new Auth_OpenID_ServiceEndpointLoader(); $auth_req = $this->consumer->begin($endpoint); $this->session->set($this->_token_key, $loader->toSession($auth_req->endpoint)); if (!$auth_req->setAnonymous($anonymous)) { return new Auth_OpenID_FailureResponse(null, "OpenID 1 requests MUST include the identifier " . "in the request."); } return $auth_req; } function complete($current_url, $query=null) { if ($current_url && !is_string($current_url)) { trigger_error("current_url must be a string; see NEWS file " . "for upgrading notes.", E_USER_ERROR); } if ($query === null) { $query = Auth_OpenID::getQuery(); } $loader = new Auth_OpenID_ServiceEndpointLoader(); $endpoint_data = $this->session->get($this->_token_key); $endpoint = $loader->fromSession($endpoint_data); $message = Auth_OpenID_Message::fromPostArgs($query); $response = $this->consumer->complete($message, $endpoint, $current_url); $this->session->del($this->_token_key); if (in_array($response->status, array(Auth_OpenID_SUCCESS, Auth_OpenID_CANCEL))) { if ($response->identity_url !== null) { $disco = $this->getDiscoveryObject($this->session, $response->identity_url, $this->session_key_prefix); $disco->cleanup(true); } } return $response; } } class Auth_OpenID_DiffieHellmanSHA1ConsumerSession { var $session_type = 'DH-SHA1'; var $hash_func = 'Auth_OpenID_SHA1'; var $secret_size = 20; var $allowed_assoc_types = array('HMAC-SHA1'); function Auth_OpenID_DiffieHellmanSHA1ConsumerSession($dh = null) { if ($dh === null) { $dh = new Auth_OpenID_DiffieHellman(); } $this->dh = $dh; } function getRequest() { $math =& Auth_OpenID_getMathLib(); $cpub = $math->longToBase64($this->dh->public); $args = array('dh_consumer_public' => $cpub); if (!$this->dh->usingDefaultValues()) { $args = array_merge($args, array( 'dh_modulus' => $math->longToBase64($this->dh->mod), 'dh_gen' => $math->longToBase64($this->dh->gen))); } return $args; } function extractSecret($response) { if (!$response->hasKey(Auth_OpenID_OPENID_NS, 'dh_server_public')) { return null; } if (!$response->hasKey(Auth_OpenID_OPENID_NS, 'enc_mac_key')) { return null; } $math =& Auth_OpenID_getMathLib(); $spub = $math->base64ToLong($response->getArg(Auth_OpenID_OPENID_NS, 'dh_server_public')); $enc_mac_key = base64_decode($response->getArg(Auth_OpenID_OPENID_NS, 'enc_mac_key')); return $this->dh->xorSecret($spub, $enc_mac_key, $this->hash_func); } } class Auth_OpenID_DiffieHellmanSHA256ConsumerSession extends Auth_OpenID_DiffieHellmanSHA1ConsumerSession { var $session_type = 'DH-SHA256'; var $hash_func = 'Auth_OpenID_SHA256'; var $secret_size = 32; var $allowed_assoc_types = array('HMAC-SHA256'); } class Auth_OpenID_PlainTextConsumerSession { var $session_type = 'no-encryption'; var $allowed_assoc_types = array('HMAC-SHA1', 'HMAC-SHA256'); function getRequest() { return array(); } function extractSecret($response) { if (!$response->hasKey(Auth_OpenID_OPENID_NS, 'mac_key')) { return null; } return base64_decode($response->getArg(Auth_OpenID_OPENID_NS, 'mac_key')); } } function Auth_OpenID_getAvailableSessionTypes() { $types = array( 'no-encryption' => 'Auth_OpenID_PlainTextConsumerSession', 'DH-SHA1' => 'Auth_OpenID_DiffieHellmanSHA1ConsumerSession', 'DH-SHA256' => 'Auth_OpenID_DiffieHellmanSHA256ConsumerSession'); return $types; } class Auth_OpenID_GenericConsumer { var $discoverMethod = 'Auth_OpenID_discover'; var $store; var $_use_assocs; var $openid1_nonce_query_arg_name = 'janrain_nonce'; var $openid1_return_to_identifier_name = 'openid1_claimed_id'; function Auth_OpenID_GenericConsumer(&$store) { $this->store =& $store; $this->negotiator =& Auth_OpenID_getDefaultNegotiator(); $this->_use_assocs = ($this->store ? true : false); $this->fetcher = Auth_Yadis_Yadis::getHTTPFetcher(); $this->session_types = Auth_OpenID_getAvailableSessionTypes(); } function begin($service_endpoint) { $assoc = $this->_getAssociation($service_endpoint); $r = new Auth_OpenID_AuthRequest($service_endpoint, $assoc); $r->return_to_args[$this->openid1_nonce_query_arg_name] = Auth_OpenID_mkNonce(); if ($r->message->isOpenID1()) { $r->return_to_args[$this->openid1_return_to_identifier_name] = $r->endpoint->claimed_id; } return $r; } function complete($message, $endpoint, $return_to) { $mode = $message->getArg(Auth_OpenID_OPENID_NS, 'mode', '<no mode set>'); $mode_methods = array( 'cancel' => '_complete_cancel', 'error' => '_complete_error', 'setup_needed' => '_complete_setup_needed', 'id_res' => '_complete_id_res', ); $method = Auth_OpenID::arrayGet($mode_methods, $mode, '_completeInvalid'); return call_user_func_array(array(&$this, $method), array($message, $endpoint, $return_to)); } function _completeInvalid($message, &$endpoint, $unused) { $mode = $message->getArg(Auth_OpenID_OPENID_NS, 'mode', '<No mode set>'); return new Auth_OpenID_FailureResponse($endpoint, sprintf("Invalid openid.mode '%s'", $mode)); } function _complete_cancel($message, &$endpoint, $unused) { return new Auth_OpenID_CancelResponse($endpoint); } function _complete_error($message, &$endpoint, $unused) { $error = $message->getArg(Auth_OpenID_OPENID_NS, 'error'); $contact = $message->getArg(Auth_OpenID_OPENID_NS, 'contact'); $reference = $message->getArg(Auth_OpenID_OPENID_NS, 'reference'); return new Auth_OpenID_FailureResponse($endpoint, $error, $contact, $reference); } function _complete_setup_needed($message, &$endpoint, $unused) { if (!$message->isOpenID2()) { return $this->_completeInvalid($message, $endpoint); } return new Auth_OpenID_SetupNeededResponse($endpoint); } function _complete_id_res($message, &$endpoint, $return_to) { $user_setup_url = $message->getArg(Auth_OpenID_OPENID1_NS, 'user_setup_url'); if ($this->_checkSetupNeeded($message)) { return new Auth_OpenID_SetupNeededResponse( $endpoint, $user_setup_url); } else { return $this->_doIdRes($message, $endpoint, $return_to); } } function _checkSetupNeeded($message) { if ($message->isOpenID1()) { $user_setup_url = $message->getArg(Auth_OpenID_OPENID1_NS, 'user_setup_url'); if ($user_setup_url !== null) { return true; } } return false; } function _doIdRes($message, $endpoint, $return_to) { $result = $this->_idResCheckForFields($message); if (Auth_OpenID::isFailure($result)) { return $result; } if (!$this->_checkReturnTo($message, $return_to)) { return new Auth_OpenID_FailureResponse(null, sprintf("return_to does not match return URL. Expected %s, got %s", $return_to, $message->getArg(Auth_OpenID_OPENID_NS, 'return_to'))); } $result = $this->_verifyDiscoveryResults($message, $endpoint); if (Auth_OpenID::isFailure($result)) { return $result; } $endpoint = $result; $result = $this->_idResCheckSignature($message, $endpoint->server_url); if (Auth_OpenID::isFailure($result)) { return $result; } $result = $this->_idResCheckNonce($message, $endpoint); if (Auth_OpenID::isFailure($result)) { return $result; } $signed_list_str = $message->getArg(Auth_OpenID_OPENID_NS, 'signed', Auth_OpenID_NO_DEFAULT); if (Auth_OpenID::isFailure($signed_list_str)) { return $signed_list_str; } $signed_list = explode(',', $signed_list_str); $signed_fields = Auth_OpenID::addPrefix($signed_list, "openid."); return new Auth_OpenID_SuccessResponse($endpoint, $message, $signed_fields); } function _checkReturnTo($message, $return_to) { $result = Auth_OpenID_GenericConsumer::_verifyReturnToArgs( $message->toPostArgs()); if (Auth_OpenID::isFailure($result)) { return false; } $msg_return_to = $message->getArg(Auth_OpenID_OPENID_NS, 'return_to'); if (Auth_OpenID::isFailure($return_to)) { return false; } $return_to_parts = parse_url(Auth_OpenID_urinorm($return_to)); $msg_return_to_parts = parse_url(Auth_OpenID_urinorm($msg_return_to)); if ((!array_key_exists('port', $return_to_parts)) && (!array_key_exists('port', $msg_return_to_parts))) { $return_to_parts['port'] = null; $msg_return_to_parts['port'] = null; } if ((!array_key_exists('path', $return_to_parts)) && (!array_key_exists('path', $msg_return_to_parts))) { $return_to_parts['path'] = null; $msg_return_to_parts['path'] = null; } foreach (array('scheme', 'host', 'port', 'path') as $component) { if (!array_key_exists($component, $return_to_parts)) { return false; } if (!array_key_exists($component, $msg_return_to_parts)) { return false; } if (Auth_OpenID::arrayGet($return_to_parts, $component) !== Auth_OpenID::arrayGet($msg_return_to_parts, $component)) { return false; } } return true; } function _verifyReturnToArgs($query) { $message = Auth_OpenID_Message::fromPostArgs($query); $return_to = $message->getArg(Auth_OpenID_OPENID_NS, 'return_to'); if (Auth_OpenID::isFailure($return_to)) { return $return_to; } if (!$return_to) { return new Auth_OpenID_FailureResponse(null, "Response has no return_to"); } $parsed_url = parse_url($return_to); $q = array(); if (array_key_exists('query', $parsed_url)) { $rt_query = $parsed_url['query']; $q = Auth_OpenID::parse_str($rt_query); } foreach ($q as $rt_key => $rt_value) { if (!array_key_exists($rt_key, $query)) { return new Auth_OpenID_FailureResponse(null, sprintf("return_to parameter %s absent from query", $rt_key)); } else { $value = $query[$rt_key]; if ($rt_value != $value) { return new Auth_OpenID_FailureResponse(null, sprintf("parameter %s value %s does not match " . "return_to value %s", $rt_key, $value, $rt_value)); } } } $bare_args = $message->getArgs(Auth_OpenID_BARE_NS); foreach ($bare_args as $key => $value) { if (Auth_OpenID::arrayGet($q, $key) != $value) { return new Auth_OpenID_FailureResponse(null, sprintf("Parameter %s = %s not in return_to URL", $key, $value)); } } return true; } function _idResCheckSignature($message, $server_url) { $assoc_handle = $message->getArg(Auth_OpenID_OPENID_NS, 'assoc_handle'); if (Auth_OpenID::isFailure($assoc_handle)) { return $assoc_handle; } $assoc = $this->store->getAssociation($server_url, $assoc_handle); if ($assoc) { if ($assoc->getExpiresIn() <= 0) { return new Auth_OpenID_FailureResponse(null, 'Association with ' . $server_url . ' expired'); } if (!$assoc->checkMessageSignature($message)) { return new Auth_OpenID_FailureResponse(null, "Bad signature"); } } else { if (!$this->_checkAuth($message, $server_url)) { return new Auth_OpenID_FailureResponse(null, "Server denied check_authentication"); } } return null; } function _verifyDiscoveryResults($message, $endpoint=null) { if ($message->getOpenIDNamespace() == Auth_OpenID_OPENID2_NS) { return $this->_verifyDiscoveryResultsOpenID2($message, $endpoint); } else { return $this->_verifyDiscoveryResultsOpenID1($message, $endpoint); } } function _verifyDiscoveryResultsOpenID1($message, $endpoint) { $claimed_id = $message->getArg(Auth_OpenID_BARE_NS, $this->openid1_return_to_identifier_name); if (($endpoint === null) && ($claimed_id === null)) { return new Auth_OpenID_FailureResponse($endpoint, 'When using OpenID 1, the claimed ID must be supplied, ' . 'either by passing it through as a return_to parameter ' . 'or by using a session, and supplied to the GenericConsumer ' . 'as the argument to complete()'); } else if (($endpoint !== null) && ($claimed_id === null)) { $claimed_id = $endpoint->claimed_id; } $to_match = new Auth_OpenID_ServiceEndpoint(); $to_match->type_uris = array(Auth_OpenID_TYPE_1_1); $to_match->local_id = $message->getArg(Auth_OpenID_OPENID1_NS, 'identity'); $to_match->claimed_id = $claimed_id; if ($to_match->local_id === null) { return new Auth_OpenID_FailureResponse($endpoint, "Missing required field openid.identity"); } $to_match_1_0 = $to_match->copy(); $to_match_1_0->type_uris = array(Auth_OpenID_TYPE_1_0); if ($endpoint !== null) { $result = $this->_verifyDiscoverySingle($endpoint, $to_match); if (is_a($result, 'Auth_OpenID_TypeURIMismatch')) { $result = $this->_verifyDiscoverySingle($endpoint, $to_match_1_0); } if (Auth_OpenID::isFailure($result)) { } else { return $endpoint; } } return $this->_discoverAndVerify($to_match->claimed_id, array($to_match, $to_match_1_0)); } function _verifyDiscoverySingle($endpoint, $to_match) { foreach ($to_match->type_uris as $type_uri) { if (!$endpoint->usesExtension($type_uri)) { return new Auth_OpenID_TypeURIMismatch($endpoint, "Required type ".$type_uri." not present"); } } list($defragged_claimed_id, $_) = Auth_OpenID::urldefrag($to_match->claimed_id); if ($defragged_claimed_id != $endpoint->claimed_id) { return new Auth_OpenID_FailureResponse($endpoint, sprintf('Claimed ID does not match (different subjects!), ' . 'Expected %s, got %s', $defragged_claimed_id, $endpoint->claimed_id)); } if ($to_match->getLocalID() != $endpoint->getLocalID()) { return new Auth_OpenID_FailureResponse($endpoint, sprintf('local_id mismatch. Expected %s, got %s', $to_match->getLocalID(), $endpoint->getLocalID())); } if ($to_match->server_url === null) { if ($to_match->preferredNamespace() != Auth_OpenID_OPENID1_NS) { return new Auth_OpenID_FailureResponse($endpoint, "Preferred namespace mismatch (bug)"); } } else if ($to_match->server_url != $endpoint->server_url) { return new Auth_OpenID_FailureResponse($endpoint, sprintf('OP Endpoint mismatch. Expected %s, got %s', $to_match->server_url, $endpoint->server_url)); } return null; } function _verifyDiscoveryResultsOpenID2($message, $endpoint) { $to_match = new Auth_OpenID_ServiceEndpoint(); $to_match->type_uris = array(Auth_OpenID_TYPE_2_0); $to_match->claimed_id = $message->getArg(Auth_OpenID_OPENID2_NS, 'claimed_id'); $to_match->local_id = $message->getArg(Auth_OpenID_OPENID2_NS, 'identity'); $to_match->server_url = $message->getArg(Auth_OpenID_OPENID2_NS, 'op_endpoint'); if ($to_match->server_url === null) { return new Auth_OpenID_FailureResponse($endpoint, "OP Endpoint URL missing"); } if (($to_match->claimed_id === null) && ($to_match->local_id !== null)) { return new Auth_OpenID_FailureResponse($endpoint, 'openid.identity is present without openid.claimed_id'); } if (($to_match->claimed_id !== null) && ($to_match->local_id === null)) { return new Auth_OpenID_FailureResponse($endpoint, 'openid.claimed_id is present without openid.identity'); } if ($to_match->claimed_id === null) { return Auth_OpenID_ServiceEndpoint::fromOPEndpointURL( $to_match->server_url); } if (!$endpoint) { return $this->_discoverAndVerify($to_match->claimed_id, array($to_match)); } else { $result = $this->_verifyDiscoverySingle($endpoint, $to_match); if (Auth_OpenID::isFailure($result)) { $endpoint = $this->_discoverAndVerify($to_match->claimed_id, array($to_match)); if (Auth_OpenID::isFailure($endpoint)) { return $endpoint; } } } if ($endpoint->claimed_id != $to_match->claimed_id) { $endpoint->claimed_id = $to_match->claimed_id; } return $endpoint; } function _discoverAndVerify($claimed_id, $to_match_endpoints) { list($unused, $services) = call_user_func($this->discoverMethod, $claimed_id, $this->fetcher); if (!$services) { return new Auth_OpenID_FailureResponse(null, sprintf("No OpenID information found at %s", $claimed_id)); } return $this->_verifyDiscoveryServices($claimed_id, $services, $to_match_endpoints); } function _verifyDiscoveryServices($claimed_id, &$services, &$to_match_endpoints) { foreach ($services as $endpoint) { foreach ($to_match_endpoints as $to_match_endpoint) { $result = $this->_verifyDiscoverySingle($endpoint, $to_match_endpoint); if (!Auth_OpenID::isFailure($result)) { return $endpoint; } } } return new Auth_OpenID_FailureResponse(null, sprintf('No matching endpoint found after discovering %s', $claimed_id)); } function _idResGetNonceOpenID1($message, $endpoint) { return $message->getArg(Auth_OpenID_BARE_NS, $this->openid1_nonce_query_arg_name); } function _idResCheckNonce($message, $endpoint) { if ($message->isOpenID1()) { $nonce = $this->_idResGetNonceOpenID1($message, $endpoint); $server_url = ''; } else { $nonce = $message->getArg(Auth_OpenID_OPENID2_NS, 'response_nonce'); $server_url = $endpoint->server_url; } if ($nonce === null) { return new Auth_OpenID_FailureResponse($endpoint, "Nonce missing from response"); } $parts = Auth_OpenID_splitNonce($nonce); if ($parts === null) { return new Auth_OpenID_FailureResponse($endpoint, "Malformed nonce in response"); } list($timestamp, $salt) = $parts; if (!$this->store->useNonce($server_url, $timestamp, $salt)) { return new Auth_OpenID_FailureResponse($endpoint, "Nonce already used or out of range"); } return null; } function _idResCheckForFields($message) { $basic_fields = array('return_to', 'assoc_handle', 'sig', 'signed'); $basic_sig_fields = array('return_to', 'identity'); $require_fields = array( Auth_OpenID_OPENID2_NS => array_merge($basic_fields, array('op_endpoint')), Auth_OpenID_OPENID1_NS => array_merge($basic_fields, array('identity')) ); $require_sigs = array( Auth_OpenID_OPENID2_NS => array_merge($basic_sig_fields, array('response_nonce', 'claimed_id', 'assoc_handle')), Auth_OpenID_OPENID1_NS => array_merge($basic_sig_fields, array('nonce')) ); foreach ($require_fields[$message->getOpenIDNamespace()] as $field) { if (!$message->hasKey(Auth_OpenID_OPENID_NS, $field)) { return new Auth_OpenID_FailureResponse(null, "Missing required field '".$field."'"); } } $signed_list_str = $message->getArg(Auth_OpenID_OPENID_NS, 'signed', Auth_OpenID_NO_DEFAULT); if (Auth_OpenID::isFailure($signed_list_str)) { return $signed_list_str; } $signed_list = explode(',', $signed_list_str); foreach ($require_sigs[$message->getOpenIDNamespace()] as $field) { if ($message->hasKey(Auth_OpenID_OPENID_NS, $field) && (!in_array($field, $signed_list))) { return new Auth_OpenID_FailureResponse(null, "'".$field."' not signed"); } } return null; } function _checkAuth($message, $server_url) { $request = $this->_createCheckAuthRequest($message); if ($request === null) { return false; } $resp_message = $this->_makeKVPost($request, $server_url); if (($resp_message === null) || (is_a($resp_message, 'Auth_OpenID_ServerErrorContainer'))) { return false; } return $this->_processCheckAuthResponse($resp_message, $server_url); } function _createCheckAuthRequest($message) { $signed = $message->getArg(Auth_OpenID_OPENID_NS, 'signed'); if ($signed) { foreach (explode(',', $signed) as $k) { $value = $message->getAliasedArg($k); if ($value === null) { return null; } } } $ca_message = $message->copy(); $ca_message->setArg(Auth_OpenID_OPENID_NS, 'mode', 'check_authentication'); return $ca_message; } function _processCheckAuthResponse($response, $server_url) { $is_valid = $response->getArg(Auth_OpenID_OPENID_NS, 'is_valid', 'false'); $invalidate_handle = $response->getArg(Auth_OpenID_OPENID_NS, 'invalidate_handle'); if ($invalidate_handle !== null) { $this->store->removeAssociation($server_url, $invalidate_handle); } if ($is_valid == 'true') { return true; } return false; } function _httpResponseToMessage($response, $server_url) { $response_message = Auth_OpenID_Message::fromKVForm($response->body); if ($response->status == 400) { return Auth_OpenID_ServerErrorContainer::fromMessage( $response_message); } else if ($response->status != 200 and $response->status != 206) { return null; } return $response_message; } function _makeKVPost($message, $server_url) { $body = $message->toURLEncoded(); $resp = $this->fetcher->post($server_url, $body); if ($resp === null) { return null; } return $this->_httpResponseToMessage($resp, $server_url); } function _getAssociation($endpoint) { if (!$this->_use_assocs) { return null; } $assoc = $this->store->getAssociation($endpoint->server_url); if (($assoc === null) || ($assoc->getExpiresIn() <= 0)) { $assoc = $this->_negotiateAssociation($endpoint); if ($assoc !== null) { $this->store->storeAssociation($endpoint->server_url, $assoc); } } return $assoc; } function _extractSupportedAssociationType(&$server_error, &$endpoint, $assoc_type) { if (($server_error->error_code != 'unsupported-type') || ($server_error->message->isOpenID1())) { return null; } $assoc_type = $server_error->message->getArg(Auth_OpenID_OPENID_NS, 'assoc_type'); $session_type = $server_error->message->getArg(Auth_OpenID_OPENID_NS, 'session_type'); if (($assoc_type === null) || ($session_type === null)) { return null; } else if (!$this->negotiator->isAllowed($assoc_type, $session_type)) { return null; } else { return array($assoc_type, $session_type); } } function _negotiateAssociation($endpoint) { list($assoc_type, $session_type) = $this->negotiator->getAllowedType(); $assoc = $this->_requestAssociation( $endpoint, $assoc_type, $session_type); if (Auth_OpenID::isFailure($assoc)) { return null; } if (is_a($assoc, 'Auth_OpenID_ServerErrorContainer')) { $why = $assoc; $supportedTypes = $this->_extractSupportedAssociationType( $why, $endpoint, $assoc_type); if ($supportedTypes !== null) { list($assoc_type, $session_type) = $supportedTypes; $assoc = $this->_requestAssociation( $endpoint, $assoc_type, $session_type); if (is_a($assoc, 'Auth_OpenID_ServerErrorContainer')) { return null; } else { return $assoc; } } else { return null; } } else { return $assoc; } } function _requestAssociation($endpoint, $assoc_type, $session_type) { list($assoc_session, $args) = $this->_createAssociateRequest( $endpoint, $assoc_type, $session_type); $response_message = $this->_makeKVPost($args, $endpoint->server_url); if ($response_message === null) { return null; } else if (is_a($response_message, 'Auth_OpenID_ServerErrorContainer')) { return $response_message; } return $this->_extractAssociation($response_message, $assoc_session); } function _extractAssociation(&$assoc_response, &$assoc_session) { $assoc_type = $assoc_response->getArg( Auth_OpenID_OPENID_NS, 'assoc_type', Auth_OpenID_NO_DEFAULT); if (Auth_OpenID::isFailure($assoc_type)) { return $assoc_type; } $assoc_handle = $assoc_response->getArg( Auth_OpenID_OPENID_NS, 'assoc_handle', Auth_OpenID_NO_DEFAULT); if (Auth_OpenID::isFailure($assoc_handle)) { return $assoc_handle; } $expires_in_str = $assoc_response->getArg( Auth_OpenID_OPENID_NS, 'expires_in', Auth_OpenID_NO_DEFAULT); if (Auth_OpenID::isFailure($expires_in_str)) { return $expires_in_str; } $expires_in = Auth_OpenID::intval($expires_in_str); if ($expires_in === false) { $err = sprintf("Could not parse expires_in from association ". "response %s", print_r($assoc_response, true)); return new Auth_OpenID_FailureResponse(null, $err); } if ($assoc_response->isOpenID1()) { $session_type = $this->_getOpenID1SessionType($assoc_response); } else { $session_type = $assoc_response->getArg( Auth_OpenID_OPENID2_NS, 'session_type', Auth_OpenID_NO_DEFAULT); if (Auth_OpenID::isFailure($session_type)) { return $session_type; } } if ($assoc_session->session_type != $session_type) { if ($assoc_response->isOpenID1() && ($session_type == 'no-encryption')) { $assoc_session = new Auth_OpenID_PlainTextConsumerSession(); } else { return null; } } if (!in_array($assoc_type, $assoc_session->allowed_assoc_types)) { return null; } $secret = $assoc_session->extractSecret($assoc_response); if ($secret === null) { return null; } return Auth_OpenID_Association::fromExpiresIn( $expires_in, $assoc_handle, $secret, $assoc_type); } function _createAssociateRequest($endpoint, $assoc_type, $session_type) { if (array_key_exists($session_type, $this->session_types)) { $session_type_class = $this->session_types[$session_type]; if (is_callable($session_type_class)) { $assoc_session = $session_type_class(); } else { $assoc_session = new $session_type_class(); } } else { return null; } $args = array( 'mode' => 'associate', 'assoc_type' => $assoc_type); if (!$endpoint->compatibilityMode()) { $args['ns'] = Auth_OpenID_OPENID2_NS; } if ((!$endpoint->compatibilityMode()) || ($assoc_session->session_type != 'no-encryption')) { $args['session_type'] = $assoc_session->session_type; } $args = array_merge($args, $assoc_session->getRequest()); $message = Auth_OpenID_Message::fromOpenIDArgs($args); return array($assoc_session, $message); } function _getOpenID1SessionType($assoc_response) { $session_type = $assoc_response->getArg(Auth_OpenID_OPENID1_NS, 'session_type'); if ($session_type == 'no-encryption') { } else if (($session_type == '') || ($session_type === null)) { $session_type = 'no-encryption'; } return $session_type; } } class Auth_OpenID_AuthRequest { function Auth_OpenID_AuthRequest(&$endpoint, $assoc) { $this->assoc = $assoc; $this->endpoint =& $endpoint; $this->return_to_args = array(); $this->message = new Auth_OpenID_Message( $endpoint->preferredNamespace()); $this->_anonymous = false; } function addExtension(&$extension_request) { $extension_request->toMessage($this->message); } function addExtensionArg($namespace, $key, $value) { return $this->message->setArg($namespace, $key, $value); } function setAnonymous($is_anonymous) { if ($is_anonymous && $this->message->isOpenID1()) { return false; } else { $this->_anonymous = $is_anonymous; return true; } } function getMessage($realm, $return_to=null, $immediate=false) { if ($return_to) { $return_to = Auth_OpenID::appendArgs($return_to, $this->return_to_args); } else if ($immediate) { return new Auth_OpenID_FailureResponse(null, "'return_to' is mandatory when using checkid_immediate"); } else if ($this->message->isOpenID1()) { return new Auth_OpenID_FailureResponse(null, "'return_to' is mandatory for OpenID 1 requests"); } else if ($this->return_to_args) { return new Auth_OpenID_FailureResponse(null, "extra 'return_to' arguments where specified, " . "but no return_to was specified"); } if ($immediate) { $mode = 'checkid_immediate'; } else { $mode = 'checkid_setup'; } $message = $this->message->copy(); if ($message->isOpenID1()) { $realm_key = 'trust_root'; } else { $realm_key = 'realm'; } $message->updateArgs(Auth_OpenID_OPENID_NS, array( $realm_key => $realm, 'mode' => $mode, 'return_to' => $return_to)); if (!$this->_anonymous) { if ($this->endpoint->isOPIdentifier()) { $claimed_id = $request_identity = Auth_OpenID_IDENTIFIER_SELECT; } else { $request_identity = $this->endpoint->getLocalID(); $claimed_id = $this->endpoint->claimed_id; } $message->setArg(Auth_OpenID_OPENID_NS, 'identity', $request_identity); if ($message->isOpenID2()) { $message->setArg(Auth_OpenID_OPENID2_NS, 'claimed_id', $claimed_id); } } if ($this->assoc) { $message->setArg(Auth_OpenID_OPENID_NS, 'assoc_handle', $this->assoc->handle); } return $message; } function redirectURL($realm, $return_to = null, $immediate = false) { $message = $this->getMessage($realm, $return_to, $immediate); if (Auth_OpenID::isFailure($message)) { return $message; } return $message->toURL($this->endpoint->server_url); } function formMarkup($realm, $return_to=null, $immediate=false, $form_tag_attrs=null) { $message = $this->getMessage($realm, $return_to, $immediate); if (Auth_OpenID::isFailure($message)) { return $message; } return $message->toFormMarkup($this->endpoint->server_url, $form_tag_attrs); } function htmlMarkup($realm, $return_to=null, $immediate=false, $form_tag_attrs=null) { $form = $this->formMarkup($realm, $return_to, $immediate, $form_tag_attrs); if (Auth_OpenID::isFailure($form)) { return $form; } return Auth_OpenID::autoSubmitHTML($form); } function shouldSendRedirect() { return $this->endpoint->compatibilityMode(); } } class Auth_OpenID_ConsumerResponse { var $status = null; function setEndpoint($endpoint) { $this->endpoint = $endpoint; if ($endpoint === null) { $this->identity_url = null; } else { $this->identity_url = $endpoint->claimed_id; } } function getDisplayIdentifier() { if ($this->endpoint !== null) { return $this->endpoint->getDisplayIdentifier(); } return null; } } class Auth_OpenID_SuccessResponse extends Auth_OpenID_ConsumerResponse { var $status = Auth_OpenID_SUCCESS; function Auth_OpenID_SuccessResponse($endpoint, $message, $signed_args=null) { $this->endpoint = $endpoint; $this->identity_url = $endpoint->claimed_id; $this->signed_args = $signed_args; $this->message = $message; if ($this->signed_args === null) { $this->signed_args = array(); } } function extensionResponse($namespace_uri, $require_signed) { if ($require_signed) { return $this->getSignedNS($namespace_uri); } else { return $this->message->getArgs($namespace_uri); } } function isOpenID1() { return $this->message->isOpenID1(); } function isSigned($ns_uri, $ns_key) { return in_array($this->message->getKey($ns_uri, $ns_key), $this->signed_args); } function getSigned($ns_uri, $ns_key, $default = null) { if ($this->isSigned($ns_uri, $ns_key)) { return $this->message->getArg($ns_uri, $ns_key, $default); } else { return $default; } } function getSignedNS($ns_uri) { $args = array(); $msg_args = $this->message->getArgs($ns_uri); if (Auth_OpenID::isFailure($msg_args)) { return null; } foreach ($msg_args as $key => $value) { if (!$this->isSigned($ns_uri, $key)) { return null; } } return $msg_args; } function getReturnTo() { return $this->getSigned(Auth_OpenID_OPENID_NS, 'return_to'); } } class Auth_OpenID_FailureResponse extends Auth_OpenID_ConsumerResponse { var $status = Auth_OpenID_FAILURE; function Auth_OpenID_FailureResponse($endpoint, $message = null, $contact = null, $reference = null) { $this->setEndpoint($endpoint); $this->message = $message; $this->contact = $contact; $this->reference = $reference; } } class Auth_OpenID_TypeURIMismatch extends Auth_OpenID_FailureResponse { } class Auth_OpenID_ServerErrorContainer { function Auth_OpenID_ServerErrorContainer($error_text, $error_code, $message) { $this->error_text = $error_text; $this->error_code = $error_code; $this->message = $message; } function fromMessage($message) { $error_text = $message->getArg( Auth_OpenID_OPENID_NS, 'error', '<no error message supplied>'); $error_code = $message->getArg(Auth_OpenID_OPENID_NS, 'error_code'); return new Auth_OpenID_ServerErrorContainer($error_text, $error_code, $message); } } class Auth_OpenID_CancelResponse extends Auth_OpenID_ConsumerResponse { var $status = Auth_OpenID_CANCEL; function Auth_OpenID_CancelResponse($endpoint) { $this->setEndpoint($endpoint); } } class Auth_OpenID_SetupNeededResponse extends Auth_OpenID_ConsumerResponse { var $status = Auth_OpenID_SETUP_NEEDED; function Auth_OpenID_SetupNeededResponse($endpoint, $setup_url = null) { $this->setEndpoint($endpoint); $this->setup_url = $setup_url; } }     if (!defined('Auth_OpenID_RAND_SOURCE')) { define('Auth_OpenID_RAND_SOURCE', null); } class Auth_OpenID_CryptUtil { function getBytes($num_bytes) { static $f = null; $bytes = ''; if ($f === null) { if (Auth_OpenID_RAND_SOURCE === null) { $f = false; } else { $f = @fopen(Auth_OpenID_RAND_SOURCE, "r"); if ($f === false) { $msg = 'Define Auth_OpenID_RAND_SOURCE as null to ' . ' continue with an insecure random number generator.'; trigger_error($msg, E_USER_ERROR); } } } if ($f === false) { $bytes = ''; for ($i = 0; $i < $num_bytes; $i += 4) { $bytes .= pack('L', mt_rand()); } $bytes = substr($bytes, 0, $num_bytes); } else { $bytes = fread($f, $num_bytes); } return $bytes; } function randomString($length, $population = null) { if ($population === null) { return Auth_OpenID_CryptUtil::getBytes($length); } $popsize = strlen($population); if ($popsize > 256) { $msg = 'More than 256 characters supplied to ' . __FUNCTION__; trigger_error($msg, E_USER_ERROR); } $duplicate = 256 % $popsize; $str = ""; for ($i = 0; $i < $length; $i++) { do { $n = ord(Auth_OpenID_CryptUtil::getBytes(1)); } while ($n < $duplicate); $n %= $popsize; $str .= $population[$n]; } return $str; } }    class Auth_OpenID_DatabaseConnection { function autoCommit($mode) { } function query($sql, $params = array()) { } function begin() { } function commit() { } function rollback() { } function getOne($sql, $params = array()) { } function getRow($sql, $params = array()) { } function getAll($sql, $params = array()) { } }    import('core.lib.openid.auth.OpenID'); import('core.lib.openid.auth.openid.BigMath'); function Auth_OpenID_getDefaultMod() { return '155172898181473697471232257763715539915724801'. '966915404479707795314057629378541917580651227423'. '698188993727816152646631438561595825688188889951'. '272158842675419950341258706556549803580104870537'. '681476726513255747040765857479291291572334510643'. '245094715007229621094194349783925984760375594985'. '848253359305585439638443'; } function Auth_OpenID_getDefaultGen() { return '2'; } class Auth_OpenID_DiffieHellman { var $mod; var $gen; var $private; var $lib = null; function Auth_OpenID_DiffieHellman($mod = null, $gen = null, $private = null, $lib = null) { if ($lib === null) { $this->lib =& Auth_OpenID_getMathLib(); } else { $this->lib =& $lib; } if ($mod === null) { $this->mod = $this->lib->init(Auth_OpenID_getDefaultMod()); } else { $this->mod = $mod; } if ($gen === null) { $this->gen = $this->lib->init(Auth_OpenID_getDefaultGen()); } else { $this->gen = $gen; } if ($private === null) { $r = $this->lib->rand($this->mod); $this->private = $this->lib->add($r, 1); } else { $this->private = $private; } $this->public = $this->lib->powmod($this->gen, $this->private, $this->mod); } function getSharedSecret($composite) { return $this->lib->powmod($composite, $this->private, $this->mod); } function getPublicKey() { return $this->public; } function usingDefaultValues() { return ($this->mod == Auth_OpenID_getDefaultMod() && $this->gen == Auth_OpenID_getDefaultGen()); } function xorSecret($composite, $secret, $hash_func) { $dh_shared = $this->getSharedSecret($composite); $dh_shared_str = $this->lib->longToBinary($dh_shared); $hash_dh_shared = $hash_func($dh_shared_str); $xsecret = ""; for ($i = 0; $i < Auth_OpenID::bytes($secret); $i++) { $xsecret .= chr(ord($secret[$i]) ^ ord($hash_dh_shared[$i])); } return $xsecret; } }     import('core.lib.openid.auth.OpenID'); import('core.lib.openid.auth.openid.Parse'); import('core.lib.openid.auth.openid.Message'); import('core.lib.openid.auth.yadis.XRIRes'); import('core.lib.openid.auth.yadis.Yadis'); define('Auth_OpenID_XMLNS_1_0', 'http://openid.net/xmlns/1.0'); define('Auth_OpenID_TYPE_1_2', 'http://openid.net/signon/1.2'); define('Auth_OpenID_TYPE_1_1', 'http://openid.net/signon/1.1'); define('Auth_OpenID_TYPE_1_0', 'http://openid.net/signon/1.0'); define('Auth_OpenID_TYPE_2_0_IDP', 'http://specs.openid.net/auth/2.0/server'); define('Auth_OpenID_TYPE_2_0', 'http://specs.openid.net/auth/2.0/signon'); define('Auth_OpenID_RP_RETURN_TO_URL_TYPE', 'http://specs.openid.net/auth/2.0/return_to'); function Auth_OpenID_getOpenIDTypeURIs() { return array(Auth_OpenID_TYPE_2_0_IDP, Auth_OpenID_TYPE_2_0, Auth_OpenID_TYPE_1_2, Auth_OpenID_TYPE_1_1, Auth_OpenID_TYPE_1_0, Auth_OpenID_RP_RETURN_TO_URL_TYPE); } class Auth_OpenID_ServiceEndpoint { function Auth_OpenID_ServiceEndpoint() { $this->claimed_id = null; $this->server_url = null; $this->type_uris = array(); $this->local_id = null; $this->canonicalID = null; $this->used_yadis = false; $this->display_identifier = null; } function getDisplayIdentifier() { if ($this->display_identifier) { return $this->display_identifier; } if (! $this->claimed_id) { return $this->claimed_id; } $parsed = parse_url($this->claimed_id); $scheme = $parsed['scheme']; $host = $parsed['host']; $path = $parsed['path']; if (array_key_exists('query', $parsed)) { $query = $parsed['query']; $no_frag = "$scheme://$host$path?$query"; } else { $no_frag = "$scheme://$host$path"; } return $no_frag; } function usesExtension($extension_uri) { return in_array($extension_uri, $this->type_uris); } function preferredNamespace() { if (in_array(Auth_OpenID_TYPE_2_0_IDP, $this->type_uris) || in_array(Auth_OpenID_TYPE_2_0, $this->type_uris)) { return Auth_OpenID_OPENID2_NS; } else { return Auth_OpenID_OPENID1_NS; } } function matchTypes($type_uris) { $result = array(); foreach ($type_uris as $test_uri) { if ($this->supportsType($test_uri)) { $result[] = $test_uri; } } return $result; } function supportsType($type_uri) { return ((in_array($type_uri, $this->type_uris)) || (($type_uri == Auth_OpenID_TYPE_2_0) && $this->isOPIdentifier())); } function compatibilityMode() { return $this->preferredNamespace() != Auth_OpenID_OPENID2_NS; } function isOPIdentifier() { return in_array(Auth_OpenID_TYPE_2_0_IDP, $this->type_uris); } function fromOPEndpointURL($op_endpoint_url) { $obj = new Auth_OpenID_ServiceEndpoint(); $obj->server_url = $op_endpoint_url; $obj->type_uris = array(Auth_OpenID_TYPE_2_0_IDP); return $obj; } function parseService($yadis_url, $uri, $type_uris, $service_element) { $this->type_uris = $type_uris; $this->server_url = $uri; $this->used_yadis = true; if (!$this->isOPIdentifier()) { $this->claimed_id = $yadis_url; $this->local_id = Auth_OpenID_findOPLocalIdentifier( $service_element, $this->type_uris); if ($this->local_id === false) { return false; } } return true; } function getLocalID() { if ($this->local_id === null && $this->canonicalID === null) { return $this->claimed_id; } else { if ($this->local_id) { return $this->local_id; } else { return $this->canonicalID; } } } function fromXRDS($uri, $xrds_text) { $xrds =& Auth_Yadis_XRDS::parseXRDS($xrds_text); if ($xrds) { $yadis_services = $xrds->services(array('filter_MatchesAnyOpenIDType')); return Auth_OpenID_makeOpenIDEndpoints($uri, $yadis_services); } return null; } function fromDiscoveryResult($discoveryResult) { if ($discoveryResult->isXRDS()) { return Auth_OpenID_ServiceEndpoint::fromXRDS( $discoveryResult->normalized_uri, $discoveryResult->response_text); } else { return Auth_OpenID_ServiceEndpoint::fromHTML( $discoveryResult->normalized_uri, $discoveryResult->response_text); } } function fromHTML($uri, $html) { $discovery_types = array( array(Auth_OpenID_TYPE_2_0, 'openid2.provider', 'openid2.local_id'), array(Auth_OpenID_TYPE_1_1, 'openid.server', 'openid.delegate') ); $services = array(); foreach ($discovery_types as $triple) { list($type_uri, $server_rel, $delegate_rel) = $triple; $urls = Auth_OpenID_legacy_discover($html, $server_rel, $delegate_rel); if ($urls === false) { continue; } list($delegate_url, $server_url) = $urls; $service = new Auth_OpenID_ServiceEndpoint(); $service->claimed_id = $uri; $service->local_id = $delegate_url; $service->server_url = $server_url; $service->type_uris = array($type_uri); $services[] = $service; } return $services; } function copy() { $x = new Auth_OpenID_ServiceEndpoint(); $x->claimed_id = $this->claimed_id; $x->server_url = $this->server_url; $x->type_uris = $this->type_uris; $x->local_id = $this->local_id; $x->canonicalID = $this->canonicalID; $x->used_yadis = $this->used_yadis; return $x; } } function Auth_OpenID_findOPLocalIdentifier($service, $type_uris) { $service->parser->registerNamespace('openid', Auth_OpenID_XMLNS_1_0); $service->parser->registerNamespace('xrd', Auth_Yadis_XMLNS_XRD_2_0); $parser =& $service->parser; $permitted_tags = array(); if (in_array(Auth_OpenID_TYPE_1_1, $type_uris) || in_array(Auth_OpenID_TYPE_1_0, $type_uris)) { $permitted_tags[] = 'openid:Delegate'; } if (in_array(Auth_OpenID_TYPE_2_0, $type_uris)) { $permitted_tags[] = 'xrd:LocalID'; } $local_id = null; foreach ($permitted_tags as $tag_name) { $tags = $service->getElements($tag_name); foreach ($tags as $tag) { $content = $parser->content($tag); if ($local_id === null) { $local_id = $content; } else if ($local_id != $content) { return false; } } } return $local_id; } function filter_MatchesAnyOpenIDType(&$service) { $uris = $service->getTypes(); foreach ($uris as $uri) { if (in_array($uri, Auth_OpenID_getOpenIDTypeURIs())) { return true; } } return false; } function Auth_OpenID_bestMatchingService($service, $preferred_types) { foreach ($preferred_types as $index => $typ) { if (in_array($typ, $service->type_uris)) { return $index; } } return count($preferred_types); } function Auth_OpenID_arrangeByType($service_list, $preferred_types) { $prio_services = array(); foreach ($service_list as $index => $service) { $prio_services[] = array(Auth_OpenID_bestMatchingService($service, $preferred_types), $index, $service); } sort($prio_services); foreach ($prio_services as $index => $s) { $prio_services[$index] = $prio_services[$index][2]; } return $prio_services; } function Auth_OpenID_getOPOrUserServices($openid_services) { $op_services = Auth_OpenID_arrangeByType($openid_services, array(Auth_OpenID_TYPE_2_0_IDP)); $openid_services = Auth_OpenID_arrangeByType($openid_services, Auth_OpenID_getOpenIDTypeURIs()); if ($op_services) { return $op_services; } else { return $openid_services; } } function Auth_OpenID_makeOpenIDEndpoints($uri, $yadis_services) { $s = array(); if (!$yadis_services) { return $s; } foreach ($yadis_services as $service) { $type_uris = $service->getTypes(); $uris = $service->getURIs(); if ($type_uris && $uris) { foreach ($uris as $service_uri) { $openid_endpoint = new Auth_OpenID_ServiceEndpoint(); if ($openid_endpoint->parseService($uri, $service_uri, $type_uris, $service)) { $s[] = $openid_endpoint; } } } } return $s; } function Auth_OpenID_discoverWithYadis($uri, &$fetcher, $endpoint_filter='Auth_OpenID_getOPOrUserServices', $discover_function=null) { if ($discover_function === null) { $discover_function = array('Auth_Yadis_Yadis', 'discover'); } $openid_services = array(); $response = call_user_func_array($discover_function, array($uri, &$fetcher)); $yadis_url = $response->normalized_uri; $yadis_services = array(); if ($response->isFailure()) { return array($uri, array()); } $openid_services = Auth_OpenID_ServiceEndpoint::fromXRDS( $yadis_url, $response->response_text); if (!$openid_services) { if ($response->isXRDS()) { return Auth_OpenID_discoverWithoutYadis($uri, $fetcher); } $openid_services = Auth_OpenID_ServiceEndpoint::fromHTML( $yadis_url, $response->response_text); } $openid_services = call_user_func_array($endpoint_filter, array(&$openid_services)); return array($yadis_url, $openid_services); } function Auth_OpenID_discoverURI($uri, &$fetcher) { $uri = Auth_OpenID::normalizeUrl($uri); return Auth_OpenID_discoverWithYadis($uri, $fetcher); } function Auth_OpenID_discoverWithoutYadis($uri, &$fetcher) { $http_resp = @$fetcher->get($uri); if ($http_resp->status != 200 and $http_resp->status != 206) { return array($uri, array()); } $identity_url = $http_resp->final_url; $openid_services = Auth_OpenID_ServiceEndpoint::fromHTML( $identity_url, $http_resp->body); return array($identity_url, $openid_services); } function Auth_OpenID_discoverXRI($iname, &$fetcher) { $resolver = new Auth_Yadis_ProxyResolver($fetcher); list($canonicalID, $yadis_services) = $resolver->query($iname, Auth_OpenID_getOpenIDTypeURIs(), array('filter_MatchesAnyOpenIDType')); $openid_services = Auth_OpenID_makeOpenIDEndpoints($iname, $yadis_services); $openid_services = Auth_OpenID_getOPOrUserServices($openid_services); for ($i = 0; $i < count($openid_services); $i++) { $openid_services[$i]->canonicalID = $canonicalID; $openid_services[$i]->claimed_id = $canonicalID; $openid_services[$i]->display_identifier = $iname; } return array($iname, $openid_services); } function Auth_OpenID_discover($uri, &$fetcher) { if ($fetcher->isHTTPS($uri) && !$fetcher->supportsSSL()) { return array($uri, array()); } if (Auth_Yadis_identifierScheme($uri) == 'XRI') { $result = Auth_OpenID_discoverXRI($uri, $fetcher); } else { $result = Auth_OpenID_discoverURI($uri, $fetcher); } if (!$fetcher->supportsSSL()) { $http_endpoints = array(); list($new_uri, $endpoints) = $result; foreach ($endpoints as $e) { if (!$fetcher->isHTTPS($e->server_url)) { $http_endpoints[] = $e; } } $result = array($new_uri, $http_endpoints); } return $result; }     import('core.lib.openid.auth.openid.Interface'); import('core.lib.openid.auth.openid.HMAC'); class Auth_OpenID_DumbStore extends Auth_OpenID_OpenIDStore { function Auth_OpenID_DumbStore($secret_phrase) { $this->auth_key = Auth_OpenID_SHA1($secret_phrase); } function storeAssociation($server_url, $association) { } function getAssociation($server_url, $handle = null) { return null; } function removeAssociation($server_url, $handle) { return false; } function useNonce($server_url, $timestamp, $salt) { return true; } function getAuthKey() { return $this->auth_key; } }    import('core.lib.openid.auth.openid.Message'); class Auth_OpenID_Extension { var $ns_uri = null; var $ns_alias = null; function getExtensionArgs() { return null; } function toMessage(&$message) { $implicit = $message->isOpenID1(); $added = $message->namespaces->addAlias($this->ns_uri, $this->ns_alias, $implicit); if ($added === null) { if ($message->namespaces->getAlias($this->ns_uri) != $this->ns_alias) { return null; } } $message->updateArgs($this->ns_uri, $this->getExtensionArgs()); return $message; } }    import('core.lib.openid.auth.OpenID'); import('core.lib.openid.auth.openid.Interface'); import('core.lib.openid.auth.openid.HMAC'); import('core.lib.openid.auth.openid.Nonce'); class Auth_OpenID_FileStore extends Auth_OpenID_OpenIDStore { function Auth_OpenID_FileStore($directory) { if (!Auth_OpenID::ensureDir($directory)) { trigger_error('Not a directory and failed to create: ' . $directory, E_USER_ERROR); } $directory = realpath($directory); $this->directory = $directory; $this->active = true; $this->nonce_dir = $directory . DIRECTORY_SEPARATOR . 'nonces'; $this->association_dir = $directory . DIRECTORY_SEPARATOR . 'associations'; $this->temp_dir = $directory . DIRECTORY_SEPARATOR . 'temp'; $this->max_nonce_age = 6 * 60 * 60; if (!$this->_setup()) { trigger_error('Failed to initialize OpenID file store in ' . $directory, E_USER_ERROR); } } function destroy() { Auth_OpenID_FileStore::_rmtree($this->directory); $this->active = false; } function _setup() { return (Auth_OpenID::ensureDir($this->nonce_dir) && Auth_OpenID::ensureDir($this->association_dir) && Auth_OpenID::ensureDir($this->temp_dir)); } function _mktemp() { $name = Auth_OpenID_FileStore::_mkstemp($dir = $this->temp_dir); $file_obj = @fopen($name, 'wb'); if ($file_obj !== false) { return array($file_obj, $name); } else { Auth_OpenID_FileStore::_removeIfPresent($name); } } function cleanupNonces() { global $Auth_OpenID_SKEW; $nonces = Auth_OpenID_FileStore::_listdir($this->nonce_dir); $now = time(); $removed = 0; foreach ($nonces as $nonce_fname) { $base = basename($nonce_fname); $parts = explode('-', $base, 2); $timestamp = $parts[0]; $timestamp = intval($timestamp, 16); if (abs($timestamp - $now) > $Auth_OpenID_SKEW) { Auth_OpenID_FileStore::_removeIfPresent($nonce_fname); $removed += 1; } } return $removed; } function getAssociationFilename($server_url, $handle) { if (!$this->active) { trigger_error("FileStore no longer active", E_USER_ERROR); return null; } if (strpos($server_url, '://') === false) { trigger_error(sprintf("Bad server URL: %s", $server_url), E_USER_WARNING); return null; } list($proto, $rest) = explode('://', $server_url, 2); $parts = explode('/', $rest); $domain = Auth_OpenID_FileStore::_filenameEscape($parts[0]); $url_hash = Auth_OpenID_FileStore::_safe64($server_url); if ($handle) { $handle_hash = Auth_OpenID_FileStore::_safe64($handle); } else { $handle_hash = ''; } $filename = sprintf('%s-%s-%s-%s', $proto, $domain, $url_hash, $handle_hash); return $this->association_dir. DIRECTORY_SEPARATOR . $filename; } function storeAssociation($server_url, $association) { if (!$this->active) { trigger_error("FileStore no longer active", E_USER_ERROR); return false; } $association_s = $association->serialize(); $filename = $this->getAssociationFilename($server_url, $association->handle); list($tmp_file, $tmp) = $this->_mktemp(); if (!$tmp_file) { trigger_error("_mktemp didn't return a valid file descriptor", E_USER_WARNING); return false; } fwrite($tmp_file, $association_s); fflush($tmp_file); fclose($tmp_file); if (@rename($tmp, $filename)) { return true; } else { @unlink($filename); if (@rename($tmp, $filename)) { return true; } } Auth_OpenID_FileStore::_removeIfPresent($tmp); return false; } function getAssociation($server_url, $handle = null) { if (!$this->active) { trigger_error("FileStore no longer active", E_USER_ERROR); return null; } if ($handle === null) { $handle = ''; } $filename = $this->getAssociationFilename($server_url, $handle); if ($handle) { return $this->_getAssociation($filename); } else { $association_files = Auth_OpenID_FileStore::_listdir($this->association_dir); $matching_files = array(); $name = basename($filename); foreach ($association_files as $association_file) { $base = basename($association_file); if (strpos($base, $name) === 0) { $matching_files[] = $association_file; } } $matching_associations = array(); foreach ($matching_files as $full_name) { $association = $this->_getAssociation($full_name); if ($association !== null) { $matching_associations[] = array($association->issued, $association); } } $issued = array(); $assocs = array(); foreach ($matching_associations as $key => $assoc) { $issued[$key] = $assoc[0]; $assocs[$key] = $assoc[1]; } array_multisort($issued, SORT_DESC, $assocs, SORT_DESC, $matching_associations); if ($matching_associations) { list($issued, $assoc) = $matching_associations[0]; return $assoc; } else { return null; } } } function _getAssociation($filename) { if (!$this->active) { trigger_error("FileStore no longer active", E_USER_ERROR); return null; } $assoc_file = @fopen($filename, 'rb'); if ($assoc_file === false) { return null; } $assoc_s = fread($assoc_file, filesize($filename)); fclose($assoc_file); if (!$assoc_s) { return null; } $association = Auth_OpenID_Association::deserialize('Auth_OpenID_Association', $assoc_s); if (!$association) { Auth_OpenID_FileStore::_removeIfPresent($filename); return null; } if ($association->getExpiresIn() == 0) { Auth_OpenID_FileStore::_removeIfPresent($filename); return null; } else { return $association; } } function removeAssociation($server_url, $handle) { if (!$this->active) { trigger_error("FileStore no longer active", E_USER_ERROR); return null; } $assoc = $this->getAssociation($server_url, $handle); if ($assoc === null) { return false; } else { $filename = $this->getAssociationFilename($server_url, $handle); return Auth_OpenID_FileStore::_removeIfPresent($filename); } } function useNonce($server_url, $timestamp, $salt) { global $Auth_OpenID_SKEW; if (!$this->active) { trigger_error("FileStore no longer active", E_USER_ERROR); return null; } if ( abs($timestamp - time()) > $Auth_OpenID_SKEW ) { return False; } if ($server_url) { list($proto, $rest) = explode('://', $server_url, 2); } else { $proto = ''; $rest = ''; } $parts = explode('/', $rest, 2); $domain = $this->_filenameEscape($parts[0]); $url_hash = $this->_safe64($server_url); $salt_hash = $this->_safe64($salt); $filename = sprintf('%08x-%s-%s-%s-%s', $timestamp, $proto, $domain, $url_hash, $salt_hash); $filename = $this->nonce_dir . DIRECTORY_SEPARATOR . $filename; $result = @fopen($filename, 'x'); if ($result === false) { return false; } else { fclose($result); return true; } } function _allAssocs() { $all_associations = array(); $association_filenames = Auth_OpenID_FileStore::_listdir($this->association_dir); foreach ($association_filenames as $association_filename) { $association_file = fopen($association_filename, 'rb'); if ($association_file !== false) { $assoc_s = fread($association_file, filesize($association_filename)); fclose($association_file); $association = Auth_OpenID_Association::deserialize( 'Auth_OpenID_Association', $assoc_s); if ($association === null) { Auth_OpenID_FileStore::_removeIfPresent( $association_filename); } else { if ($association->getExpiresIn() == 0) { $all_associations[] = array($association_filename, $association); } } } } return $all_associations; } function clean() { if (!$this->active) { trigger_error("FileStore no longer active", E_USER_ERROR); return null; } $nonces = Auth_OpenID_FileStore::_listdir($this->nonce_dir); $now = time(); foreach ($nonces as $nonce) { if (!Auth_OpenID_checkTimestamp($nonce, $now)) { $filename = $this->nonce_dir . DIRECTORY_SEPARATOR . $nonce; Auth_OpenID_FileStore::_removeIfPresent($filename); } } foreach ($this->_allAssocs() as $pair) { list($assoc_filename, $assoc) = $pair; if ($assoc->getExpiresIn() == 0) { Auth_OpenID_FileStore::_removeIfPresent($assoc_filename); } } } function _rmtree($dir) { if ($dir[strlen($dir) - 1] != DIRECTORY_SEPARATOR) { $dir .= DIRECTORY_SEPARATOR; } if ($handle = opendir($dir)) { while ($item = readdir($handle)) { if (!in_array($item, array('.', '..'))) { if (is_dir($dir . $item)) { if (!Auth_OpenID_FileStore::_rmtree($dir . $item)) { return false; } } else if (is_file($dir . $item)) { if (!unlink($dir . $item)) { return false; } } } } closedir($handle); if (!@rmdir($dir)) { return false; } return true; } else { return false; } } function _mkstemp($dir) { foreach (range(0, 4) as $i) { $name = tempnam($dir, "php_openid_filestore_"); if ($name !== false) { return $name; } } return false; } function _mkdtemp($dir) { foreach (range(0, 4) as $i) { $name = $dir . strval(DIRECTORY_SEPARATOR) . strval(getmypid()) . "-" . strval(rand(1, time())); if (!mkdir($name, 0700)) { return false; } else { return $name; } } return false; } function _listdir($dir) { $handle = opendir($dir); $files = array(); while (false !== ($filename = readdir($handle))) { if (!in_array($filename, array('.', '..'))) { $files[] = $dir . DIRECTORY_SEPARATOR . $filename; } } return $files; } function _isFilenameSafe($char) { $_Auth_OpenID_filename_allowed = Auth_OpenID_letters . Auth_OpenID_digits . "."; return (strpos($_Auth_OpenID_filename_allowed, $char) !== false); } function _safe64($str) { $h64 = base64_encode(Auth_OpenID_SHA1($str)); $h64 = str_replace('+', '_', $h64); $h64 = str_replace('/', '.', $h64); $h64 = str_replace('=', '', $h64); return $h64; } function _filenameEscape($str) { $filename = ""; $b = Auth_OpenID::toBytes($str); for ($i = 0; $i < count($b); $i++) { $c = $b[$i]; if (Auth_OpenID_FileStore::_isFilenameSafe($c)) { $filename .= $c; } else { $filename .= sprintf("_%02X", ord($c)); } } return $filename; } function _removeIfPresent($filename) { return @unlink($filename); } function cleanupAssociations() { $removed = 0; foreach ($this->_allAssocs() as $pair) { list($assoc_filename, $assoc) = $pair; if ($assoc->getExpiresIn() == 0) { $this->_removeIfPresent($assoc_filename); $removed += 1; } } return $removed; } }     import('core.lib.openid.auth.OpenID'); define('Auth_OpenID_SHA1_BLOCKSIZE', 64); function Auth_OpenID_SHA1($text) { if (function_exists('hash') && function_exists('hash_algos') && (in_array('sha1', hash_algos()))) { return hash('sha1', $text, true); } else if (function_exists('sha1')) { $hex = sha1($text); $raw = ''; for ($i = 0; $i < 40; $i += 2) { $hexcode = substr($hex, $i, 2); $charcode = (int)base_convert($hexcode, 16, 10); $raw .= chr($charcode); } return $raw; } else { trigger_error('No SHA1 function found', E_USER_ERROR); } } function Auth_OpenID_HMACSHA1($key, $text) { if (Auth_OpenID::bytes($key) > Auth_OpenID_SHA1_BLOCKSIZE) { $key = Auth_OpenID_SHA1($key, true); } $key = str_pad($key, Auth_OpenID_SHA1_BLOCKSIZE, chr(0x00)); $ipad = str_repeat(chr(0x36), Auth_OpenID_SHA1_BLOCKSIZE); $opad = str_repeat(chr(0x5c), Auth_OpenID_SHA1_BLOCKSIZE); $hash1 = Auth_OpenID_SHA1(($key ^ $ipad) . $text, true); $hmac = Auth_OpenID_SHA1(($key ^ $opad) . $hash1, true); return $hmac; } if (function_exists('hash') && function_exists('hash_algos') && (in_array('sha256', hash_algos()))) { function Auth_OpenID_SHA256($text) { return hash('sha256', $text, true); } define('Auth_OpenID_SHA256_SUPPORTED', true); } else { define('Auth_OpenID_SHA256_SUPPORTED', false); } if (function_exists('hash_hmac') && function_exists('hash_algos') && (in_array('sha256', hash_algos()))) { function Auth_OpenID_HMACSHA256($key, $text) { return hash_hmac('sha256', $text, $key, true); } define('Auth_OpenID_HMACSHA256_SUPPORTED', true); } else { define('Auth_OpenID_HMACSHA256_SUPPORTED', false); }    class Auth_OpenID_OpenIDStore { function storeAssociation($server_url, $association) { trigger_error("Auth_OpenID_OpenIDStore::storeAssociation ". "not implemented", E_USER_ERROR); } function cleanupNonces() { trigger_error("Auth_OpenID_OpenIDStore::cleanupNonces ". "not implemented", E_USER_ERROR); } function cleanupAssociations() { trigger_error("Auth_OpenID_OpenIDStore::cleanupAssociations ". "not implemented", E_USER_ERROR); } function cleanup() { return array($this->cleanupNonces(), $this->cleanupAssociations()); } function supportsCleanup() { return true; } function getAssociation($server_url, $handle = null) { trigger_error("Auth_OpenID_OpenIDStore::getAssociation ". "not implemented", E_USER_ERROR); } function removeAssociation($server_url, $handle) { trigger_error("Auth_OpenID_OpenIDStore::removeAssociation ". "not implemented", E_USER_ERROR); } function useNonce($server_url, $timestamp, $salt) { trigger_error("Auth_OpenID_OpenIDStore::useNonce ". "not implemented", E_USER_ERROR); } function reset() { } }    class Auth_OpenID_KVForm { function toArray($kvs, $strict=false) { $lines = explode("\n", $kvs); $last = array_pop($lines); if ($last !== '') { array_push($lines, $last); if ($strict) { return false; } } $values = array(); for ($lineno = 0; $lineno < count($lines); $lineno++) { $line = $lines[$lineno]; $kv = explode(':', $line, 2); if (count($kv) != 2) { if ($strict) { return false; } continue; } $key = $kv[0]; $tkey = trim($key); if ($tkey != $key) { if ($strict) { return false; } } $value = $kv[1]; $tval = trim($value); if ($tval != $value) { if ($strict) { return false; } } $values[$tkey] = $tval; } return $values; } function fromArray($values) { if ($values === null) { return null; } ksort($values); $serialized = ''; foreach ($values as $key => $value) { if (is_array($value)) { list($key, $value) = array($value[0], $value[1]); } if (strpos($key, ':') !== false) { return null; } if (strpos($key, "\n") !== false) { return null; } if (strpos($value, "\n") !== false) { return null; } $serialized .= "$key:$value\n"; } return $serialized; } }    import('core.lib.openid.auth.openid.Interface'); class Auth_OpenID_MemcachedStore extends Auth_OpenID_OpenIDStore { function Auth_OpenID_MemcachedStore($connection, $compress = false) { $this->connection = $connection; $this->compress = $compress ? MEMCACHE_COMPRESSED : 0; } function storeAssociation($server_url, $association) { $associationKey = $this->associationKey($server_url, $association->handle); $serverKey = $this->associationServerKey($server_url); $serverAssociations = $this->connection->get($serverKey); if (!$serverAssociations) { $serverAssociations = array(); } $serverAssociations[$association->issued] = $associationKey; $this->connection->set( $serverKey, $serverAssociations, $this->compress ); $this->connection->set( $associationKey, $association, $this->compress, $association->issued + $association->lifetime); } function getAssociation($server_url, $handle = null) { if ($handle !== null) { $association = $this->connection->get( $this->associationKey($server_url, $handle)); return $association ? $association : null; } $serverKey = $this->associationServerKey($server_url); $serverAssociations = $this->connection->get($serverKey); if (!$serverAssociations) { return null; } $keys = array_keys($serverAssociations); sort($keys); $lastKey = $serverAssociations[array_pop($keys)]; $association = $this->connection->get($lastKey); return $association ? $association : null; } function removeAssociation($server_url, $handle) { $serverKey = $this->associationServerKey($server_url); $associationKey = $this->associationKey($server_url, $handle); $serverAssociations = $this->connection->get($serverKey); if (!$serverAssociations) { return false; } $serverAssociations = array_flip($serverAssociations); if (!array_key_exists($associationKey, $serverAssociations)) { return false; } unset($serverAssociations[$associationKey]); $serverAssociations = array_flip($serverAssociations); $this->connection->set( $serverKey, $serverAssociations, $this->compress ); return $this->connection->delete($associationKey); } function useNonce($server_url, $timestamp, $salt) { global $Auth_OpenID_SKEW; if (abs($timestamp - time()) > $Auth_OpenID_SKEW) { return false; } return $this->connection->add( 'openid_nonce_' . sha1($server_url) . '_' . sha1($salt), 1, $this->compress, $Auth_OpenID_SKEW); } function associationKey($server_url, $handle = null) { return 'openid_association_' . sha1($server_url) . '_' . sha1($handle); } function associationServerKey($server_url) { return 'openid_association_server_' . sha1($server_url); } function supportsCleanup() { return false; } }    import('core.lib.openid.auth.OpenID'); import('core.lib.openid.auth.openid.KVForm'); import('core.lib.openid.auth.yadis.XML'); import('core.lib.openid.auth.openid.Consumer'); define('Auth_OpenID_IDENTIFIER_SELECT', "http://specs.openid.net/auth/2.0/identifier_select"); define('Auth_OpenID_SREG_URI', 'http://openid.net/sreg/1.0'); define('Auth_OpenID_OPENID1_NS', 'http://openid.net/signon/1.0'); define('Auth_OpenID_THE_OTHER_OPENID1_NS', 'http://openid.net/signon/1.1'); function Auth_OpenID_isOpenID1($ns) { return ($ns == Auth_OpenID_THE_OTHER_OPENID1_NS) || ($ns == Auth_OpenID_OPENID1_NS); } define('Auth_OpenID_OPENID2_NS', 'http://specs.openid.net/auth/2.0'); define('Auth_OpenID_NULL_NAMESPACE', 'Null namespace'); define('Auth_OpenID_OPENID_NS', 'OpenID namespace'); define('Auth_OpenID_BARE_NS', 'Bare namespace'); define('Auth_OpenID_NO_DEFAULT', 'NO DEFAULT ALLOWED'); define('Auth_OpenID_OPENID1_URL_LIMIT', 2047); global $Auth_OpenID_OPENID_PROTOCOL_FIELDS; $Auth_OpenID_OPENID_PROTOCOL_FIELDS = array( 'ns', 'mode', 'error', 'return_to', 'contact', 'reference', 'signed', 'assoc_type', 'session_type', 'dh_modulus', 'dh_gen', 'dh_consumer_public', 'claimed_id', 'identity', 'realm', 'invalidate_handle', 'op_endpoint', 'response_nonce', 'sig', 'assoc_handle', 'trust_root', 'openid'); global $Auth_OpenID_registered_aliases; $Auth_OpenID_registered_aliases = array(); function Auth_OpenID_registerNamespaceAlias($namespace_uri, $alias) { global $Auth_OpenID_registered_aliases; if (Auth_OpenID::arrayGet($Auth_OpenID_registered_aliases, $alias) == $namespace_uri) { return true; } if (in_array($namespace_uri, array_values($Auth_OpenID_registered_aliases))) { return false; } if (in_array($alias, array_keys($Auth_OpenID_registered_aliases))) { return false; } $Auth_OpenID_registered_aliases[$alias] = $namespace_uri; return true; } function Auth_OpenID_removeNamespaceAlias($namespace_uri, $alias) { global $Auth_OpenID_registered_aliases; if (Auth_OpenID::arrayGet($Auth_OpenID_registered_aliases, $alias) === $namespace_uri) { unset($Auth_OpenID_registered_aliases[$alias]); return true; } return false; } class Auth_OpenID_Mapping { function Auth_OpenID_Mapping($classic_array = null) { $this->keys = array(); $this->values = array(); if (is_array($classic_array)) { foreach ($classic_array as $key => $value) { $this->set($key, $value); } } } function isA($thing) { return (is_object($thing) && strtolower(get_class($thing)) == 'auth_openid_mapping'); } function keys() { return $this->keys; } function values() { return $this->values; } function items() { $temp = array(); for ($i = 0; $i < count($this->keys); $i++) { $temp[] = array($this->keys[$i], $this->values[$i]); } return $temp; } function len() { return count($this->keys); } function set($key, $value) { $index = array_search($key, $this->keys); if ($index !== false) { $this->values[$index] = $value; } else { $this->keys[] = $key; $this->values[] = $value; } } function get($key, $default = null) { $index = array_search($key, $this->keys); if ($index !== false) { return $this->values[$index]; } else { return $default; } } function _reflow() { $old_keys = $this->keys; $old_values = $this->values; $this->keys = array(); $this->values = array(); foreach ($old_keys as $k) { $this->keys[] = $k; } foreach ($old_values as $v) { $this->values[] = $v; } } function del($key) { $index = array_search($key, $this->keys); if ($index !== false) { unset($this->keys[$index]); unset($this->values[$index]); $this->_reflow(); return true; } return false; } function contains($value) { return (array_search($value, $this->keys) !== false); } } class Auth_OpenID_NamespaceMap { function Auth_OpenID_NamespaceMap() { $this->alias_to_namespace = new Auth_OpenID_Mapping(); $this->namespace_to_alias = new Auth_OpenID_Mapping(); $this->implicit_namespaces = array(); } function getAlias($namespace_uri) { return $this->namespace_to_alias->get($namespace_uri); } function getNamespaceURI($alias) { return $this->alias_to_namespace->get($alias); } function iterNamespaceURIs() { return $this->namespace_to_alias->keys(); } function iterAliases() { return $this->alias_to_namespace->keys(); } function iteritems() { return $this->namespace_to_alias->items(); } function isImplicit($namespace_uri) { return in_array($namespace_uri, $this->implicit_namespaces); } function addAlias($namespace_uri, $desired_alias, $implicit=false) { global $Auth_OpenID_OPENID_PROTOCOL_FIELDS; if (in_array($desired_alias, $Auth_OpenID_OPENID_PROTOCOL_FIELDS)) { Auth_OpenID::log("\"%s\" is not an allowed namespace alias", $desired_alias); return null; } if (strpos($desired_alias, '.') !== false) { Auth_OpenID::log('"%s" must not contain a dot', $desired_alias); return null; } $current_namespace_uri = $this->alias_to_namespace->get($desired_alias); if (($current_namespace_uri !== null) && ($current_namespace_uri != $namespace_uri)) { Auth_OpenID::log('Cannot map "%s" because previous mapping exists', $namespace_uri); return null; } $alias = $this->namespace_to_alias->get($namespace_uri); if (($alias !== null) && ($alias != $desired_alias)) { Auth_OpenID::log('Cannot map %s to alias %s. ' . 'It is already mapped to alias %s', $namespace_uri, $desired_alias, $alias); return null; } assert((Auth_OpenID_NULL_NAMESPACE === $desired_alias) || is_string($desired_alias)); $this->alias_to_namespace->set($desired_alias, $namespace_uri); $this->namespace_to_alias->set($namespace_uri, $desired_alias); if ($implicit) { array_push($this->implicit_namespaces, $namespace_uri); } return $desired_alias; } function add($namespace_uri) { $alias = $this->namespace_to_alias->get($namespace_uri); if ($alias !== null) { return $alias; } $i = 0; while (1) { $alias = 'ext' . strval($i); if ($this->addAlias($namespace_uri, $alias) === null) { $i += 1; } else { return $alias; } } return null; } function contains($namespace_uri) { return $this->isDefined($namespace_uri); } function isDefined($namespace_uri) { return $this->namespace_to_alias->contains($namespace_uri); } } class Auth_OpenID_Message { function Auth_OpenID_Message($openid_namespace = null) { $this->allowed_openid_namespaces = array( Auth_OpenID_OPENID1_NS, Auth_OpenID_THE_OTHER_OPENID1_NS, Auth_OpenID_OPENID2_NS); $this->args = new Auth_OpenID_Mapping(); $this->namespaces = new Auth_OpenID_NamespaceMap(); if ($openid_namespace === null) { $this->_openid_ns_uri = null; } else { $implicit = Auth_OpenID_isOpenID1($openid_namespace); $this->setOpenIDNamespace($openid_namespace, $implicit); } } function isOpenID1() { return Auth_OpenID_isOpenID1($this->getOpenIDNamespace()); } function isOpenID2() { return $this->getOpenIDNamespace() == Auth_OpenID_OPENID2_NS; } function fromPostArgs($args) { $obj = new Auth_OpenID_Message(); $openid_args = array(); foreach ($args as $key => $value) { if (is_array($value)) { return null; } $parts = explode('.', $key, 2); if (count($parts) == 2) { list($prefix, $rest) = $parts; } else { $prefix = null; } if ($prefix != 'openid') { $obj->args->set(array(Auth_OpenID_BARE_NS, $key), $value); } else { $openid_args[$rest] = $value; } } if ($obj->_fromOpenIDArgs($openid_args)) { return $obj; } else { return null; } } function fromOpenIDArgs($openid_args) { $obj = new Auth_OpenID_Message(); if ($obj->_fromOpenIDArgs($openid_args)) { return $obj; } else { return null; } } function _fromOpenIDArgs($openid_args) { global $Auth_OpenID_registered_aliases; if (!Auth_OpenID_Mapping::isA($openid_args)) { $openid_args = new Auth_OpenID_Mapping($openid_args); } $ns_args = array(); foreach ($openid_args->items() as $pair) { list($rest, $value) = $pair; $parts = explode('.', $rest, 2); if (count($parts) == 2) { list($ns_alias, $ns_key) = $parts; } else { $ns_alias = Auth_OpenID_NULL_NAMESPACE; $ns_key = $rest; } if ($ns_alias == 'ns') { if ($this->namespaces->addAlias($value, $ns_key) === null) { return false; } } else if (($ns_alias == Auth_OpenID_NULL_NAMESPACE) && ($ns_key == 'ns')) { if ($this->setOpenIDNamespace($value, false) === false) { return false; } } else { $ns_args[] = array($ns_alias, $ns_key, $value); } } if (!$this->getOpenIDNamespace()) { if ($this->setOpenIDNamespace(Auth_OpenID_OPENID1_NS, true) === false) { return false; } } foreach ($ns_args as $triple) { list($ns_alias, $ns_key, $value) = $triple; $ns_uri = $this->namespaces->getNamespaceURI($ns_alias); if ($ns_uri === null) { $ns_uri = $this->_getDefaultNamespace($ns_alias); if ($ns_uri === null) { $ns_uri = Auth_OpenID_OPENID_NS; $ns_key = sprintf('%s.%s', $ns_alias, $ns_key); } else { $this->namespaces->addAlias($ns_uri, $ns_alias, true); } } $this->setArg($ns_uri, $ns_key, $value); } return true; } function _getDefaultNamespace($mystery_alias) { global $Auth_OpenID_registered_aliases; if ($this->isOpenID1()) { return @$Auth_OpenID_registered_aliases[$mystery_alias]; } return null; } function setOpenIDNamespace($openid_ns_uri, $implicit) { if (!in_array($openid_ns_uri, $this->allowed_openid_namespaces)) { Auth_OpenID::log('Invalid null namespace: "%s"', $openid_ns_uri); return false; } $succeeded = $this->namespaces->addAlias($openid_ns_uri, Auth_OpenID_NULL_NAMESPACE, $implicit); if ($succeeded === false) { return false; } $this->_openid_ns_uri = $openid_ns_uri; return true; } function getOpenIDNamespace() { return $this->_openid_ns_uri; } function fromKVForm($kvform_string) { return Auth_OpenID_Message::fromOpenIDArgs( Auth_OpenID_KVForm::toArray($kvform_string)); } function copy() { return $this; } function toPostArgs() { $args = array(); foreach ($this->namespaces->iteritems() as $pair) { list($ns_uri, $alias) = $pair; if ($this->namespaces->isImplicit($ns_uri)) { continue; } if ($alias == Auth_OpenID_NULL_NAMESPACE) { $ns_key = 'openid.ns'; } else { $ns_key = 'openid.ns.' . $alias; } $args[$ns_key] = $ns_uri; } foreach ($this->args->items() as $pair) { list($ns_parts, $value) = $pair; list($ns_uri, $ns_key) = $ns_parts; $key = $this->getKey($ns_uri, $ns_key); $args[$key] = $value; } return $args; } function toArgs() { $post_args = $this->toPostArgs(); $kvargs = array(); foreach ($post_args as $k => $v) { if (strpos($k, 'openid.') !== 0) { return null; } else { $kvargs[substr($k, 7)] = $v; } } return $kvargs; } function toFormMarkup($action_url, $form_tag_attrs = null, $submit_text = "Continue") { $form = "<form accept-charset=\"UTF-8\" ". "enctype=\"application/x-www-form-urlencoded\""; if (!$form_tag_attrs) { $form_tag_attrs = array(); } $form_tag_attrs['action'] = $action_url; $form_tag_attrs['method'] = 'post'; unset($form_tag_attrs['enctype']); unset($form_tag_attrs['accept-charset']); if ($form_tag_attrs) { foreach ($form_tag_attrs as $name => $attr) { $form .= sprintf(" %s=\"%s\"", $name, $attr); } } $form .= ">\n"; foreach ($this->toPostArgs() as $name => $value) { $form .= sprintf( "<input type=\"hidden\" name=\"%s\" value=\"%s\" />\n", $name, $value); } $form .= sprintf("<input type=\"submit\" value=\"%s\" />\n", $submit_text); $form .= "</form>\n"; return $form; } function toURL($base_url) { return Auth_OpenID::appendArgs($base_url, $this->toPostArgs()); } function toKVForm() { return Auth_OpenID_KVForm::fromArray($this->toArgs()); } function toURLEncoded() { $args = array(); foreach ($this->toPostArgs() as $k => $v) { $args[] = array($k, $v); } sort($args); return Auth_OpenID::httpBuildQuery($args); } function _fixNS($namespace) { if ($namespace == Auth_OpenID_OPENID_NS) { if ($this->_openid_ns_uri === null) { return new Auth_OpenID_FailureResponse(null, 'OpenID namespace not set'); } else { $namespace = $this->_openid_ns_uri; } } if (($namespace != Auth_OpenID_BARE_NS) && (!is_string($namespace))) { $err_msg = sprintf("Namespace must be Auth_OpenID_BARE_NS, ". "Auth_OpenID_OPENID_NS or a string. got %s", print_r($namespace, true)); return new Auth_OpenID_FailureResponse(null, $err_msg); } if (($namespace != Auth_OpenID_BARE_NS) && (strpos($namespace, ':') === false)) { if ($namespace == 'sreg') { return Auth_OpenID_SREG_URI; } } return $namespace; } function hasKey($namespace, $ns_key) { $namespace = $this->_fixNS($namespace); if (Auth_OpenID::isFailure($namespace)) { return false; } else { return $this->args->contains(array($namespace, $ns_key)); } } function getKey($namespace, $ns_key) { $namespace = $this->_fixNS($namespace); if (Auth_OpenID::isFailure($namespace)) { return $namespace; } if ($namespace == Auth_OpenID_BARE_NS) { return $ns_key; } $ns_alias = $this->namespaces->getAlias($namespace); if ($ns_alias === null) { return null; } if ($ns_alias == Auth_OpenID_NULL_NAMESPACE) { $tail = $ns_key; } else { $tail = sprintf('%s.%s', $ns_alias, $ns_key); } return 'openid.' . $tail; } function getArg($namespace, $key, $default = null) { $namespace = $this->_fixNS($namespace); if (Auth_OpenID::isFailure($namespace)) { return $namespace; } else { if ((!$this->args->contains(array($namespace, $key))) && ($default == Auth_OpenID_NO_DEFAULT)) { $err_msg = sprintf("Namespace %s missing required field %s", $namespace, $key); return new Auth_OpenID_FailureResponse(null, $err_msg); } else { return $this->args->get(array($namespace, $key), $default); } } } function getArgs($namespace) { $namespace = $this->_fixNS($namespace); if (Auth_OpenID::isFailure($namespace)) { return $namespace; } else { $stuff = array(); foreach ($this->args->items() as $pair) { list($key, $value) = $pair; list($pair_ns, $ns_key) = $key; if ($pair_ns == $namespace) { $stuff[$ns_key] = $value; } } return $stuff; } } function updateArgs($namespace, $updates) { $namespace = $this->_fixNS($namespace); if (Auth_OpenID::isFailure($namespace)) { return $namespace; } else { foreach ($updates as $k => $v) { $this->setArg($namespace, $k, $v); } return true; } } function setArg($namespace, $key, $value) { $namespace = $this->_fixNS($namespace); if (Auth_OpenID::isFailure($namespace)) { return $namespace; } else { $this->args->set(array($namespace, $key), $value); if ($namespace !== Auth_OpenID_BARE_NS) { $this->namespaces->add($namespace); } return true; } } function delArg($namespace, $key) { $namespace = $this->_fixNS($namespace); if (Auth_OpenID::isFailure($namespace)) { return $namespace; } else { return $this->args->del(array($namespace, $key)); } } function getAliasedArg($aliased_key, $default = null) { $parts = explode('.', $aliased_key, 2); if (count($parts) != 2) { $ns = null; } else { list($alias, $key) = $parts; if ($alias == 'ns') { return $this->namespaces->getNamespaceURI($key); } else { $ns = $this->namespaces->getNamespaceURI($alias); } } if ($ns === null) { $key = $aliased_key; $ns = $this->getOpenIDNamespace(); } return $this->getArg($ns, $key, $default); } }     import('core.lib.openid.auth.openid.SQLStore'); class Auth_OpenID_MySQLStore extends Auth_OpenID_SQLStore { function setSQL() { $this->sql['nonce_table'] = "CREATE TABLE %s (\n". "  server_url VARCHAR(2047) NOT NULL,\n". "  timestamp INTEGER NOT NULL,\n". "  salt CHAR(40) NOT NULL,\n". "  UNIQUE (server_url(255), timestamp, salt)\n". ") ENGINE=InnoDB"; $this->sql['assoc_table'] = "CREATE TABLE %s (\n". "  server_url BLOB NOT NULL,\n". "  handle VARCHAR(255) NOT NULL,\n". "  secret BLOB NOT NULL,\n". "  issued INTEGER NOT NULL,\n". "  lifetime INTEGER NOT NULL,\n". "  assoc_type VARCHAR(64) NOT NULL,\n". "  PRIMARY KEY (server_url(255), handle)\n". ") ENGINE=InnoDB"; $this->sql['set_assoc'] = "REPLACE INTO %s (server_url, handle, secret, issued,\n". "  lifetime, assoc_type) VALUES (?, ?, !, ?, ?, ?)"; $this->sql['get_assocs'] = "SELECT handle, secret, issued, lifetime, assoc_type FROM %s ". "WHERE server_url = ?"; $this->sql['get_assoc'] = "SELECT handle, secret, issued, lifetime, assoc_type FROM %s ". "WHERE server_url = ? AND handle = ?"; $this->sql['remove_assoc'] = "DELETE FROM %s WHERE server_url = ? AND handle = ?"; $this->sql['add_nonce'] = "INSERT INTO %s (server_url, timestamp, salt) VALUES (?, ?, ?)"; $this->sql['clean_nonce'] = "DELETE FROM %s WHERE timestamp < ?"; $this->sql['clean_assoc'] = "DELETE FROM %s WHERE issued + lifetime < ?"; } function blobEncode($blob) { return "0x" . bin2hex($blob); } }    import('core.lib.openid.auth.openid.CryptUtil'); define('Auth_OpenID_Nonce_CHRS',"abcdefghijklmnopqrstuvwxyz" . "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"); global $Auth_OpenID_SKEW; $Auth_OpenID_SKEW = 60 * 60 * 5; define('Auth_OpenID_Nonce_REGEX', '/(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d):(\d\d)Z(.*)/'); define('Auth_OpenID_Nonce_TIME_FMT', '%Y-%m-%dT%H:%M:%SZ'); function Auth_OpenID_splitNonce($nonce_string) { $result = preg_match(Auth_OpenID_Nonce_REGEX, $nonce_string, $matches); if ($result != 1 || count($matches) != 8) { return null; } list($unused, $tm_year, $tm_mon, $tm_mday, $tm_hour, $tm_min, $tm_sec, $uniquifier) = $matches; $timestamp = @gmmktime($tm_hour, $tm_min, $tm_sec, $tm_mon, $tm_mday, $tm_year); if ($timestamp === false || $timestamp < 0) { return null; } return array($timestamp, $uniquifier); } function Auth_OpenID_checkTimestamp($nonce_string, $allowed_skew = null, $now = null) { global $Auth_OpenID_SKEW; if ($allowed_skew === null) { $allowed_skew = $Auth_OpenID_SKEW; } $parts = Auth_OpenID_splitNonce($nonce_string); if ($parts == null) { return false; } if ($now === null) { $now = time(); } $stamp = $parts[0]; $past = $now - $allowed_skew; $future = $now + $allowed_skew; return (($past <= $stamp) && ($stamp <= $future)); } function Auth_OpenID_mkNonce($when = null) { $salt = Auth_OpenID_CryptUtil::randomString( 6, Auth_OpenID_Nonce_CHRS); if ($when === null) { $when = time(); } $time_str = gmstrftime(Auth_OpenID_Nonce_TIME_FMT, $when); return $time_str . $salt; }    import('core.lib.openid.auth.openid.Extension'); define('Auth_OpenID_PAPE_NS_URI', "http://specs.openid.net/extensions/pape/1.0"); define('PAPE_AUTH_MULTI_FACTOR_PHYSICAL', 'http://schemas.openid.net/pape/policies/2007/06/multi-factor-physical'); define('PAPE_AUTH_MULTI_FACTOR', 'http://schemas.openid.net/pape/policies/2007/06/multi-factor'); define('PAPE_AUTH_PHISHING_RESISTANT', 'http://schemas.openid.net/pape/policies/2007/06/phishing-resistant'); define('PAPE_TIME_VALIDATOR', '^[0-9]{4,4}-[0-9][0-9]-[0-9][0-9]T[0-9][0-9]:[0-9][0-9]:[0-9][0-9]Z$'); class Auth_OpenID_PAPE_Request extends Auth_OpenID_Extension { var $ns_alias = 'pape'; var $ns_uri = Auth_OpenID_PAPE_NS_URI; function Auth_OpenID_PAPE_Request($preferred_auth_policies=null, $max_auth_age=null) { if ($preferred_auth_policies === null) { $preferred_auth_policies = array(); } $this->preferred_auth_policies = $preferred_auth_policies; $this->max_auth_age = $max_auth_age; } function addPolicyURI($policy_uri) { if (!in_array($policy_uri, $this->preferred_auth_policies)) { $this->preferred_auth_policies[] = $policy_uri; } } function getExtensionArgs() { $ns_args = array( 'preferred_auth_policies' => implode(' ', $this->preferred_auth_policies) ); if ($this->max_auth_age !== null) { $ns_args['max_auth_age'] = strval($this->max_auth_age); } return $ns_args; } function fromOpenIDRequest($request) { $obj = new Auth_OpenID_PAPE_Request(); $args = $request->message->getArgs(Auth_OpenID_PAPE_NS_URI); if ($args === null || $args === array()) { return null; } $obj->parseExtensionArgs($args); return $obj; } function parseExtensionArgs($args) { $this->preferred_auth_policies = array(); $policies_str = Auth_OpenID::arrayGet($args, 'preferred_auth_policies'); if ($policies_str) { foreach (explode(' ', $policies_str) as $uri) { if (!in_array($uri, $this->preferred_auth_policies)) { $this->preferred_auth_policies[] = $uri; } } } $max_auth_age_str = Auth_OpenID::arrayGet($args, 'max_auth_age'); if ($max_auth_age_str) { $this->max_auth_age = Auth_OpenID::intval($max_auth_age_str); } else { $this->max_auth_age = null; } } function preferredTypes($supported_types) { $result = array(); foreach ($supported_types as $st) { if (in_array($st, $this->preferred_auth_policies)) { $result[] = $st; } } return $result; } } class Auth_OpenID_PAPE_Response extends Auth_OpenID_Extension { var $ns_alias = 'pape'; var $ns_uri = Auth_OpenID_PAPE_NS_URI; function Auth_OpenID_PAPE_Response($auth_policies=null, $auth_time=null, $nist_auth_level=null) { if ($auth_policies) { $this->auth_policies = $auth_policies; } else { $this->auth_policies = array(); } $this->auth_time = $auth_time; $this->nist_auth_level = $nist_auth_level; } function addPolicyURI($policy_uri) { if (!in_array($policy_uri, $this->auth_policies)) { $this->auth_policies[] = $policy_uri; } } function fromSuccessResponse($success_response) { $obj = new Auth_OpenID_PAPE_Response(); $args = $success_response->getSignedNS(Auth_OpenID_PAPE_NS_URI); if ($args === null || $args === array()) { return null; } $result = $obj->parseExtensionArgs($args); if ($result === false) { return null; } else { return $obj; } } function parseExtensionArgs($args, $strict=false) { $policies_str = Auth_OpenID::arrayGet($args, 'auth_policies'); if ($policies_str && $policies_str != "none") { $this->auth_policies = explode(" ", $policies_str); } $nist_level_str = Auth_OpenID::arrayGet($args, 'nist_auth_level'); if ($nist_level_str !== null) { $nist_level = Auth_OpenID::intval($nist_level_str); if ($nist_level === false) { if ($strict) { return false; } else { $nist_level = null; } } if (0 <= $nist_level && $nist_level < 5) { $this->nist_auth_level = $nist_level; } else if ($strict) { return false; } } $auth_time = Auth_OpenID::arrayGet($args, 'auth_time'); if ($auth_time !== null) { if (ereg(PAPE_TIME_VALIDATOR, $auth_time)) { $this->auth_time = $auth_time; } else if ($strict) { return false; } } } function getExtensionArgs() { $ns_args = array(); if (count($this->auth_policies) > 0) { $ns_args['auth_policies'] = implode(' ', $this->auth_policies); } else { $ns_args['auth_policies'] = 'none'; } if ($this->nist_auth_level !== null) { if (!in_array($this->nist_auth_level, range(0, 4), true)) { return false; } $ns_args['nist_auth_level'] = strval($this->nist_auth_level); } if ($this->auth_time !== null) { if (!ereg(PAPE_TIME_VALIDATOR, $this->auth_time)) { return false; } $ns_args['auth_time'] = $this->auth_time; } return $ns_args; } }    import('core.lib.openid.auth.OpenID'); class Auth_OpenID_Parse { var $_re_flags = "si"; var $_removed_re = "<!--.*?-->|<!\[CDATA\[.*?\]\]>|<script\b(?!:)[^>]*>.*?<\/script>"; var $_tag_expr = "<%s\b(?!:)([^>]*?)(?:\/>|>(.*?)(?:<\/?%s\s*>|\Z))"; var $_attr_find = '\b(\w+)=("[^"]*"|\'[^\']*\'|[^\'"\s\/<>]+)'; var $_open_tag_expr = "<%s\b"; var $_close_tag_expr = "<((\/%s\b)|(%s[^>\/]*\/))>"; function Auth_OpenID_Parse() { $this->_link_find = sprintf("/<link\b(?!:)([^>]*)(?!<)>/%s", $this->_re_flags); $this->_entity_replacements = array( 'amp' => '&', 'lt' => '<', 'gt' => '>', 'quot' => '"' ); $this->_attr_find = sprintf("/%s/%s", $this->_attr_find, $this->_re_flags); $this->_removed_re = sprintf("/%s/%s", $this->_removed_re, $this->_re_flags); $this->_ent_replace = sprintf("&(%s);", implode("|", $this->_entity_replacements)); } function tagMatcher($tag_name, $close_tags = null) { $expr = $this->_tag_expr; if ($close_tags) { $options = implode("|", array_merge(array($tag_name), $close_tags)); $closer = sprintf("(?:%s)", $options); } else { $closer = $tag_name; } $expr = sprintf($expr, $tag_name, $closer); return sprintf("/%s/%s", $expr, $this->_re_flags); } function openTag($tag_name) { $expr = sprintf($this->_open_tag_expr, $tag_name); return sprintf("/%s/%s", $expr, $this->_re_flags); } function closeTag($tag_name) { $expr = sprintf($this->_close_tag_expr, $tag_name, $tag_name); return sprintf("/%s/%s", $expr, $this->_re_flags); } function htmlBegin($s) { $matches = array(); $result = preg_match($this->openTag('html'), $s, $matches, PREG_OFFSET_CAPTURE); if ($result === false || !$matches) { return false; } return $matches[0][1]; } function htmlEnd($s) { $matches = array(); $result = preg_match($this->closeTag('html'), $s, $matches, PREG_OFFSET_CAPTURE); if ($result === false || !$matches) { return false; } return $matches[count($matches) - 1][1]; } function headFind() { return $this->tagMatcher('head', array('body', 'html')); } function replaceEntities($str) { foreach ($this->_entity_replacements as $old => $new) { $str = preg_replace(sprintf("/&%s;/", $old), $new, $str); } return $str; } function removeQuotes($str) { $matches = array(); $double = '/^"(.*)"$/'; $single = "/^\'(.*)\'$/"; if (preg_match($double, $str, $matches)) { return $matches[1]; } else if (preg_match($single, $str, $matches)) { return $matches[1]; } else { return $str; } } function parseLinkAttrs($html) { $stripped = preg_replace($this->_removed_re, "", $html); $html_begin = $this->htmlBegin($stripped); $html_end = $this->htmlEnd($stripped); if ($html_begin === false) { return array(); } if ($html_end === false) { $html_end = strlen($stripped); } $stripped = substr($stripped, $html_begin, $html_end - $html_begin); $head_re = $this->headFind(); $head_matches = array(); if (!preg_match($head_re, $stripped, $head_matches)) { return array(); } $link_data = array(); $link_matches = array(); if (!preg_match_all($this->_link_find, $head_matches[0], $link_matches)) { return array(); } foreach ($link_matches[0] as $link) { $attr_matches = array(); preg_match_all($this->_attr_find, $link, $attr_matches); $link_attrs = array(); foreach ($attr_matches[0] as $index => $full_match) { $name = $attr_matches[1][$index]; $value = $this->replaceEntities( $this->removeQuotes($attr_matches[2][$index])); $link_attrs[strtolower($name)] = $value; } $link_data[] = $link_attrs; } return $link_data; } function relMatches($rel_attr, $target_rel) { $rels = preg_split("/\s+/", trim($rel_attr)); foreach ($rels as $rel) { $rel = strtolower($rel); if ($rel == $target_rel) { return 1; } } return 0; } function linkHasRel($link_attrs, $target_rel) { $rel_attr = Auth_OpeniD::arrayGet($link_attrs, 'rel', null); return ($rel_attr && $this->relMatches($rel_attr, $target_rel)); } function findLinksRel($link_attrs_list, $target_rel) { $result = array(); foreach ($link_attrs_list as $attr) { if ($this->linkHasRel($attr, $target_rel)) { $result[] = $attr; } } return $result; } function findFirstHref($link_attrs_list, $target_rel) { $matches = $this->findLinksRel($link_attrs_list, $target_rel); if (!$matches) { return null; } $first = $matches[0]; return Auth_OpenID::arrayGet($first, 'href', null); } } function Auth_OpenID_legacy_discover($html_text, $server_rel, $delegate_rel) { $p = new Auth_OpenID_Parse(); $link_attrs = $p->parseLinkAttrs($html_text); $server_url = $p->findFirstHref($link_attrs, $server_rel); if ($server_url === null) { return false; } else { $delegate_url = $p->findFirstHref($link_attrs, $delegate_rel); return array($delegate_url, $server_url); } }    import('core.lib.openid.auth.openid.SQLStore'); class Auth_OpenID_PostgreSQLStore extends Auth_OpenID_SQLStore { function setSQL() { $this->sql['nonce_table'] = "CREATE TABLE %s (server_url VARCHAR(2047) NOT NULL, ". "timestamp INTEGER NOT NULL, ". "salt CHAR(40) NOT NULL, ". "UNIQUE (server_url, timestamp, salt))"; $this->sql['assoc_table'] = "CREATE TABLE %s (server_url VARCHAR(2047) NOT NULL, ". "handle VARCHAR(255) NOT NULL, ". "secret BYTEA NOT NULL, ". "issued INTEGER NOT NULL, ". "lifetime INTEGER NOT NULL, ". "assoc_type VARCHAR(64) NOT NULL, ". "PRIMARY KEY (server_url, handle), ". "CONSTRAINT secret_length_constraint CHECK ". "(LENGTH(secret) <= 128))"; $this->sql['set_assoc'] = array( 'insert_assoc' => "INSERT INTO %s (server_url, handle, ". "secret, issued, lifetime, assoc_type) VALUES ". "(?, ?, '!', ?, ?, ?)", 'update_assoc' => "UPDATE %s SET secret = '!', issued = ?, ". "lifetime = ?, assoc_type = ? WHERE server_url = ? AND ". "handle = ?" ); $this->sql['get_assocs'] = "SELECT handle, secret, issued, lifetime, assoc_type FROM %s ". "WHERE server_url = ?"; $this->sql['get_assoc'] = "SELECT handle, secret, issued, lifetime, assoc_type FROM %s ". "WHERE server_url = ? AND handle = ?"; $this->sql['remove_assoc'] = "DELETE FROM %s WHERE server_url = ? AND handle = ?"; $this->sql['add_nonce'] = "INSERT INTO %s (server_url, timestamp, salt) VALUES ". "(?, ?, ?)" ; $this->sql['clean_nonce'] = "DELETE FROM %s WHERE timestamp < ?"; $this->sql['clean_assoc'] = "DELETE FROM %s WHERE issued + lifetime < ?"; } function _set_assoc($server_url, $handle, $secret, $issued, $lifetime, $assoc_type) { $result = $this->_get_assoc($server_url, $handle); if ($result) { $this->connection->query($this->sql['set_assoc']['update_assoc'], array($secret, $issued, $lifetime, $assoc_type, $server_url, $handle)); } else { $this->connection->query($this->sql['set_assoc']['insert_assoc'], array($server_url, $handle, $secret, $issued, $lifetime, $assoc_type)); } } function blobEncode($blob) { return $this->_octify($blob); } function blobDecode($blob) { return $this->_unoctify($blob); } }    import('core.lib.openid.auth.OpenID'); import('core.lib.openid.auth.openid.Association'); import('core.lib.openid.auth.openid.CryptUtil'); import('core.lib.openid.auth.openid.BigMath'); import('core.lib.openid.auth.openid.DiffieHellman'); import('core.lib.openid.auth.openid.KVForm'); import('core.lib.openid.auth.openid.TrustRoot'); import('core.lib.openid.auth.openid.ServerRequest'); import('core.lib.openid.auth.openid.Message'); import('core.lib.openid.auth.openid.Nonce'); define('AUTH_OPENID_HTTP_OK', 200); define('AUTH_OPENID_HTTP_REDIRECT', 302); define('AUTH_OPENID_HTTP_ERROR', 400); global $_Auth_OpenID_Request_Modes; $_Auth_OpenID_Request_Modes = array('checkid_setup', 'checkid_immediate'); define('Auth_OpenID_ENCODE_KVFORM', 'kfvorm'); define('Auth_OpenID_ENCODE_URL', 'URL/redirect'); define('Auth_OpenID_ENCODE_HTML_FORM', 'HTML form'); function Auth_OpenID_isError($obj, $cls = 'Auth_OpenID_ServerError') { return is_a($obj, $cls); } class Auth_OpenID_ServerError { function Auth_OpenID_ServerError($message = null, $text = null, $reference = null, $contact = null) { $this->message = $message; $this->text = $text; $this->contact = $contact; $this->reference = $reference; } function getReturnTo() { if ($this->message && $this->message->hasKey(Auth_OpenID_OPENID_NS, 'return_to')) { return $this->message->getArg(Auth_OpenID_OPENID_NS, 'return_to'); } else { return null; } } function hasReturnTo() { return $this->getReturnTo() !== null; } function encodeToURL() { if (!$this->message) { return null; } $msg = $this->toMessage(); return $msg->toURL($this->getReturnTo()); } function encodeToKVForm() { return Auth_OpenID_KVForm::fromArray( array('mode' => 'error', 'error' => $this->toString())); } function toFormMarkup($form_tag_attrs=null) { $msg = $this->toMessage(); return $msg->toFormMarkup($this->getReturnTo(), $form_tag_attrs); } function toHTML($form_tag_attrs=null) { return Auth_OpenID::autoSubmitHTML( $this->toFormMarkup($form_tag_attrs)); } function toMessage() { $namespace = $this->message->getOpenIDNamespace(); $reply = new Auth_OpenID_Message($namespace); $reply->setArg(Auth_OpenID_OPENID_NS, 'mode', 'error'); $reply->setArg(Auth_OpenID_OPENID_NS, 'error', $this->toString()); if ($this->contact !== null) { $reply->setArg(Auth_OpenID_OPENID_NS, 'contact', $this->contact); } if ($this->reference !== null) { $reply->setArg(Auth_OpenID_OPENID_NS, 'reference', $this->reference); } return $reply; } function whichEncoding() { global $_Auth_OpenID_Request_Modes; if ($this->hasReturnTo()) { if ($this->message->isOpenID2() && (strlen($this->encodeToURL()) > Auth_OpenID_OPENID1_URL_LIMIT)) { return Auth_OpenID_ENCODE_HTML_FORM; } else { return Auth_OpenID_ENCODE_URL; } } if (!$this->message) { return null; } $mode = $this->message->getArg(Auth_OpenID_OPENID_NS, 'mode'); if ($mode) { if (!in_array($mode, $_Auth_OpenID_Request_Modes)) { return Auth_OpenID_ENCODE_KVFORM; } } return null; } function toString() { if ($this->text) { return $this->text; } else { return get_class($this) . " error"; } } } class Auth_OpenID_NoReturnToError extends Auth_OpenID_ServerError { function Auth_OpenID_NoReturnToError($message = null, $text = "No return_to URL available") { parent::Auth_OpenID_ServerError($message, $text); } function toString() { return "No return_to available"; } } class Auth_OpenID_MalformedReturnURL extends Auth_OpenID_ServerError { function Auth_OpenID_MalformedReturnURL($message, $return_to) { $this->return_to = $return_to; parent::Auth_OpenID_ServerError($message, "malformed return_to URL"); } } class Auth_OpenID_MalformedTrustRoot extends Auth_OpenID_ServerError { function Auth_OpenID_MalformedTrustRoot($message = null, $text = "Malformed trust root") { parent::Auth_OpenID_ServerError($message, $text); } function toString() { return "Malformed trust root"; } } class Auth_OpenID_Request { var $mode = null; } class Auth_OpenID_CheckAuthRequest extends Auth_OpenID_Request { var $mode = "check_authentication"; var $invalidate_handle = null; function Auth_OpenID_CheckAuthRequest($assoc_handle, $signed, $invalidate_handle = null) { $this->assoc_handle = $assoc_handle; $this->signed = $signed; if ($invalidate_handle !== null) { $this->invalidate_handle = $invalidate_handle; } $this->namespace = Auth_OpenID_OPENID2_NS; $this->message = null; } function fromMessage($message, $server=null) { $required_keys = array('assoc_handle', 'sig', 'signed'); foreach ($required_keys as $k) { if (!$message->getArg(Auth_OpenID_OPENID_NS, $k)) { return new Auth_OpenID_ServerError($message, sprintf("%s request missing required parameter %s from \                             query", "check_authentication", $k)); } } $assoc_handle = $message->getArg(Auth_OpenID_OPENID_NS, 'assoc_handle'); $sig = $message->getArg(Auth_OpenID_OPENID_NS, 'sig'); $signed_list = $message->getArg(Auth_OpenID_OPENID_NS, 'signed'); $signed_list = explode(",", $signed_list); $signed = $message; if ($signed->hasKey(Auth_OpenID_OPENID_NS, 'mode')) { $signed->setArg(Auth_OpenID_OPENID_NS, 'mode', 'id_res'); } $result = new Auth_OpenID_CheckAuthRequest($assoc_handle, $signed); $result->message = $message; $result->sig = $sig; $result->invalidate_handle = $message->getArg(Auth_OpenID_OPENID_NS, 'invalidate_handle'); return $result; } function answer(&$signatory) { $is_valid = $signatory->verify($this->assoc_handle, $this->signed); $signatory->invalidate($this->assoc_handle, true); $response = new Auth_OpenID_ServerResponse($this); $response->fields->setArg(Auth_OpenID_OPENID_NS, 'is_valid', ($is_valid ? "true" : "false")); if ($this->invalidate_handle) { $assoc = $signatory->getAssociation($this->invalidate_handle, false); if (!$assoc) { $response->fields->setArg(Auth_OpenID_OPENID_NS, 'invalidate_handle', $this->invalidate_handle); } } return $response; } } class Auth_OpenID_PlainTextServerSession { var $session_type = 'no-encryption'; var $needs_math = false; var $allowed_assoc_types = array('HMAC-SHA1', 'HMAC-SHA256'); function fromMessage($unused_request) { return new Auth_OpenID_PlainTextServerSession(); } function answer($secret) { return array('mac_key' => base64_encode($secret)); } } class Auth_OpenID_DiffieHellmanSHA1ServerSession { var $session_type = 'DH-SHA1'; var $needs_math = true; var $allowed_assoc_types = array('HMAC-SHA1'); var $hash_func = 'Auth_OpenID_SHA1'; function Auth_OpenID_DiffieHellmanSHA1ServerSession($dh, $consumer_pubkey) { $this->dh = $dh; $this->consumer_pubkey = $consumer_pubkey; } function getDH($message) { $dh_modulus = $message->getArg(Auth_OpenID_OPENID_NS, 'dh_modulus'); $dh_gen = $message->getArg(Auth_OpenID_OPENID_NS, 'dh_gen'); if ((($dh_modulus === null) && ($dh_gen !== null)) || (($dh_gen === null) && ($dh_modulus !== null))) { if ($dh_modulus === null) { $missing = 'modulus'; } else { $missing = 'generator'; } return new Auth_OpenID_ServerError($message, 'If non-default modulus or generator is '. 'supplied, both must be supplied.  Missing '. $missing); } $lib =& Auth_OpenID_getMathLib(); if ($dh_modulus || $dh_gen) { $dh_modulus = $lib->base64ToLong($dh_modulus); $dh_gen = $lib->base64ToLong($dh_gen); if ($lib->cmp($dh_modulus, 0) == 0 || $lib->cmp($dh_gen, 0) == 0) { return new Auth_OpenID_ServerError( $message, "Failed to parse dh_mod or dh_gen"); } $dh = new Auth_OpenID_DiffieHellman($dh_modulus, $dh_gen); } else { $dh = new Auth_OpenID_DiffieHellman(); } $consumer_pubkey = $message->getArg(Auth_OpenID_OPENID_NS, 'dh_consumer_public'); if ($consumer_pubkey === null) { return new Auth_OpenID_ServerError($message, 'Public key for DH-SHA1 session '. 'not found in query'); } $consumer_pubkey = $lib->base64ToLong($consumer_pubkey); if ($consumer_pubkey === false) { return new Auth_OpenID_ServerError($message, "dh_consumer_public is not base64"); } return array($dh, $consumer_pubkey); } function fromMessage($message) { $result = Auth_OpenID_DiffieHellmanSHA1ServerSession::getDH($message); if (is_a($result, 'Auth_OpenID_ServerError')) { return $result; } else { list($dh, $consumer_pubkey) = $result; return new Auth_OpenID_DiffieHellmanSHA1ServerSession($dh, $consumer_pubkey); } } function answer($secret) { $lib =& Auth_OpenID_getMathLib(); $mac_key = $this->dh->xorSecret($this->consumer_pubkey, $secret, $this->hash_func); return array( 'dh_server_public' => $lib->longToBase64($this->dh->public), 'enc_mac_key' => base64_encode($mac_key)); } } class Auth_OpenID_DiffieHellmanSHA256ServerSession extends Auth_OpenID_DiffieHellmanSHA1ServerSession { var $session_type = 'DH-SHA256'; var $hash_func = 'Auth_OpenID_SHA256'; var $allowed_assoc_types = array('HMAC-SHA256'); function fromMessage($message) { $result = Auth_OpenID_DiffieHellmanSHA1ServerSession::getDH($message); if (is_a($result, 'Auth_OpenID_ServerError')) { return $result; } else { list($dh, $consumer_pubkey) = $result; return new Auth_OpenID_DiffieHellmanSHA256ServerSession($dh, $consumer_pubkey); } } } class Auth_OpenID_AssociateRequest extends Auth_OpenID_Request { var $mode = "associate"; function getSessionClasses() { return array( 'no-encryption' => 'Auth_OpenID_PlainTextServerSession', 'DH-SHA1' => 'Auth_OpenID_DiffieHellmanSHA1ServerSession', 'DH-SHA256' => 'Auth_OpenID_DiffieHellmanSHA256ServerSession'); } function Auth_OpenID_AssociateRequest(&$session, $assoc_type) { $this->session =& $session; $this->namespace = Auth_OpenID_OPENID2_NS; $this->assoc_type = $assoc_type; } function fromMessage($message, $server=null) { if ($message->isOpenID1()) { $session_type = $message->getArg(Auth_OpenID_OPENID_NS, 'session_type'); if ($session_type == 'no-encryption') { } else if (!$session_type) { $session_type = 'no-encryption'; } } else { $session_type = $message->getArg(Auth_OpenID_OPENID_NS, 'session_type'); if ($session_type === null) { return new Auth_OpenID_ServerError($message, "session_type missing from request"); } } $session_class = Auth_OpenID::arrayGet( Auth_OpenID_AssociateRequest::getSessionClasses(), $session_type); if ($session_class === null) { return new Auth_OpenID_ServerError($message, "Unknown session type " . $session_type); } $session = call_user_func(array($session_class, 'fromMessage'), $message); if (is_a($session, 'Auth_OpenID_ServerError')) { return $session; } $assoc_type = $message->getArg(Auth_OpenID_OPENID_NS, 'assoc_type', 'HMAC-SHA1'); if (!in_array($assoc_type, $session->allowed_assoc_types)) { $fmt = "Session type %s does not support association type %s"; return new Auth_OpenID_ServerError($message, sprintf($fmt, $session_type, $assoc_type)); } $obj = new Auth_OpenID_AssociateRequest($session, $assoc_type); $obj->message = $message; $obj->namespace = $message->getOpenIDNamespace(); return $obj; } function answer($assoc) { $response = new Auth_OpenID_ServerResponse($this); $response->fields->updateArgs(Auth_OpenID_OPENID_NS, array( 'expires_in' => sprintf('%d', $assoc->getExpiresIn()), 'assoc_type' => $this->assoc_type, 'assoc_handle' => $assoc->handle)); $response->fields->updateArgs(Auth_OpenID_OPENID_NS, $this->session->answer($assoc->secret)); if (! ($this->session->session_type == 'no-encryption' && $this->message->isOpenID1())) { $response->fields->setArg(Auth_OpenID_OPENID_NS, 'session_type', $this->session->session_type); } return $response; } function answerUnsupported($text_message, $preferred_association_type=null, $preferred_session_type=null) { if ($this->message->isOpenID1()) { return new Auth_OpenID_ServerError($this->message); } $response = new Auth_OpenID_ServerResponse($this); $response->fields->setArg(Auth_OpenID_OPENID_NS, 'error_code', 'unsupported-type'); $response->fields->setArg(Auth_OpenID_OPENID_NS, 'error', $text_message); if ($preferred_association_type) { $response->fields->setArg(Auth_OpenID_OPENID_NS, 'assoc_type', $preferred_association_type); } if ($preferred_session_type) { $response->fields->setArg(Auth_OpenID_OPENID_NS, 'session_type', $preferred_session_type); } return $response; } } class Auth_OpenID_CheckIDRequest extends Auth_OpenID_Request { var $verifyReturnTo = 'Auth_OpenID_verifyReturnTo'; var $mode = "checkid_setup"; var $immediate = false; var $trust_root = null; var $namespace; function make(&$message, $identity, $return_to, $trust_root = null, $immediate = false, $assoc_handle = null, $server = null) { if ($server === null) { return new Auth_OpenID_ServerError($message, "server must not be null"); } if ($return_to && !Auth_OpenID_TrustRoot::_parse($return_to)) { return new Auth_OpenID_MalformedReturnURL($message, $return_to); } $r = new Auth_OpenID_CheckIDRequest($identity, $return_to, $trust_root, $immediate, $assoc_handle, $server); $r->namespace = $message->getOpenIDNamespace(); $r->message =& $message; if (!$r->trustRootValid()) { return new Auth_OpenID_UntrustedReturnURL($message, $return_to, $trust_root); } else { return $r; } } function Auth_OpenID_CheckIDRequest($identity, $return_to, $trust_root = null, $immediate = false, $assoc_handle = null, $server = null) { $this->namespace = Auth_OpenID_OPENID2_NS; $this->assoc_handle = $assoc_handle; $this->identity = $identity; $this->claimed_id = $identity; $this->return_to = $return_to; $this->trust_root = $trust_root; $this->server =& $server; if ($immediate) { $this->immediate = true; $this->mode = "checkid_immediate"; } else { $this->immediate = false; $this->mode = "checkid_setup"; } } function equals($other) { return ( (is_a($other, 'Auth_OpenID_CheckIDRequest')) && ($this->namespace == $other->namespace) && ($this->assoc_handle == $other->assoc_handle) && ($this->identity == $other->identity) && ($this->claimed_id == $other->claimed_id) && ($this->return_to == $other->return_to) && ($this->trust_root == $other->trust_root)); } function returnToVerified() { return call_user_func_array($this->verifyReturnTo, array($this->trust_root, $this->return_to)); } function fromMessage(&$message, $server) { $mode = $message->getArg(Auth_OpenID_OPENID_NS, 'mode'); $immediate = null; if ($mode == "checkid_immediate") { $immediate = true; $mode = "checkid_immediate"; } else { $immediate = false; $mode = "checkid_setup"; } $return_to = $message->getArg(Auth_OpenID_OPENID_NS, 'return_to'); if (($message->isOpenID1()) && (!$return_to)) { $fmt = "Missing required field 'return_to' from checkid request"; return new Auth_OpenID_ServerError($message, $fmt); } $identity = $message->getArg(Auth_OpenID_OPENID_NS, 'identity'); $claimed_id = $message->getArg(Auth_OpenID_OPENID_NS, 'claimed_id'); if ($message->isOpenID1()) { if ($identity === null) { $s = "OpenID 1 message did not contain openid.identity"; return new Auth_OpenID_ServerError($message, $s); } } else { if ($identity && !$claimed_id) { $s = "OpenID 2.0 message contained openid.identity but not " . "claimed_id"; return new Auth_OpenID_ServerError($message, $s); } else if ($claimed_id && !$identity) { $s = "OpenID 2.0 message contained openid.claimed_id " . "but not identity"; return new Auth_OpenID_ServerError($message, $s); } } if ($message->isOpenID1()) { $trust_root_param = 'trust_root'; } else { $trust_root_param = 'realm'; } $trust_root = $message->getArg(Auth_OpenID_OPENID_NS, $trust_root_param); if (! $trust_root) { $trust_root = $return_to; } if (! $message->isOpenID1() && ($return_to === null) && ($trust_root === null)) { return new Auth_OpenID_ServerError($message, "openid.realm required when openid.return_to absent"); } $assoc_handle = $message->getArg(Auth_OpenID_OPENID_NS, 'assoc_handle'); $obj = Auth_OpenID_CheckIDRequest::make($message, $identity, $return_to, $trust_root, $immediate, $assoc_handle, $server); if (is_a($obj, 'Auth_OpenID_ServerError')) { return $obj; } $obj->claimed_id = $claimed_id; return $obj; } function idSelect() { return $this->identity == Auth_OpenID_IDENTIFIER_SELECT; } function trustRootValid() { if (!$this->trust_root) { return true; } $tr = Auth_OpenID_TrustRoot::_parse($this->trust_root); if ($tr === false) { return new Auth_OpenID_MalformedTrustRoot($this->message, $this->trust_root); } if ($this->return_to !== null) { return Auth_OpenID_TrustRoot::match($this->trust_root, $this->return_to); } else { return true; } } function answer($allow, $server_url = null, $identity = null, $claimed_id = null) { if (!$this->return_to) { return new Auth_OpenID_NoReturnToError(); } if (!$server_url) { if ((!$this->message->isOpenID1()) && (!$this->server->op_endpoint)) { return new Auth_OpenID_ServerError(null, "server should be constructed with op_endpoint to " . "respond to OpenID 2.0 messages."); } $server_url = $this->server->op_endpoint; } if ($allow) { $mode = 'id_res'; } else if ($this->message->isOpenID1()) { if ($this->immediate) { $mode = 'id_res'; } else { $mode = 'cancel'; } } else { if ($this->immediate) { $mode = 'setup_needed'; } else { $mode = 'cancel'; } } if (!$this->trustRootValid()) { return new Auth_OpenID_UntrustedReturnURL(null, $this->return_to, $this->trust_root); } $response = new Auth_OpenID_ServerResponse($this); if ($claimed_id && ($this->message->isOpenID1())) { return new Auth_OpenID_ServerError(null, "claimed_id is new in OpenID 2.0 and not " . "available for ".$this->namespace); } if ($identity && !$claimed_id) { $claimed_id = $identity; } if ($allow) { if ($this->identity == Auth_OpenID_IDENTIFIER_SELECT) { if (!$identity) { return new Auth_OpenID_ServerError(null, "This request uses IdP-driven identifier selection.  " . "You must supply an identifier in the response."); } $response_identity = $identity; $response_claimed_id = $claimed_id; } else if ($this->identity) { if ($identity && ($this->identity != $identity)) { $fmt = "Request was for %s, cannot reply with identity %s"; return new Auth_OpenID_ServerError(null, sprintf($fmt, $this->identity, $identity)); } $response_identity = $this->identity; $response_claimed_id = $this->claimed_id; } else { if ($identity) { return new Auth_OpenID_ServerError(null, "This request specified no identity and " . "you supplied ".$identity); } $response_identity = null; } if (($this->message->isOpenID1()) && ($response_identity === null)) { return new Auth_OpenID_ServerError(null, "Request was an OpenID 1 request, so response must " . "include an identifier."); } $response->fields->updateArgs(Auth_OpenID_OPENID_NS, array('mode' => $mode, 'return_to' => $this->return_to, 'response_nonce' => Auth_OpenID_mkNonce())); if (!$this->message->isOpenID1()) { $response->fields->setArg(Auth_OpenID_OPENID_NS, 'op_endpoint', $server_url); } if ($response_identity !== null) { $response->fields->setArg( Auth_OpenID_OPENID_NS, 'identity', $response_identity); if ($this->message->isOpenID2()) { $response->fields->setArg( Auth_OpenID_OPENID_NS, 'claimed_id', $response_claimed_id); } } } else { $response->fields->setArg(Auth_OpenID_OPENID_NS, 'mode', $mode); if ($this->immediate) { if (($this->message->isOpenID1()) && (!$server_url)) { return new Auth_OpenID_ServerError(null, 'setup_url is required for $allow=false \                                   in OpenID 1.x immediate mode.'); } $setup_request =& new Auth_OpenID_CheckIDRequest( $this->identity, $this->return_to, $this->trust_root, false, $this->assoc_handle, $this->server); $setup_request->message = $this->message; $setup_url = $setup_request->encodeToURL($server_url); if ($setup_url === null) { return new Auth_OpenID_NoReturnToError(); } $response->fields->setArg(Auth_OpenID_OPENID_NS, 'user_setup_url', $setup_url); } } return $response; } function encodeToURL($server_url) { if (!$this->return_to) { return new Auth_OpenID_NoReturnToError(); } $q = array('mode' => $this->mode, 'identity' => $this->identity, 'claimed_id' => $this->claimed_id, 'return_to' => $this->return_to); if ($this->trust_root) { if ($this->message->isOpenID1()) { $q['trust_root'] = $this->trust_root; } else { $q['realm'] = $this->trust_root; } } if ($this->assoc_handle) { $q['assoc_handle'] = $this->assoc_handle; } $response = new Auth_OpenID_Message( $this->message->getOpenIDNamespace()); $response->updateArgs(Auth_OpenID_OPENID_NS, $q); return $response->toURL($server_url); } function getCancelURL() { if (!$this->return_to) { return new Auth_OpenID_NoReturnToError(); } if ($this->immediate) { return new Auth_OpenID_ServerError(null, "Cancel is not an appropriate \                                                response to immediate mode \                                                requests."); } $response = new Auth_OpenID_Message( $this->message->getOpenIDNamespace()); $response->setArg(Auth_OpenID_OPENID_NS, 'mode', 'cancel'); return $response->toURL($this->return_to); } } class Auth_OpenID_ServerResponse { function Auth_OpenID_ServerResponse(&$request) { $this->request =& $request; $this->fields = new Auth_OpenID_Message($this->request->namespace); } function whichEncoding() { global $_Auth_OpenID_Request_Modes; if (in_array($this->request->mode, $_Auth_OpenID_Request_Modes)) { if ($this->fields->isOpenID2() && (strlen($this->encodeToURL()) > Auth_OpenID_OPENID1_URL_LIMIT)) { return Auth_OpenID_ENCODE_HTML_FORM; } else { return Auth_OpenID_ENCODE_URL; } } else { return Auth_OpenID_ENCODE_KVFORM; } } function toFormMarkup($form_tag_attrs=null) { return $this->fields->toFormMarkup($this->request->return_to, $form_tag_attrs); } function toHTML() { return Auth_OpenID::autoSubmitHTML($this->toFormMarkup()); } function renderAsForm() { return $this->whichEncoding() == Auth_OpenID_ENCODE_HTML_FORM; } function encodeToURL() { return $this->fields->toURL($this->request->return_to); } function addExtension($extension_response) { $extension_response->toMessage($this->fields); } function needsSigning() { return $this->fields->getArg(Auth_OpenID_OPENID_NS, 'mode') == 'id_res'; } function encodeToKVForm() { return $this->fields->toKVForm(); } } class Auth_OpenID_WebResponse { var $code = AUTH_OPENID_HTTP_OK; var $body = ""; function Auth_OpenID_WebResponse($code = null, $headers = null, $body = null) { if ($code) { $this->code = $code; } if ($headers !== null) { $this->headers = $headers; } else { $this->headers = array(); } if ($body !== null) { $this->body = $body; } } } class Auth_OpenID_Signatory { var $SECRET_LIFETIME = 1209600; var $normal_key = 'http://localhost/|normal'; var $dumb_key = 'http://localhost/|dumb'; function Auth_OpenID_Signatory(&$store) { $this->store =& $store; } function verify($assoc_handle, $message) { $assoc = $this->getAssociation($assoc_handle, true); if (!$assoc) { return false; } return $assoc->checkMessageSignature($message); } function sign($response) { $signed_response = $response; $assoc_handle = $response->request->assoc_handle; if ($assoc_handle) { $assoc = $this->getAssociation($assoc_handle, false, false); if (!$assoc || ($assoc->getExpiresIn() <= 0)) { $signed_response->fields->setArg(Auth_OpenID_OPENID_NS, 'invalidate_handle', $assoc_handle); $assoc_type = ($assoc ? $assoc->assoc_type : 'HMAC-SHA1'); if ($assoc && ($assoc->getExpiresIn() <= 0)) { $this->invalidate($assoc_handle, false); } $assoc = $this->createAssociation(true, $assoc_type); } } else { $assoc = $this->createAssociation(true); } $signed_response->fields = $assoc->signMessage( $signed_response->fields); return $signed_response; } function createAssociation($dumb = true, $assoc_type = 'HMAC-SHA1') { $secret = Auth_OpenID_CryptUtil::getBytes( Auth_OpenID_getSecretSize($assoc_type)); $uniq = base64_encode(Auth_OpenID_CryptUtil::getBytes(4)); $handle = sprintf('{%s}{%x}{%s}', $assoc_type, intval(time()), $uniq); $assoc = Auth_OpenID_Association::fromExpiresIn( $this->SECRET_LIFETIME, $handle, $secret, $assoc_type); if ($dumb) { $key = $this->dumb_key; } else { $key = $this->normal_key; } $this->store->storeAssociation($key, $assoc); return $assoc; } function getAssociation($assoc_handle, $dumb, $check_expiration=true) { if ($assoc_handle === null) { return new Auth_OpenID_ServerError(null, "assoc_handle must not be null"); } if ($dumb) { $key = $this->dumb_key; } else { $key = $this->normal_key; } $assoc = $this->store->getAssociation($key, $assoc_handle); if (($assoc !== null) && ($assoc->getExpiresIn() <= 0)) { if ($check_expiration) { $this->store->removeAssociation($key, $assoc_handle); $assoc = null; } } return $assoc; } function invalidate($assoc_handle, $dumb) { if ($dumb) { $key = $this->dumb_key; } else { $key = $this->normal_key; } $this->store->removeAssociation($key, $assoc_handle); } } class Auth_OpenID_Encoder { var $responseFactory = 'Auth_OpenID_WebResponse'; function encode(&$response) { $cls = $this->responseFactory; $encode_as = $response->whichEncoding(); if ($encode_as == Auth_OpenID_ENCODE_KVFORM) { $wr = new $cls(null, null, $response->encodeToKVForm()); if (is_a($response, 'Auth_OpenID_ServerError')) { $wr->code = AUTH_OPENID_HTTP_ERROR; } } else if ($encode_as == Auth_OpenID_ENCODE_URL) { $location = $response->encodeToURL(); $wr = new $cls(AUTH_OPENID_HTTP_REDIRECT, array('location' => $location)); } else if ($encode_as == Auth_OpenID_ENCODE_HTML_FORM) { $wr = new $cls(AUTH_OPENID_HTTP_OK, array(), $response->toFormMarkup()); } else { return new Auth_OpenID_EncodingError($response); } return $wr; } } class Auth_OpenID_SigningEncoder extends Auth_OpenID_Encoder { function Auth_OpenID_SigningEncoder(&$signatory) { $this->signatory =& $signatory; } function encode(&$response) { if (!is_a($response, 'Auth_OpenID_ServerError') && $response->needsSigning()) { if (!$this->signatory) { return new Auth_OpenID_ServerError(null, "Must have a store to sign request"); } if ($response->fields->hasKey(Auth_OpenID_OPENID_NS, 'sig')) { return new Auth_OpenID_AlreadySigned($response); } $response = $this->signatory->sign($response); } return parent::encode($response); } } class Auth_OpenID_Decoder { function Auth_OpenID_Decoder(&$server) { $this->server =& $server; $this->handlers = array( 'checkid_setup' => 'Auth_OpenID_CheckIDRequest', 'checkid_immediate' => 'Auth_OpenID_CheckIDRequest', 'check_authentication' => 'Auth_OpenID_CheckAuthRequest', 'associate' => 'Auth_OpenID_AssociateRequest' ); } function decode($query) { if (!$query) { return null; } $message = Auth_OpenID_Message::fromPostArgs($query); if ($message === null) { $old_ns = $query['openid.ns']; $query['openid.ns'] = Auth_OpenID_OPENID2_NS; $message = Auth_OpenID_Message::fromPostArgs($query); return new Auth_OpenID_ServerError( $message, sprintf("Invalid OpenID namespace URI: %s", $old_ns)); } $mode = $message->getArg(Auth_OpenID_OPENID_NS, 'mode'); if (!$mode) { return new Auth_OpenID_ServerError($message, "No mode value in message"); } if (Auth_OpenID::isFailure($mode)) { return new Auth_OpenID_ServerError($message, $mode->message); } $handlerCls = Auth_OpenID::arrayGet($this->handlers, $mode, $this->defaultDecoder($message)); if (!is_a($handlerCls, 'Auth_OpenID_ServerError')) { return call_user_func_array(array($handlerCls, 'fromMessage'), array($message, $this->server)); } else { return $handlerCls; } } function defaultDecoder($message) { $mode = $message->getArg(Auth_OpenID_OPENID_NS, 'mode'); if (Auth_OpenID::isFailure($mode)) { return new Auth_OpenID_ServerError($message, $mode->message); } return new Auth_OpenID_ServerError($message, sprintf("Unrecognized OpenID mode %s", $mode)); } } class Auth_OpenID_EncodingError { function Auth_OpenID_EncodingError(&$response) { $this->response =& $response; } } class Auth_OpenID_AlreadySigned extends Auth_OpenID_EncodingError { } class Auth_OpenID_UntrustedReturnURL extends Auth_OpenID_ServerError { function Auth_OpenID_UntrustedReturnURL($message, $return_to, $trust_root) { parent::Auth_OpenID_ServerError($message, "Untrusted return_to URL"); $this->return_to = $return_to; $this->trust_root = $trust_root; } function toString() { return sprintf("return_to %s not under trust_root %s", $this->return_to, $this->trust_root); } } class Auth_OpenID_Server { function Auth_OpenID_Server(&$store, $op_endpoint=null) { $this->store =& $store; $this->signatory =& new Auth_OpenID_Signatory($this->store); $this->encoder =& new Auth_OpenID_SigningEncoder($this->signatory); $this->decoder =& new Auth_OpenID_Decoder($this); $this->op_endpoint = $op_endpoint; $this->negotiator =& Auth_OpenID_getDefaultNegotiator(); } function handleRequest($request) { if (method_exists($this, "openid_" . $request->mode)) { $handler = array($this, "openid_" . $request->mode); return call_user_func($handler, $request); } return null; } function openid_check_authentication(&$request) { return $request->answer($this->signatory); } function openid_associate(&$request) { $assoc_type = $request->assoc_type; $session_type = $request->session->session_type; if ($this->negotiator->isAllowed($assoc_type, $session_type)) { $assoc = $this->signatory->createAssociation(false, $assoc_type); return $request->answer($assoc); } else { $message = sprintf('Association type %s is not supported with '. 'session type %s', $assoc_type, $session_type); list($preferred_assoc_type, $preferred_session_type) = $this->negotiator->getAllowedType(); return $request->answerUnsupported($message, $preferred_assoc_type, $preferred_session_type); } } function encodeResponse(&$response) { return $this->encoder->encode($response); } function decodeRequest($query=null) { if ($query === null) { $query = Auth_OpenID::getQuery(); } return $this->decoder->decode($query); } }     import('core.lib.openid.auth.OpenID'); class Auth_OpenID_ServerRequest { function Auth_OpenID_ServerRequest() { $this->mode = null; } }    import('core.lib.openid.auth.openid.SQLStore'); class Auth_OpenID_SQLiteStore extends Auth_OpenID_SQLStore { function setSQL() { $this->sql['nonce_table'] = "CREATE TABLE %s (server_url VARCHAR(2047), timestamp INTEGER, ". "salt CHAR(40), UNIQUE (server_url, timestamp, salt))"; $this->sql['assoc_table'] = "CREATE TABLE %s (server_url VARCHAR(2047), handle VARCHAR(255), ". "secret BLOB(128), issued INTEGER, lifetime INTEGER, ". "assoc_type VARCHAR(64), PRIMARY KEY (server_url, handle))"; $this->sql['set_assoc'] = "INSERT OR REPLACE INTO %s VALUES (?, ?, ?, ?, ?, ?)"; $this->sql['get_assocs'] = "SELECT handle, secret, issued, lifetime, assoc_type FROM %s ". "WHERE server_url = ?"; $this->sql['get_assoc'] = "SELECT handle, secret, issued, lifetime, assoc_type FROM %s ". "WHERE server_url = ? AND handle = ?"; $this->sql['remove_assoc'] = "DELETE FROM %s WHERE server_url = ? AND handle = ?"; $this->sql['add_nonce'] = "INSERT INTO %s (server_url, timestamp, salt) VALUES (?, ?, ?)"; $this->sql['clean_nonce'] = "DELETE FROM %s WHERE timestamp < ?"; $this->sql['clean_assoc'] = "DELETE FROM %s WHERE issued + lifetime < ?"; } function _add_nonce($server_url, $timestamp, $salt) { return parent::_add_nonce('x' . $server_url, $timestamp, $salt); } }    global $__Auth_OpenID_PEAR_AVAILABLE; $__Auth_OpenID_PEAR_AVAILABLE = @include_once 'DB.php'; import('core.lib.openid.auth.openid.Interface'); import('core.lib.openid.auth.openid.Nonce'); import('core.lib.openid.auth.OpenID'); import('core.lib.openid.auth.openid.Nonce'); class Auth_OpenID_SQLStore extends Auth_OpenID_OpenIDStore { function Auth_OpenID_SQLStore($connection, $associations_table = null, $nonces_table = null) { global $__Auth_OpenID_PEAR_AVAILABLE; $this->associations_table_name = "oid_associations"; $this->nonces_table_name = "oid_nonces"; if (!(is_object($connection) && (is_subclass_of($connection, 'db_common') || is_subclass_of($connection, 'auth_openid_databaseconnection')))) { trigger_error("Auth_OpenID_SQLStore expected PEAR connection " . "object (got ".get_class($connection).")", E_USER_ERROR); return; } $this->connection = $connection; if ($__Auth_OpenID_PEAR_AVAILABLE) { $this->connection->setFetchMode(DB_FETCHMODE_ASSOC); } if ($associations_table) { $this->associations_table_name = $associations_table; } if ($nonces_table) { $this->nonces_table_name = $nonces_table; } $this->max_nonce_age = 6 * 60 * 60; $this->connection->autoCommit(false); $this->sql = array(); $this->setSQL(); list($missing, $empty) = $this->_verifySQL(); if ($missing) { trigger_error("Expected keys in SQL query list: " . implode(", ", $missing), E_USER_ERROR); return; } if ($empty) { trigger_error("SQL list keys have no SQL strings: " . implode(", ", $empty), E_USER_ERROR); return; } $this->_fixSQL(); } function tableExists($table_name) { return !$this->isError( $this->connection->query( sprintf("SELECT * FROM %s LIMIT 0", $table_name))); } function isError($value) { return PEAR::isError($value); } function resultToBool($obj) { if ($this->isError($obj)) { return false; } else { return true; } } function setSQL() { } function reset() { $this->connection->query(sprintf("DELETE FROM %s", $this->associations_table_name)); $this->connection->query(sprintf("DELETE FROM %s", $this->nonces_table_name)); } function _verifySQL() { $missing = array(); $empty = array(); $required_sql_keys = array( 'nonce_table', 'assoc_table', 'set_assoc', 'get_assoc', 'get_assocs', 'remove_assoc' ); foreach ($required_sql_keys as $key) { if (!array_key_exists($key, $this->sql)) { $missing[] = $key; } else if (!$this->sql[$key]) { $empty[] = $key; } } return array($missing, $empty); } function _fixSQL() { $replacements = array( array( 'value' => $this->nonces_table_name, 'keys' => array('nonce_table', 'add_nonce', 'clean_nonce') ), array( 'value' => $this->associations_table_name, 'keys' => array('assoc_table', 'set_assoc', 'get_assoc', 'get_assocs', 'remove_assoc', 'clean_assoc') ) ); foreach ($replacements as $item) { $value = $item['value']; $keys = $item['keys']; foreach ($keys as $k) { if (is_array($this->sql[$k])) { foreach ($this->sql[$k] as $part_key => $part_value) { $this->sql[$k][$part_key] = sprintf($part_value, $value); } } else { $this->sql[$k] = sprintf($this->sql[$k], $value); } } } } function blobDecode($blob) { return $blob; } function blobEncode($str) { return $str; } function createTables() { $this->connection->autoCommit(true); $n = $this->create_nonce_table(); $a = $this->create_assoc_table(); $this->connection->autoCommit(false); if ($n && $a) { return true; } else { return false; } } function create_nonce_table() { if (!$this->tableExists($this->nonces_table_name)) { $r = $this->connection->query($this->sql['nonce_table']); return $this->resultToBool($r); } return true; } function create_assoc_table() { if (!$this->tableExists($this->associations_table_name)) { $r = $this->connection->query($this->sql['assoc_table']); return $this->resultToBool($r); } return true; } function _set_assoc($server_url, $handle, $secret, $issued, $lifetime, $assoc_type) { return $this->connection->query($this->sql['set_assoc'], array( $server_url, $handle, $secret, $issued, $lifetime, $assoc_type)); } function storeAssociation($server_url, $association) { if ($this->resultToBool($this->_set_assoc( $server_url, $association->handle, $this->blobEncode( $association->secret), $association->issued, $association->lifetime, $association->assoc_type ))) { $this->connection->commit(); } else { $this->connection->rollback(); } } function _get_assoc($server_url, $handle) { $result = $this->connection->getRow($this->sql['get_assoc'], array($server_url, $handle)); if ($this->isError($result)) { return null; } else { return $result; } } function _get_assocs($server_url) { $result = $this->connection->getAll($this->sql['get_assocs'], array($server_url)); if ($this->isError($result)) { return array(); } else { return $result; } } function removeAssociation($server_url, $handle) { if ($this->_get_assoc($server_url, $handle) == null) { return false; } if ($this->resultToBool($this->connection->query( $this->sql['remove_assoc'], array($server_url, $handle)))) { $this->connection->commit(); } else { $this->connection->rollback(); } return true; } function getAssociation($server_url, $handle = null) { if ($handle !== null) { $assoc = $this->_get_assoc($server_url, $handle); $assocs = array(); if ($assoc) { $assocs[] = $assoc; } } else { $assocs = $this->_get_assocs($server_url); } if (!$assocs || (count($assocs) == 0)) { return null; } else { $associations = array(); foreach ($assocs as $assoc_row) { $assoc = new Auth_OpenID_Association($assoc_row['handle'], $assoc_row['secret'], $assoc_row['issued'], $assoc_row['lifetime'], $assoc_row['assoc_type']); $assoc->secret = $this->blobDecode($assoc->secret); if ($assoc->getExpiresIn() == 0) { $this->removeAssociation($server_url, $assoc->handle); } else { $associations[] = array($assoc->issued, $assoc); } } if ($associations) { $issued = array(); $assocs = array(); foreach ($associations as $key => $assoc) { $issued[$key] = $assoc[0]; $assocs[$key] = $assoc[1]; } array_multisort($issued, SORT_DESC, $assocs, SORT_DESC, $associations); list($issued, $assoc) = $associations[0]; return $assoc; } else { return null; } } } function _add_nonce($server_url, $timestamp, $salt) { $sql = $this->sql['add_nonce']; $result = $this->connection->query($sql, array($server_url, $timestamp, $salt)); if ($this->isError($result)) { $this->connection->rollback(); } else { $this->connection->commit(); } return $this->resultToBool($result); } function useNonce($server_url, $timestamp, $salt) { global $Auth_OpenID_SKEW; if ( abs($timestamp - time()) > $Auth_OpenID_SKEW ) { return False; } return $this->_add_nonce($server_url, $timestamp, $salt); } function _octify($str) { $result = ""; for ($i = 0; $i < Auth_OpenID::bytes($str); $i++) { $ch = substr($str, $i, 1); if ($ch == "\\") { $result .= "\\\\\\\\"; } else if (ord($ch) == 0) { $result .= "\\\\000"; } else { $result .= "\\" . strval(decoct(ord($ch))); } } return $result; } function _unoctify($str) { $result = ""; $i = 0; while ($i < strlen($str)) { $char = $str[$i]; if ($char == "\\") { if ($str[$i + 1] != "\\") { $octal_digits = substr($str, $i + 1, 3); $dec = octdec($octal_digits); $char = chr($dec); $i += 4; } else { $char = "\\"; $i += 2; } } else { $i += 1; } $result .= $char; } return $result; } function cleanupNonces() { global $Auth_OpenID_SKEW; $v = time() - $Auth_OpenID_SKEW; $this->connection->query($this->sql['clean_nonce'], array($v)); $num = $this->connection->affectedRows(); $this->connection->commit(); return $num; } function cleanupAssociations() { $this->connection->query($this->sql['clean_assoc'], array(time())); $num = $this->connection->affectedRows(); $this->connection->commit(); return $num; } }     import('core.lib.openid.auth.openid.Message'); import('core.lib.openid.auth.openid.Extension'); global $Auth_OpenID_sreg_data_fields; $Auth_OpenID_sreg_data_fields = array( 'fullname' => 'Full Name', 'nickname' => 'Nickname', 'dob' => 'Date of Birth', 'email' => 'E-mail Address', 'gender' => 'Gender', 'postcode' => 'Postal Code', 'country' => 'Country', 'language' => 'Language', 'timezone' => 'Time Zone'); function Auth_OpenID_checkFieldName($field_name) { global $Auth_OpenID_sreg_data_fields; if (!in_array($field_name, array_keys($Auth_OpenID_sreg_data_fields))) { return false; } return true; } define('Auth_OpenID_SREG_NS_URI_1_0', 'http://openid.net/sreg/1.0'); define('Auth_OpenID_SREG_NS_URI_1_1', 'http://openid.net/extensions/sreg/1.1'); define('Auth_OpenID_SREG_NS_URI', Auth_OpenID_SREG_NS_URI_1_1); Auth_OpenID_registerNamespaceAlias(Auth_OpenID_SREG_NS_URI_1_1, 'sreg'); function Auth_OpenID_supportsSReg(&$endpoint) { return ($endpoint->usesExtension(Auth_OpenID_SREG_NS_URI_1_1) || $endpoint->usesExtension(Auth_OpenID_SREG_NS_URI_1_0)); } class Auth_OpenID_SRegBase extends Auth_OpenID_Extension { function _getSRegNS(&$message) { $alias = null; $found_ns_uri = null; foreach (array(Auth_OpenID_SREG_NS_URI_1_1, Auth_OpenID_SREG_NS_URI_1_0) as $sreg_ns_uri) { $alias = $message->namespaces->getAlias($sreg_ns_uri); if ($alias !== null) { $found_ns_uri = $sreg_ns_uri; break; } } if ($alias === null) { $found_ns_uri = Auth_OpenID_SREG_NS_URI_1_1; if ($message->namespaces->addAlias(Auth_OpenID_SREG_NS_URI_1_1, 'sreg') === null) { return null; } } return $found_ns_uri; } } class Auth_OpenID_SRegRequest extends Auth_OpenID_SRegBase { var $ns_alias = 'sreg'; function build($required=null, $optional=null, $policy_url=null, $sreg_ns_uri=Auth_OpenID_SREG_NS_URI, $cls='Auth_OpenID_SRegRequest') { $obj = new $cls(); $obj->required = array(); $obj->optional = array(); $obj->policy_url = $policy_url; $obj->ns_uri = $sreg_ns_uri; if ($required) { if (!$obj->requestFields($required, true, true)) { return null; } } if ($optional) { if (!$obj->requestFields($optional, false, true)) { return null; } } return $obj; } function fromOpenIDRequest($request, $cls='Auth_OpenID_SRegRequest') { $obj = call_user_func_array(array($cls, 'build'), array(null, null, null, Auth_OpenID_SREG_NS_URI, $cls)); $m = $request->message; $obj->ns_uri = $obj->_getSRegNS($m); $args = $m->getArgs($obj->ns_uri); if ($args === null || Auth_OpenID::isFailure($args)) { return null; } $obj->parseExtensionArgs($args); return $obj; } function parseExtensionArgs($args, $strict=false) { foreach (array('required', 'optional') as $list_name) { $required = ($list_name == 'required'); $items = Auth_OpenID::arrayGet($args, $list_name); if ($items) { foreach (explode(',', $items) as $field_name) { if (!$this->requestField($field_name, $required, $strict)) { if ($strict) { return false; } } } } } $this->policy_url = Auth_OpenID::arrayGet($args, 'policy_url'); return true; } function allRequestedFields() { return array_merge($this->required, $this->optional); } function wereFieldsRequested() { return count($this->allRequestedFields()); } function contains($field_name) { return (in_array($field_name, $this->required) || in_array($field_name, $this->optional)); } function requestField($field_name, $required=false, $strict=false) { if (!Auth_OpenID_checkFieldName($field_name)) { return false; } if ($strict) { if ($this->contains($field_name)) { return false; } } else { if (in_array($field_name, $this->required)) { return true; } if (in_array($field_name, $this->optional)) { if ($required) { unset($this->optional[array_search($field_name, $this->optional)]); } else { return true; } } } if ($required) { $this->required[] = $field_name; } else { $this->optional[] = $field_name; } return true; } function requestFields($field_names, $required=false, $strict=false) { if (!is_array($field_names)) { return false; } foreach ($field_names as $field_name) { if (!$this->requestField($field_name, $required, $strict=$strict)) { return false; } } return true; } function getExtensionArgs() { $args = array(); if ($this->required) { $args['required'] = implode(',', $this->required); } if ($this->optional) { $args['optional'] = implode(',', $this->optional); } if ($this->policy_url) { $args['policy_url'] = $this->policy_url; } return $args; } } class Auth_OpenID_SRegResponse extends Auth_OpenID_SRegBase { var $ns_alias = 'sreg'; function Auth_OpenID_SRegResponse($data=null, $sreg_ns_uri=Auth_OpenID_SREG_NS_URI) { if ($data === null) { $this->data = array(); } else { $this->data = $data; } $this->ns_uri = $sreg_ns_uri; } function extractResponse($request, $data) { $obj = new Auth_OpenID_SRegResponse(); $obj->ns_uri = $request->ns_uri; foreach ($request->allRequestedFields() as $field) { $value = Auth_OpenID::arrayGet($data, $field); if ($value !== null) { $obj->data[$field] = $value; } } return $obj; } function fromSuccessResponse(&$success_response, $signed_only=true) { global $Auth_OpenID_sreg_data_fields; $obj = new Auth_OpenID_SRegResponse(); $obj->ns_uri = $obj->_getSRegNS($success_response->message); if ($signed_only) { $args = $success_response->getSignedNS($obj->ns_uri); } else { $args = $success_response->message->getArgs($obj->ns_uri); } if ($args === null || Auth_OpenID::isFailure($args)) { return null; } foreach ($Auth_OpenID_sreg_data_fields as $field_name => $desc) { if (in_array($field_name, array_keys($args))) { $obj->data[$field_name] = $args[$field_name]; } } return $obj; } function getExtensionArgs() { return $this->data; } function get($field_name, $default=null) { if (!Auth_OpenID_checkFieldName($field_name)) { return null; } return Auth_OpenID::arrayGet($this->data, $field_name, $default); } function contents() { return $this->data; } }     import('core.lib.openid.auth.openid.Discover'); define('Auth_OpenID___TLDs', '/\.(ac|ad|ae|aero|af|ag|ai|al|am|an|ao|aq|ar|arpa|as|asia' . '|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|biz|bj|bm|bn|bo|br' . '|bs|bt|bv|bw|by|bz|ca|cat|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co' . '|com|coop|cr|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|ec|edu|ee|eg' . '|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl' . '|gm|gn|gov|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie' . '|il|im|in|info|int|io|iq|ir|is|it|je|jm|jo|jobs|jp|ke|kg|kh' . '|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly' . '|ma|mc|md|me|mg|mh|mil|mk|ml|mm|mn|mo|mobi|mp|mq|mr|ms|mt' . '|mu|museum|mv|mw|mx|my|mz|na|name|nc|ne|net|nf|ng|ni|nl|no' . '|np|nr|nu|nz|om|org|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|pro|ps|pt' . '|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl' . '|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tel|tf|tg|th|tj|tk|tl|tm' . '|tn|to|tp|tr|travel|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve' . '|vg|vi|vn|vu|wf|ws|xn--0zwm56d|xn--11b5bs3a9aj6g' . '|xn--80akhbyknj4f|xn--9t4b11yi5a|xn--deba0ad|xn--g6w251d' . '|xn--hgbk6aj7f53bba|xn--hlcj6aya9esc7a|xn--jxalpdlp' . '|xn--kgbechtv|xn--zckzah|ye|yt|yu|za|zm|zw)\.?$/'); define('Auth_OpenID___HostSegmentRe', "/^(?:[-a-zA-Z0-9!$&'\\(\\)\\*+,;=._~]|%[a-zA-Z0-9]{2})*$/"); class Auth_OpenID_TrustRoot { function buildDiscoveryURL($realm) { $parsed = Auth_OpenID_TrustRoot::_parse($realm); if ($parsed === false) { return false; } if ($parsed['wildcard']) { if ($parsed['host'][0] != '.') { return false; } $www_domain = 'www' . $parsed['host']; return sprintf('%s://%s%s', $parsed['scheme'], $www_domain, $parsed['path']); } else { return $parsed['unparsed']; } } function _parse($trust_root) { $trust_root = Auth_OpenID_urinorm($trust_root); if ($trust_root === null) { return false; } if (preg_match("/:\/\/[^:]+(:\d+){2,}(\/|$)/", $trust_root)) { return false; } $parts = @parse_url($trust_root); if ($parts === false) { return false; } $required_parts = array('scheme', 'host'); $forbidden_parts = array('user', 'pass', 'fragment'); $keys = array_keys($parts); if (array_intersect($keys, $required_parts) != $required_parts) { return false; } if (array_intersect($keys, $forbidden_parts) != array()) { return false; } if (!preg_match(Auth_OpenID___HostSegmentRe, $parts['host'])) { return false; } $scheme = strtolower($parts['scheme']); $allowed_schemes = array('http', 'https'); if (!in_array($scheme, $allowed_schemes)) { return false; } $parts['scheme'] = $scheme; $host = strtolower($parts['host']); $hostparts = explode('*', $host); switch (count($hostparts)) { case 1: $parts['wildcard'] = false; break; case 2: if ($hostparts[0] || ($hostparts[1] && substr($hostparts[1], 0, 1) != '.')) { return false; } $host = $hostparts[1]; $parts['wildcard'] = true; break; default: return false; } if (strpos($host, ':') !== false) { return false; } $parts['host'] = $host; if (isset($parts['path'])) { $path = strtolower($parts['path']); if (substr($path, 0, 1) != '/') { return false; } } else { $path = '/'; } $parts['path'] = $path; if (!isset($parts['port'])) { $parts['port'] = false; } $parts['unparsed'] = $trust_root; return $parts; } function isSane($trust_root) { $parts = Auth_OpenID_TrustRoot::_parse($trust_root); if ($parts === false) { return false; } if ($parts['host'] == 'localhost') { return true; } $host_parts = explode('.', $parts['host']); if ($parts['wildcard']) { array_shift($host_parts); } if ($host_parts && !$host_parts[count($host_parts) - 1]) { array_pop($host_parts); } if (!$host_parts) { return false; } if (in_array('', $host_parts, true)) { return false; } preg_match(Auth_OpenID___TLDs, $parts['host'], $matches); if (!$matches) { return false; } $tld = $matches[1]; if (count($host_parts) == 1) { return false; } if ($parts['wildcard']) { $second_level = $host_parts[count($host_parts) - 2]; if (strlen($tld) == 2 && strlen($second_level) <= 3) { return count($host_parts) > 2; } } return true; } function match($trust_root, $url) { $trust_root_parsed = Auth_OpenID_TrustRoot::_parse($trust_root); $url_parsed = Auth_OpenID_TrustRoot::_parse($url); if (!$trust_root_parsed || !$url_parsed) { return false; } if ($url_parsed['wildcard']) { return false; } if ($trust_root_parsed['wildcard']) { $host_tail = $trust_root_parsed['host']; $host = $url_parsed['host']; if ($host_tail && substr($host, -(strlen($host_tail))) != $host_tail && substr($host_tail, 1) != $host) { return false; } } else { if ($trust_root_parsed['host'] != $url_parsed['host']) { return false; } } $base_path = $trust_root_parsed['path']; $path = $url_parsed['path']; if (!isset($trust_root_parsed['query'])) { if ($base_path != $path) { if (substr($path, 0, strlen($base_path)) != $base_path) { return false; } if (substr($base_path, strlen($base_path) - 1, 1) != '/' && substr($path, strlen($base_path), 1) != '/') { return false; } } } else { $base_query = $trust_root_parsed['query']; $query = @$url_parsed['query']; $qplus = substr($query, 0, strlen($base_query) + 1); $bqplus = $base_query . '&'; if ($base_path != $path || ($base_query != $query && $qplus != $bqplus)) { return false; } } return ($trust_root_parsed['scheme'] == $url_parsed['scheme'] && $url_parsed['port'] === $trust_root_parsed['port']); } } function filter_extractReturnURL(&$endpoint) { if ($endpoint->matchTypes(array(Auth_OpenID_RP_RETURN_TO_URL_TYPE))) { return $endpoint; } else { return null; } } function &Auth_OpenID_extractReturnURL(&$endpoint_list) { $result = array(); foreach ($endpoint_list as $endpoint) { if (filter_extractReturnURL($endpoint)) { $result[] = $endpoint; } } return $result; } function Auth_OpenID_returnToMatches($allowed_return_to_urls, $return_to) { foreach ($allowed_return_to_urls as $allowed_return_to) { $return_realm = Auth_OpenID_TrustRoot::_parse($allowed_return_to); if ( ($return_realm !== false) && (!$return_realm['wildcard']) && (Auth_OpenID_TrustRoot::match($allowed_return_to, $return_to))) { return true; } } return false; } function Auth_OpenID_getAllowedReturnURLs($relying_party_url, &$fetcher, $discover_function=null) { if ($discover_function === null) { $discover_function = array('Auth_Yadis_Yadis', 'discover'); } $xrds_parse_cb = array('Auth_OpenID_ServiceEndpoint', 'fromXRDS'); list($rp_url_after_redirects, $endpoints) = Auth_Yadis_getServiceEndpoints($relying_party_url, $xrds_parse_cb, $discover_function, $fetcher); if ($rp_url_after_redirects != $relying_party_url) { return false; } call_user_func_array($discover_function, array($relying_party_url, $fetcher)); $return_to_urls = array(); $matching_endpoints = Auth_OpenID_extractReturnURL($endpoints); foreach ($matching_endpoints as $e) { $return_to_urls[] = $e->server_url; } return $return_to_urls; } function Auth_OpenID_verifyReturnTo($realm_str, $return_to, &$fetcher, $_vrfy='Auth_OpenID_getAllowedReturnURLs') { $disco_url = Auth_OpenID_TrustRoot::buildDiscoveryURL($realm_str); if ($disco_url === false) { return false; } $allowable_urls = call_user_func_array($_vrfy, array($disco_url, &$fetcher)); if ($allowable_urls === false) { return false; } if (Auth_OpenID_returnToMatches($allowable_urls, $return_to)) { return true; } else { return false; } }    import('core.lib.openid.auth.yadis.Misc'); function Auth_OpenID_getURIPattern() { return '&^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?&'; } function Auth_OpenID_getAuthorityPattern() { return '/^([^@]*@)?([^:]*)(:.*)?/'; } function Auth_OpenID_getEncodedPattern() { return '/%([0-9A-Fa-f]{2})/'; } function Auth_OpenID_getURLIllegalCharRE() { return "/([^-A-Za-z0-9:\/\?#\[\]@\!\$&'\(\)\*\+,;=\._~\%])/"; } function Auth_OpenID_getUnreserved() { $_unreserved = array(); for ($i = 0; $i < 256; $i++) { $_unreserved[$i] = false; } for ($i = ord('A'); $i <= ord('Z'); $i++) { $_unreserved[$i] = true; } for ($i = ord('0'); $i <= ord('9'); $i++) { $_unreserved[$i] = true; } for ($i = ord('a'); $i <= ord('z'); $i++) { $_unreserved[$i] = true; } $_unreserved[ord('-')] = true; $_unreserved[ord('.')] = true; $_unreserved[ord('_')] = true; $_unreserved[ord('~')] = true; return $_unreserved; } function Auth_OpenID_getEscapeRE() { $parts = array(); foreach (array_merge(Auth_Yadis_getUCSChars(), Auth_Yadis_getIPrivateChars()) as $pair) { list($m, $n) = $pair; $parts[] = sprintf("%s-%s", chr($m), chr($n)); } return sprintf('[%s]', implode('', $parts)); } function Auth_OpenID_pct_encoded_replace_unreserved($mo) { $_unreserved = Auth_OpenID_getUnreserved(); $i = intval($mo[1], 16); if ($_unreserved[$i]) { return chr($i); } else { return strtoupper($mo[0]); } return $mo[0]; } function Auth_OpenID_pct_encoded_replace($mo) { return chr(intval($mo[1], 16)); } function Auth_OpenID_remove_dot_segments($path) { $result_segments = array(); while ($path) { if (Auth_Yadis_startswith($path, '../')) { $path = substr($path, 3); } else if (Auth_Yadis_startswith($path, './')) { $path = substr($path, 2); } else if (Auth_Yadis_startswith($path, '/./')) { $path = substr($path, 2); } else if ($path == '/.') { $path = '/'; } else if (Auth_Yadis_startswith($path, '/../')) { $path = substr($path, 3); if ($result_segments) { array_pop($result_segments); } } else if ($path == '/..') { $path = '/'; if ($result_segments) { array_pop($result_segments); } } else if (($path == '..') || ($path == '.')) { $path = ''; } else { $i = 0; if ($path[0] == '/') { $i = 1; } $i = strpos($path, '/', $i); if ($i === false) { $i = strlen($path); } $result_segments[] = substr($path, 0, $i); $path = substr($path, $i); } } return implode('', $result_segments); } function Auth_OpenID_urinorm($uri) { $uri_matches = array(); preg_match(Auth_OpenID_getURIPattern(), $uri, $uri_matches); if (count($uri_matches) < 9) { for ($i = count($uri_matches); $i <= 9; $i++) { $uri_matches[] = ''; } } $illegal_matches = array(); preg_match(Auth_OpenID_getURLIllegalCharRE(), $uri, $illegal_matches); if ($illegal_matches) { return null; } $scheme = $uri_matches[2]; if ($scheme) { $scheme = strtolower($scheme); } $scheme = $uri_matches[2]; if ($scheme === '') { return null; } $scheme = strtolower($scheme); if (!in_array($scheme, array('http', 'https'))) { return null; } $authority = $uri_matches[4]; if ($authority === '') { return null; } $authority_matches = array(); preg_match(Auth_OpenID_getAuthorityPattern(), $authority, $authority_matches); if (count($authority_matches) === 0) { return null; } if (count($authority_matches) < 4) { for ($i = count($authority_matches); $i <= 4; $i++) { $authority_matches[] = ''; } } list($_whole, $userinfo, $host, $port) = $authority_matches; if ($userinfo === null) { $userinfo = ''; } if (strpos($host, '%') !== -1) { $host = strtolower($host); $host = preg_replace_callback( Auth_OpenID_getEncodedPattern(), 'Auth_OpenID_pct_encoded_replace', $host); } else { $host = strtolower($host); } if ($port) { if (($port == ':') || ($scheme == 'http' && $port == ':80') || ($scheme == 'https' && $port == ':443')) { $port = ''; } } else { $port = ''; } $authority = $userinfo . $host . $port; $path = $uri_matches[5]; $path = preg_replace_callback( Auth_OpenID_getEncodedPattern(), 'Auth_OpenID_pct_encoded_replace_unreserved', $path); $path = Auth_OpenID_remove_dot_segments($path); if (!$path) { $path = '/'; } $query = $uri_matches[6]; if ($query === null) { $query = ''; } $fragment = $uri_matches[8]; if ($fragment === null) { $fragment = ''; } return $scheme . '://' . $authority . $path . $query . $fragment; }     define('Auth_OpenID_VERSION', '2.1.1'); global $abs, $ds; import('core.lib.openid.auth.yadis.PlainHTTPFetcher'); import('core.lib.openid.auth.yadis.ParanoidHTTPFetcher'); import('core.lib.openid.auth.openid.BigMath'); import('core.lib.openid.auth.openid.URINorm'); define('Auth_OpenID_LOCAL_ERROR', 'local_error'); define('Auth_OpenID_REMOTE_ERROR', 'remote_error'); define('Auth_OpenID_REMOTE_OK', 'remote_ok'); define('Auth_OpenID_REDIRECT', 'redirect'); define('Auth_OpenID_DO_AUTH', 'do_auth'); define('Auth_OpenID_DO_ABOUT', 'do_about'); define('Auth_OpenID_letters', "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"); define('Auth_OpenID_digits', "0123456789"); define('Auth_OpenID_punct', "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"); if (Auth_OpenID_getMathLib() === null) { Auth_OpenID_setNoMathSupport(); } class Auth_OpenID { function isFailure($thing) { return is_a($thing, 'Auth_OpenID_FailureResponse'); } function getQuery($query_str=null) { $data = array(); if ($query_str !== null) { $data = Auth_OpenID::params_from_string($query_str); } else if (!array_key_exists('REQUEST_METHOD', $_SERVER)) { } else { $data = Auth_OpenID::params_from_string($_SERVER['QUERY_STRING']); if ($_SERVER['REQUEST_METHOD'] == 'POST') { $str = file_get_contents('php://input'); if ($str === false) { $post = array(); } else { $post = Auth_OpenID::params_from_string($str); } $data = array_merge($data, $post); } } return $data; } function params_from_string($str) { $chunks = explode("&", $str); $data = array(); foreach ($chunks as $chunk) { $parts = explode("=", $chunk, 2); if (count($parts) != 2) { continue; } list($k, $v) = $parts; $data[$k] = urldecode($v); } return $data; } function ensureDir($dir_name) { if (is_dir($dir_name) || @mkdir($dir_name)) { return true; } else { $parent_dir = dirname($dir_name); if ($parent_dir == $dir_name) { return true; } return (Auth_OpenID::ensureDir($parent_dir) && @mkdir($dir_name)); } } function addPrefix($values, $prefix) { $new_values = array(); foreach ($values as $s) { $new_values[] = $prefix . $s; } return $new_values; } function arrayGet($arr, $key, $fallback = null) { if (is_array($arr)) { if (array_key_exists($key, $arr)) { return $arr[$key]; } else { return $fallback; } } else { trigger_error("Auth_OpenID::arrayGet (key = ".$key.") expected " . "array as first parameter, got " . gettype($arr), E_USER_WARNING); return false; } } function parse_str($query) { if ($query === null) { return null; } $parts = explode('&', $query); $new_parts = array(); for ($i = 0; $i < count($parts); $i++) { $pair = explode('=', $parts[$i]); if (count($pair) != 2) { continue; } list($key, $value) = $pair; $new_parts[$key] = urldecode($value); } return $new_parts; } function httpBuildQuery($data) { $pairs = array(); foreach ($data as $key => $value) { if (is_array($value)) { $pairs[] = urlencode($value[0])."=".urlencode($value[1]); } else { $pairs[] = urlencode($key)."=".urlencode($value); } } return implode("&", $pairs); } function appendArgs($url, $args) { if (count($args) == 0) { return $url; } if (array_key_exists(0, $args) && is_array($args[0])) { } else { $keys = array_keys($args); sort($keys); $new_args = array(); foreach ($keys as $key) { $new_args[] = array($key, $args[$key]); } $args = $new_args; } $sep = '?'; if (strpos($url, '?') !== false) { $sep = '&'; } return $url . $sep . Auth_OpenID::httpBuildQuery($args); } function urlunparse($scheme, $host, $port = null, $path = '/', $query = '', $fragment = '') { if (!$scheme) { $scheme = 'http'; } if (!$host) { return false; } if (!$path) { $path = ''; } $result = $scheme . "://" . $host; if ($port) { $result .= ":" . $port; } $result .= $path; if ($query) { $result .= "?" . $query; } if ($fragment) { $result .= "#" . $fragment; } return $result; } function normalizeUrl($url) { @$parsed = parse_url($url); if (!$parsed) { return null; } if (isset($parsed['scheme']) && isset($parsed['host'])) { $scheme = strtolower($parsed['scheme']); if (!in_array($scheme, array('http', 'https'))) { return null; } } else { $url = 'http://' . $url; } $normalized = Auth_OpenID_urinorm($url); if ($normalized === null) { return null; } list($defragged, $frag) = Auth_OpenID::urldefrag($normalized); return $defragged; } function intval($value) { $re = "/^\\d+$/"; if (!preg_match($re, $value)) { return false; } return intval($value); } function bytes($str) { return strlen(bin2hex($str)) / 2; } function toBytes($str) { $hex = bin2hex($str); if (!$hex) { return array(); } $b = array(); for ($i = 0; $i < strlen($hex); $i += 2) { $b[] = chr(base_convert(substr($hex, $i, 2), 16, 10)); } return $b; } function urldefrag($url) { $parts = explode("#", $url, 2); if (count($parts) == 1) { return array($parts[0], ""); } else { return $parts; } } function filter($callback, &$sequence) { $result = array(); foreach ($sequence as $item) { if (call_user_func_array($callback, array($item))) { $result[] = $item; } } return $result; } function update(&$dest, &$src) { foreach ($src as $k => $v) { $dest[$k] = $v; } } function log($format_string) { $args = func_get_args(); $message = call_user_func_array('sprintf', $args); error_log($message); } function autoSubmitHTML($form, $title="OpenId transaction in progress") { return("<html>". "<head><title>". $title . "</title></head>". "<body onload='document.forms[0].submit();'>". $form . "<script>". "var elements = document.forms[0].elements;". "for (var i = 0; i < elements.length; i++) {". "  elements[i].style.display = \"none\";". "}". "</script>". "</body>". "</html>"); } }     import('core.lib.openid.auth.OpenID'); define('Auth_OpenID_FETCHER_MAX_RESPONSE_KB', 1024); define('Auth_OpenID_USER_AGENT', 'php-openid/'.Auth_OpenID_VERSION.' (php/'.phpversion().')'); class Auth_Yadis_HTTPResponse { function Auth_Yadis_HTTPResponse($final_url = null, $status = null, $headers = null, $body = null) { $this->final_url = $final_url; $this->status = $status; $this->headers = $headers; $this->body = $body; } } class Auth_Yadis_HTTPFetcher { var $timeout = 20; function canFetchURL($url) { if ($this->isHTTPS($url) && !$this->supportsSSL()) { Auth_OpenID::log("HTTPS URL unsupported fetching %s", $url); return false; } if (!$this->allowedURL($url)) { Auth_OpenID::log("URL fetching not allowed for '%s'", $url); return false; } return true; } function allowedURL($url) { return $this->URLHasAllowedScheme($url); } function supportsSSL() { trigger_error("not implemented", E_USER_ERROR); } function isHTTPS($url) { return (bool)preg_match('/^https:\/\//i', $url); } function URLHasAllowedScheme($url) { return (bool)preg_match('/^https?:\/\//i', $url); } function _findRedirect($headers) { foreach ($headers as $line) { if (strpos(strtolower($line), "location: ") === 0) { $parts = explode(" ", $line, 2); return $parts[1]; } } return null; } function get($url, $headers) { trigger_error("not implemented", E_USER_ERROR); } }    class Auth_Yadis_PHPSession { function set($name, $value) { $_SESSION[$name] = $value; } function get($name, $default=null) { if (array_key_exists($name, $_SESSION)) { return $_SESSION[$name]; } else { return $default; } } function del($name) { unset($_SESSION[$name]); } function contents() { return $_SESSION; } } class Auth_Yadis_SessionLoader { function check($data) { return true; } function fromSession($data) { if (!$data) { return null; } $required = $this->requiredKeys(); foreach ($required as $k) { if (!array_key_exists($k, $data)) { return null; } } if (!$this->check($data)) { return null; } $data = array_merge($data, $this->prepareForLoad($data)); $obj = $this->newObject($data); if (!$obj) { return null; } foreach ($required as $k) { $obj->$k = $data[$k]; } return $obj; } function prepareForLoad($data) { return array(); } function newObject($data) { return null; } function toSession($obj) { $data = array(); foreach ($obj as $k => $v) { $data[$k] = $v; } $extra = $this->prepareForSave($obj); if ($extra && is_array($extra)) { foreach ($extra as $k => $v) { $data[$k] = $v; } } return $data; } function prepareForSave($obj) { return array(); } } class Auth_OpenID_ServiceEndpointLoader extends Auth_Yadis_SessionLoader { function newObject($data) { return new Auth_OpenID_ServiceEndpoint(); } function requiredKeys() { $obj = new Auth_OpenID_ServiceEndpoint(); $data = array(); foreach ($obj as $k => $v) { $data[] = $k; } return $data; } function check($data) { return is_array($data['type_uris']); } } class Auth_Yadis_ManagerLoader extends Auth_Yadis_SessionLoader { function requiredKeys() { return array('starting_url', 'yadis_url', 'services', 'session_key', '_current', 'stale'); } function newObject($data) { return new Auth_Yadis_Manager($data['starting_url'], $data['yadis_url'], $data['services'], $data['session_key']); } function check($data) { return is_array($data['services']); } function prepareForLoad($data) { $loader = new Auth_OpenID_ServiceEndpointLoader(); $services = array(); foreach ($data['services'] as $s) { $services[] = $loader->fromSession($s); } return array('services' => $services); } function prepareForSave($obj) { $loader = new Auth_OpenID_ServiceEndpointLoader(); $services = array(); foreach ($obj->services as $s) { $services[] = $loader->toSession($s); } return array('services' => $services); } } class Auth_Yadis_Manager { function Auth_Yadis_Manager($starting_url, $yadis_url, $services, $session_key) { $this->starting_url = $starting_url; $this->yadis_url = $yadis_url; $this->services = $services; $this->session_key = $session_key; $this->_current = null; $this->stale = false; } function length() { return count($this->services); } function nextService() { if ($this->services) { $this->_current = array_shift($this->services); } else { $this->_current = null; } return $this->_current; } function current() { return $this->_current; } function forURL($url) { return in_array($url, array($this->starting_url, $this->yadis_url)); } function started() { return $this->_current !== null; } } class Auth_Yadis_Discovery { var $DEFAULT_SUFFIX = 'auth'; var $PREFIX = '_yadis_services_'; function Auth_Yadis_Discovery(&$session, $url, $session_key_suffix = null) { $this->session =& $session; $this->url = $url; if ($session_key_suffix === null) { $session_key_suffix = $this->DEFAULT_SUFFIX; } $this->session_key_suffix = $session_key_suffix; $this->session_key = $this->PREFIX . $this->session_key_suffix; } function getNextService($discover_cb, &$fetcher) { $manager = $this->getManager(); if (!$manager || (!$manager->services)) { $this->destroyManager(); list($yadis_url, $services) = call_user_func($discover_cb, $this->url, $fetcher); $manager = $this->createManager($services, $yadis_url); } if ($manager) { $loader = new Auth_Yadis_ManagerLoader(); $service = $manager->nextService(); $this->session->set($this->session_key, serialize($loader->toSession($manager))); } else { $service = null; } return $service; } function cleanup($force=false) { $manager = $this->getManager($force); if ($manager) { $service = $manager->current(); $this->destroyManager($force); } else { $service = null; } return $service; } function getSessionKey() { return $this->PREFIX . $this->session_key_suffix; } function &getManager($force=false) { $manager_str = $this->session->get($this->getSessionKey()); $manager = null; if ($manager_str !== null) { $loader = new Auth_Yadis_ManagerLoader(); $manager = $loader->fromSession(unserialize($manager_str)); } if ($manager && ($manager->forURL($this->url) || $force)) { return $manager; } else { $unused = null; return $unused; } } function &createManager($services, $yadis_url = null) { $key = $this->getSessionKey(); if ($this->getManager()) { return $this->getManager(); } if ($services) { $loader = new Auth_Yadis_ManagerLoader(); $manager = new Auth_Yadis_Manager($this->url, $yadis_url, $services, $key); $this->session->set($this->session_key, serialize($loader->toSession($manager))); return $manager; } else { $unused = null; return $unused; } } function destroyManager($force=false) { if ($this->getManager($force) !== null) { $key = $this->getSessionKey(); $this->session->del($key); } } }    function Auth_Yadis_getUCSChars() { return array( array(0xA0, 0xD7FF), array(0xF900, 0xFDCF), array(0xFDF0, 0xFFEF), array(0x10000, 0x1FFFD), array(0x20000, 0x2FFFD), array(0x30000, 0x3FFFD), array(0x40000, 0x4FFFD), array(0x50000, 0x5FFFD), array(0x60000, 0x6FFFD), array(0x70000, 0x7FFFD), array(0x80000, 0x8FFFD), array(0x90000, 0x9FFFD), array(0xA0000, 0xAFFFD), array(0xB0000, 0xBFFFD), array(0xC0000, 0xCFFFD), array(0xD0000, 0xDFFFD), array(0xE1000, 0xEFFFD) ); } function Auth_Yadis_getIPrivateChars() { return array( array(0xE000, 0xF8FF), array(0xF0000, 0xFFFFD), array(0x100000, 0x10FFFD) ); } function Auth_Yadis_pct_escape_unicode($char_match) { $c = $char_match[0]; $result = ""; for ($i = 0; $i < strlen($c); $i++) { $result .= "%".sprintf("%X", ord($c[$i])); } return $result; } function Auth_Yadis_startswith($s, $stuff) { return strpos($s, $stuff) === 0; }    import('core.lib.openid.auth.yadis.HTTPFetcher'); import('core.lib.openid.auth.OpenID'); class Auth_Yadis_ParanoidHTTPFetcher extends Auth_Yadis_HTTPFetcher { function Auth_Yadis_ParanoidHTTPFetcher() { $this->reset(); } function reset() { $this->headers = array(); $this->data = ""; } function _writeHeader($ch, $header) { array_push($this->headers, rtrim($header)); return strlen($header); } function _writeData($ch, $data) { if (strlen($this->data) > 1024*Auth_OpenID_FETCHER_MAX_RESPONSE_KB) { return 0; } else { $this->data .= $data; return strlen($data); } } function supportsSSL() { $v = curl_version(); if(is_array($v)) { return in_array('https', $v['protocols']); } elseif (is_string($v)) { return preg_match('/OpenSSL/i', $v); } else { return 0; } } function get($url, $extra_headers = null) { if (!$this->canFetchURL($url)) { return null; } $stop = time() + $this->timeout; $off = $this->timeout; $redir = true; while ($redir && ($off > 0)) { $this->reset(); $c = curl_init(); if ($c === false) { Auth_OpenID::log( "curl_init returned false; could not " . "initialize for URL '%s'", $url); return null; } if (defined('CURLOPT_NOSIGNAL')) { curl_setopt($c, CURLOPT_NOSIGNAL, true); } if (!$this->allowedURL($url)) { Auth_OpenID::log("Fetching URL not allowed: %s", $url); return null; } curl_setopt($c, CURLOPT_WRITEFUNCTION, array(&$this, "_writeData")); curl_setopt($c, CURLOPT_HEADERFUNCTION, array(&$this, "_writeHeader")); if ($extra_headers) { curl_setopt($c, CURLOPT_HTTPHEADER, $extra_headers); } $cv = curl_version(); if(is_array($cv)) { $curl_user_agent = 'curl/'.$cv['version']; } else { $curl_user_agent = $cv; } curl_setopt($c, CURLOPT_USERAGENT, Auth_OpenID_USER_AGENT.' '.$curl_user_agent); curl_setopt($c, CURLOPT_TIMEOUT, $off); curl_setopt($c, CURLOPT_URL, $url); curl_setopt($c, CURLOPT_RANGE, "0-".(1024 * Auth_OpenID_FETCHER_MAX_RESPONSE_KB)); curl_exec($c); $code = curl_getinfo($c, CURLINFO_HTTP_CODE); $body = $this->data; $headers = $this->headers; if (!$code) { Auth_OpenID::log("Got no response code when fetching %s", $url); Auth_OpenID::log("CURL error (%s): %s", curl_errno($c), curl_error($c)); return null; } if (in_array($code, array(301, 302, 303, 307))) { $url = $this->_findRedirect($headers); $redir = true; } else { $redir = false; curl_close($c); $new_headers = array(); foreach ($headers as $header) { if (strpos($header, ': ')) { list($name, $value) = explode(': ', $header, 2); $new_headers[$name] = $value; } } Auth_OpenID::log( "Successfully fetched '%s': GET response code %s", $url, $code); return new Auth_Yadis_HTTPResponse($url, $code, $new_headers, $body); } $off = $stop - time(); } return null; } function post($url, $body, $extra_headers = null) { if (!$this->canFetchURL($url)) { return null; } $this->reset(); $c = curl_init(); if (defined('CURLOPT_NOSIGNAL')) { curl_setopt($c, CURLOPT_NOSIGNAL, true); } curl_setopt($c, CURLOPT_POST, true); curl_setopt($c, CURLOPT_POSTFIELDS, $body); curl_setopt($c, CURLOPT_TIMEOUT, $this->timeout); curl_setopt($c, CURLOPT_URL, $url); curl_setopt($c, CURLOPT_WRITEFUNCTION, array(&$this, "_writeData")); curl_exec($c); $code = curl_getinfo($c, CURLINFO_HTTP_CODE); if (!$code) { Auth_OpenID::log("Got no response code when fetching %s", $url); return null; } $body = $this->data; curl_close($c); $new_headers = $extra_headers; foreach ($this->headers as $header) { if (strpos($header, ': ')) { list($name, $value) = explode(': ', $header, 2); $new_headers[$name] = $value; } } Auth_OpenID::log("Successfully fetched '%s': POST response code %s", $url, $code); return new Auth_Yadis_HTTPResponse($url, $code, $new_headers, $body); } }    class Auth_Yadis_ParseHTML { var $_re_flags = "si"; var $_removed_re = "<!--.*?-->|<!\[CDATA\[.*?\]\]>|<script\b(?!:)[^>]*>.*?<\/script>"; var $_tag_expr = "<%s%s(?:\s.*?)?%s>"; var $_attr_find = '\b([-\w]+)=(".*?"|\'.*?\'|.+?)[\/\s>]'; function Auth_Yadis_ParseHTML() { $this->_attr_find = sprintf("/%s/%s", $this->_attr_find, $this->_re_flags); $this->_removed_re = sprintf("/%s/%s", $this->_removed_re, $this->_re_flags); $this->_entity_replacements = array( 'amp' => '&', 'lt' => '<', 'gt' => '>', 'quot' => '"' ); $this->_ent_replace = sprintf("&(%s);", implode("|", $this->_entity_replacements)); } function replaceEntities($str) { foreach ($this->_entity_replacements as $old => $new) { $str = preg_replace(sprintf("/&%s;/", $old), $new, $str); } $str = preg_replace('~&#x([0-9a-f]+);~ei', 'chr(hexdec("\\1"))', $str); $str = preg_replace('~&#([0-9]+);~e', 'chr(\\1)', $str); return $str; } function removeQuotes($str) { $matches = array(); $double = '/^"(.*)"$/'; $single = "/^\'(.*)\'$/"; if (preg_match($double, $str, $matches)) { return $matches[1]; } else if (preg_match($single, $str, $matches)) { return $matches[1]; } else { return $str; } } function tagPattern($tag_names, $close, $self_close) { if (is_array($tag_names)) { $tag_names = '(?:'.implode('|',$tag_names).')'; } if ($close) { $close = '\/' . (($close == 1)? '' : '?'); } else { $close = ''; } if ($self_close) { $self_close = '(?:\/\s*)' . (($self_close == 1)? '' : '?'); } else { $self_close = ''; } $expr = sprintf($this->_tag_expr, $close, $tag_names, $self_close); return sprintf("/%s/%s", $expr, $this->_re_flags); } function getMetaTags($html_string) { $html_string = preg_replace($this->_removed_re, "", $html_string); $key_tags = array($this->tagPattern('html', false, false), $this->tagPattern('head', false, false), $this->tagPattern('head', true, false), $this->tagPattern('html', true, false), $this->tagPattern(array( 'body', 'frameset', 'frame', 'p', 'div', 'table','span','a'), 'maybe', 'maybe')); $key_tags_pos = array(); foreach ($key_tags as $pat) { $matches = array(); preg_match($pat, $html_string, $matches, PREG_OFFSET_CAPTURE); if($matches) { $key_tags_pos[] = $matches[0][1]; } else { $key_tags_pos[] = null; } } if (is_null($key_tags_pos[1])) { return array(); } if (is_null($key_tags_pos[2])) { $key_tags_pos[2] = strlen($html_string); } foreach (array($key_tags_pos[3], $key_tags_pos[4]) as $pos) { if (!is_null($pos) && $pos < $key_tags_pos[2]) { $key_tags_pos[2] = $pos; } } if ($key_tags_pos[1] > $key_tags_pos[2]) { return array(); } if (!is_null($key_tags_pos[0]) && $key_tags_pos[1] < $key_tags_pos[0]) { return array(); } $html_string = substr($html_string, $key_tags_pos[1], ($key_tags_pos[2]-$key_tags_pos[1])); $link_data = array(); $link_matches = array(); if (!preg_match_all($this->tagPattern('meta', false, 'maybe'), $html_string, $link_matches)) { return array(); } foreach ($link_matches[0] as $link) { $attr_matches = array(); preg_match_all($this->_attr_find, $link, $attr_matches); $link_attrs = array(); foreach ($attr_matches[0] as $index => $full_match) { $name = $attr_matches[1][$index]; $value = $this->replaceEntities( $this->removeQuotes($attr_matches[2][$index])); $link_attrs[strtolower($name)] = $value; } $link_data[] = $link_attrs; } return $link_data; } function getHTTPEquiv($html_string) { $meta_tags = $this->getMetaTags($html_string); if ($meta_tags) { foreach ($meta_tags as $tag) { if (array_key_exists('http-equiv', $tag) && (in_array(strtolower($tag['http-equiv']), array('x-xrds-location', 'x-yadis-location'))) && array_key_exists('content', $tag)) { return $tag['content']; } } } return null; } }    import('core.lib.openid.auth.yadis.HTTPFetcher'); class Auth_Yadis_PlainHTTPFetcher extends Auth_Yadis_HTTPFetcher { function supportsSSL() { return function_exists('openssl_open'); } function get($url, $extra_headers = null) { if (!$this->canFetchURL($url)) { return null; } $redir = true; $stop = time() + $this->timeout; $off = $this->timeout; while ($redir && ($off > 0)) { $parts = parse_url($url); $specify_port = true; if (!array_key_exists('port', $parts)) { $specify_port = false; if ($parts['scheme'] == 'http') { $parts['port'] = 80; } elseif ($parts['scheme'] == 'https') { $parts['port'] = 443; } else { return null; } } if (!array_key_exists('path', $parts)) { $parts['path'] = '/'; } $host = $parts['host']; if ($parts['scheme'] == 'https') { $host = 'ssl://' . $host; } $user_agent = Auth_OpenID_USER_AGENT; $headers = array( "GET ".$parts['path']. (array_key_exists('query', $parts) ? "?".$parts['query'] : ""). " HTTP/1.0", "User-Agent: $user_agent", "Host: ".$parts['host']. ($specify_port ? ":".$parts['port'] : ""), "Range: 0-". (1024*Auth_OpenID_FETCHER_MAX_RESPONSE_KB), "Port: ".$parts['port']); $errno = 0; $errstr = ''; if ($extra_headers) { foreach ($extra_headers as $h) { $headers[] = $h; } } @$sock = fsockopen($host, $parts['port'], $errno, $errstr, $this->timeout); if ($sock === false) { return false; } stream_set_timeout($sock, $this->timeout); fputs($sock, implode("\r\n", $headers) . "\r\n\r\n"); $data = ""; $kilobytes = 0; while (!feof($sock) && $kilobytes < Auth_OpenID_FETCHER_MAX_RESPONSE_KB ) { $data .= fgets($sock, 1024); $kilobytes += 1; } fclose($sock); list($headers, $body) = explode("\r\n\r\n", $data, 2); $headers = explode("\r\n", $headers); $http_code = explode(" ", $headers[0]); $code = $http_code[1]; if (in_array($code, array('301', '302'))) { $url = $this->_findRedirect($headers); $redir = true; } else { $redir = false; } $off = $stop - time(); } $new_headers = array(); foreach ($headers as $header) { if (preg_match("/:/", $header)) { $parts = explode(": ", $header, 2); if (count($parts) == 2) { list($name, $value) = $parts; $new_headers[$name] = $value; } } } return new Auth_Yadis_HTTPResponse($url, $code, $new_headers, $body); } function post($url, $body, $extra_headers = null) { if (!$this->canFetchURL($url)) { return null; } $parts = parse_url($url); $headers = array(); $post_path = $parts['path']; if (isset($parts['query'])) { $post_path .= '?' . $parts['query']; } $headers[] = "POST ".$post_path." HTTP/1.0"; $headers[] = "Host: " . $parts['host']; $headers[] = "Content-type: application/x-www-form-urlencoded"; $headers[] = "Content-length: " . strval(strlen($body)); if ($extra_headers && is_array($extra_headers)) { $headers = array_merge($headers, $extra_headers); } $all_headers = implode("\r\n", $headers); $request = $all_headers . "\r\n\r\n" . $body; if (!array_key_exists('port', $parts)) { if ($parts['scheme'] == 'http') { $parts['port'] = 80; } elseif ($parts['scheme'] == 'https') { $parts['port'] = 443; } else { return null; } } if ($parts['scheme'] == 'https') { $parts['host'] = sprintf("ssl://%s", $parts['host']); } $errno = 0; $errstr = ''; $sock = fsockopen($parts['host'], $parts['port'], $errno, $errstr, $this->timeout); if ($sock === false) { return null; } stream_set_timeout($sock, $this->timeout); fputs($sock, $request); $response = ""; while (!feof($sock)) { if ($data = fgets($sock, 128)) { $response .= $data; } else { break; } } list($headers, $response_body) = explode("\r\n\r\n", $response, 2); $headers = explode("\r\n", $headers); $http_code = explode(" ", $headers[0]); $code = $http_code[1]; $new_headers = array(); foreach ($headers as $header) { if (preg_match("/:/", $header)) { list($name, $value) = explode(": ", $header, 2); $new_headers[$name] = $value; } } return new Auth_Yadis_HTTPResponse($url, $code, $new_headers, $response_body); } }    class Auth_Yadis_XMLParser { function init($xml_string, $namespace_map) { if (!$this->setXML($xml_string)) { return false; } foreach ($namespace_map as $prefix => $uri) { if (!$this->registerNamespace($prefix, $uri)) { return false; } } return true; } function registerNamespace($prefix, $uri) { } function setXML($xml_string) { } function evalXPath($xpath, $node = null) { } function content($node) { } function attributes($node) { } } class Auth_Yadis_domxml extends Auth_Yadis_XMLParser { function Auth_Yadis_domxml() { $this->xml = null; $this->doc = null; $this->xpath = null; $this->errors = array(); } function setXML($xml_string) { $this->xml = $xml_string; $this->doc = @domxml_open_mem($xml_string, DOMXML_LOAD_PARSING, $this->errors); if (!$this->doc) { return false; } $this->xpath = $this->doc->xpath_new_context(); return true; } function registerNamespace($prefix, $uri) { return xpath_register_ns($this->xpath, $prefix, $uri); } function &evalXPath($xpath, $node = null) { if ($node) { $result = @$this->xpath->xpath_eval($xpath, $node); } else { $result = @$this->xpath->xpath_eval($xpath); } if (!$result) { $n = array(); return $n; } if (!$result->nodeset) { $n = array(); return $n; } return $result->nodeset; } function content($node) { if ($node) { return $node->get_content(); } } function attributes($node) { if ($node) { $arr = $node->attributes(); $result = array(); if ($arr) { foreach ($arr as $attrnode) { $result[$attrnode->name] = $attrnode->value; } } return $result; } } } class Auth_Yadis_dom extends Auth_Yadis_XMLParser { function Auth_Yadis_dom() { $this->xml = null; $this->doc = null; $this->xpath = null; $this->errors = array(); } function setXML($xml_string) { $this->xml = $xml_string; $this->doc = new DOMDocument; if (!$this->doc) { return false; } if (!@$this->doc->loadXML($xml_string)) { return false; } $this->xpath = new DOMXPath($this->doc); if ($this->xpath) { return true; } else { return false; } } function registerNamespace($prefix, $uri) { return $this->xpath->registerNamespace($prefix, $uri); } function &evalXPath($xpath, $node = null) { if ($node) { $result = @$this->xpath->query($xpath, $node); } else { $result = @$this->xpath->query($xpath); } $n = array(); if (!$result) { return $n; } for ($i = 0; $i < $result->length; $i++) { $n[] = $result->item($i); } return $n; } function content($node) { if ($node) { return $node->textContent; } } function attributes($node) { if ($node) { $arr = $node->attributes; $result = array(); if ($arr) { for ($i = 0; $i < $arr->length; $i++) { $node = $arr->item($i); $result[$node->nodeName] = $node->nodeValue; } } return $result; } } } global $__Auth_Yadis_defaultParser; $__Auth_Yadis_defaultParser = null; function Auth_Yadis_setDefaultParser(&$parser) { global $__Auth_Yadis_defaultParser; $__Auth_Yadis_defaultParser =& $parser; } function Auth_Yadis_getSupportedExtensions() { return array( 'dom' => array('classname' => 'Auth_Yadis_dom', 'libname' => array('dom.so', 'dom.dll')), 'domxml' => array('classname' => 'Auth_Yadis_domxml', 'libname' => array('domxml.so', 'php_domxml.dll')), ); } function &Auth_Yadis_getXMLParser() { global $__Auth_Yadis_defaultParser; if (isset($__Auth_Yadis_defaultParser)) { return $__Auth_Yadis_defaultParser; } $p = null; $classname = null; $extensions = Auth_Yadis_getSupportedExtensions(); foreach ($extensions as $name => $params) { if (!extension_loaded($name)) { foreach ($params['libname'] as $libname) { if (@dl($libname)) { $classname = $params['classname']; } } } else { $classname = $params['classname']; } if (isset($classname)) { $p = new $classname(); return $p; } } if (!isset($p)) { trigger_error('No XML parser was found', E_USER_ERROR); } else { Auth_Yadis_setDefaultParser($p); } return $p; }     import('core.lib.openid.auth.yadis.XML'); define('SERVICES_YADIS_MATCH_ALL', 101); define('SERVICES_YADIS_MATCH_ANY', 102); define('SERVICES_YADIS_MAX_PRIORITY', pow(2, 30)); define('Auth_Yadis_XMLNS_XRD_2_0', 'xri://$xrd*($v*2.0)'); define('Auth_Yadis_XMLNS_XRDS', 'xri://$xrds'); function Auth_Yadis_getNSMap() { return array('xrds' => Auth_Yadis_XMLNS_XRDS, 'xrd' => Auth_Yadis_XMLNS_XRD_2_0); } function Auth_Yadis_array_scramble($arr) { $result = array(); while (count($arr)) { $index = array_rand($arr, 1); $result[] = $arr[$index]; unset($arr[$index]); } return $result; } class Auth_Yadis_Service { function Auth_Yadis_Service() { $this->element = null; $this->parser = null; } function getTypes() { $t = array(); foreach ($this->getElements('xrd:Type') as $elem) { $c = $this->parser->content($elem); if ($c) { $t[] = $c; } } return $t; } function matchTypes($type_uris) { $result = array(); foreach ($this->getTypes() as $typ) { if (in_array($typ, $type_uris)) { $result[] = $typ; } } return $result; } function getURIs() { $uris = array(); $last = array(); foreach ($this->getElements('xrd:URI') as $elem) { $uri_string = $this->parser->content($elem); $attrs = $this->parser->attributes($elem); if ($attrs && array_key_exists('priority', $attrs)) { $priority = intval($attrs['priority']); if (!array_key_exists($priority, $uris)) { $uris[$priority] = array(); } $uris[$priority][] = $uri_string; } else { $last[] = $uri_string; } } $keys = array_keys($uris); sort($keys); $result = array(); foreach ($keys as $k) { $new_uris = Auth_Yadis_array_scramble($uris[$k]); $result = array_merge($result, $new_uris); } $result = array_merge($result, Auth_Yadis_array_scramble($last)); return $result; } function getPriority() { $attributes = $this->parser->attributes($this->element); if (array_key_exists('priority', $attributes)) { return intval($attributes['priority']); } return null; } function getElements($name) { return $this->parser->evalXPath($name, $this->element); } } function Auth_Yadis_getXRDExpiration($xrd_element, $default=null) { $expires_element = $xrd_element->$parser->evalXPath('/xrd:Expires'); if ($expires_element === null) { return $default; } else { $expires_string = $expires_element->text; $t = strptime($expires_string, "%Y-%m-%dT%H:%M:%SZ"); if ($t === false) { return false; } return mktime($t['tm_hour'], $t['tm_min'], $t['tm_sec'], $t['tm_mon'], $t['tm_day'], $t['tm_year']); } } class Auth_Yadis_XRDS { function Auth_Yadis_XRDS(&$xmlParser, &$xrdNodes) { $this->parser =& $xmlParser; $this->xrdNode = $xrdNodes[count($xrdNodes) - 1]; $this->allXrdNodes =& $xrdNodes; $this->serviceList = array(); $this->_parse(); } function &parseXRDS($xml_string, $extra_ns_map = null) { $_null = null; if (!$xml_string) { return $_null; } $parser = Auth_Yadis_getXMLParser(); $ns_map = Auth_Yadis_getNSMap(); if ($extra_ns_map && is_array($extra_ns_map)) { $ns_map = array_merge($ns_map, $extra_ns_map); } if (!($parser && $parser->init($xml_string, $ns_map))) { return $_null; } $root = $parser->evalXPath('/xrds:XRDS[1]'); if (!$root) { return $_null; } if (is_array($root)) { $root = $root[0]; } $attrs = $parser->attributes($root); if (array_key_exists('xmlns:xrd', $attrs) && $attrs['xmlns:xrd'] != Auth_Yadis_XMLNS_XRDS) { return $_null; } else if (array_key_exists('xmlns', $attrs) && preg_match('/xri/', $attrs['xmlns']) && $attrs['xmlns'] != Auth_Yadis_XMLNS_XRD_2_0) { return $_null; } $xrd_nodes = $parser->evalXPath('/xrds:XRDS[1]/xrd:XRD'); if (!$xrd_nodes) { return $_null; } $xrds = new Auth_Yadis_XRDS($parser, $xrd_nodes); return $xrds; } function _addService($priority, $service) { $priority = intval($priority); if (!array_key_exists($priority, $this->serviceList)) { $this->serviceList[$priority] = array(); } $this->serviceList[$priority][] = $service; } function _parse() { $this->serviceList = array(); $services = $this->parser->evalXPath('xrd:Service', $this->xrdNode); foreach ($services as $node) { $s =& new Auth_Yadis_Service(); $s->element = $node; $s->parser =& $this->parser; $priority = $s->getPriority(); if ($priority === null) { $priority = SERVICES_YADIS_MAX_PRIORITY; } $this->_addService($priority, $s); } } function services($filters = null, $filter_mode = SERVICES_YADIS_MATCH_ANY) { $pri_keys = array_keys($this->serviceList); sort($pri_keys, SORT_NUMERIC); if (!$filters || (!is_array($filters))) { $result = array(); foreach ($pri_keys as $pri) { $result = array_merge($result, $this->serviceList[$pri]); } return $result; } if (!in_array($filter_mode, array(SERVICES_YADIS_MATCH_ANY, SERVICES_YADIS_MATCH_ALL))) { return null; } $filtered = array(); foreach ($pri_keys as $priority_value) { $service_obj_list = $this->serviceList[$priority_value]; foreach ($service_obj_list as $service) { $matches = 0; foreach ($filters as $filter) { if (call_user_func_array($filter, array($service))) { $matches++; if ($filter_mode == SERVICES_YADIS_MATCH_ANY) { $pri = $service->getPriority(); if ($pri === null) { $pri = SERVICES_YADIS_MAX_PRIORITY; } if (!array_key_exists($pri, $filtered)) { $filtered[$pri] = array(); } $filtered[$pri][] = $service; break; } } } if (($filter_mode == SERVICES_YADIS_MATCH_ALL) && ($matches == count($filters))) { $pri = $service->getPriority(); if ($pri === null) { $pri = SERVICES_YADIS_MAX_PRIORITY; } if (!array_key_exists($pri, $filtered)) { $filtered[$pri] = array(); } $filtered[$pri][] = $service; } } } $pri_keys = array_keys($filtered); sort($pri_keys, SORT_NUMERIC); $result = array(); foreach ($pri_keys as $pri) { $result = array_merge($result, $filtered[$pri]); } return $result; } }    import('core.lib.openid.auth.yadis.Misc'); import('core.lib.openid.auth.yadis.Yadis'); import('core.lib.openid.auth.OpenID'); function Auth_Yadis_getDefaultProxy() { return 'http://xri.net/'; } function Auth_Yadis_getXRIAuthorities() { return array('!', '=', '@', '+', '$', '('); } function Auth_Yadis_getEscapeRE() { $parts = array(); foreach (array_merge(Auth_Yadis_getUCSChars(), Auth_Yadis_getIPrivateChars()) as $pair) { list($m, $n) = $pair; $parts[] = sprintf("%s-%s", chr($m), chr($n)); } return sprintf('/[%s]/', implode('', $parts)); } function Auth_Yadis_getXrefRE() { return '/\((.*?)\)/'; } function Auth_Yadis_identifierScheme($identifier) { if (Auth_Yadis_startswith($identifier, 'xri://') || ($identifier && in_array($identifier[0], Auth_Yadis_getXRIAuthorities()))) { return "XRI"; } else { return "URI"; } } function Auth_Yadis_toIRINormal($xri) { if (!Auth_Yadis_startswith($xri, 'xri://')) { $xri = 'xri://' . $xri; } return Auth_Yadis_escapeForIRI($xri); } function _escape_xref($xref_match) { $xref = $xref_match[0]; $xref = str_replace('/', '%2F', $xref); $xref = str_replace('?', '%3F', $xref); $xref = str_replace('#', '%23', $xref); return $xref; } function Auth_Yadis_escapeForIRI($xri) { $xri = str_replace('%', '%25', $xri); $xri = preg_replace_callback(Auth_Yadis_getXrefRE(), '_escape_xref', $xri); return $xri; } function Auth_Yadis_toURINormal($xri) { return Auth_Yadis_iriToURI(Auth_Yadis_toIRINormal($xri)); } function Auth_Yadis_iriToURI($iri) { if (1) { return $iri; } else { return preg_replace_callback(Auth_Yadis_getEscapeRE(), 'Auth_Yadis_pct_escape_unicode', $iri); } } function Auth_Yadis_XRIAppendArgs($url, $args) { if (count($args) == 0) { return $url; } if (array_key_exists(0, $args) && is_array($args[0])) { } else { $keys = array_keys($args); sort($keys); $new_args = array(); foreach ($keys as $key) { $new_args[] = array($key, $args[$key]); } $args = $new_args; } if (strpos(rtrim($url, '?'), '?') !== false) { $sep = '&'; } else { $sep = '?'; } return $url . $sep . Auth_OpenID::httpBuildQuery($args); } function Auth_Yadis_providerIsAuthoritative($providerID, $canonicalID) { $lastbang = strrpos($canonicalID, '!'); $p = substr($canonicalID, 0, $lastbang); return $p == $providerID; } function Auth_Yadis_rootAuthority($xri) { $root = null; if (Auth_Yadis_startswith($xri, 'xri://')) { $xri = substr($xri, 6); } $authority = explode('/', $xri, 2); $authority = $authority[0]; if ($authority[0] == '(') { $root = substr($authority, 0, strpos($authority, ')') + 1); } else if (in_array($authority[0], Auth_Yadis_getXRIAuthorities())) { $root = $authority[0]; } else { $_segments = explode("!", $authority); $segments = array(); foreach ($_segments as $s) { $segments = array_merge($segments, explode("*", $s)); } $root = $segments[0]; } return Auth_Yadis_XRI($root); } function Auth_Yadis_XRI($xri) { if (!Auth_Yadis_startswith($xri, 'xri://')) { $xri = 'xri://' . $xri; } return $xri; } function Auth_Yadis_getCanonicalID($iname, $xrds) { $xrd_list = array_reverse($xrds->allXrdNodes); $parser =& $xrds->parser; $node = $xrd_list[0]; $canonicalID_nodes = $parser->evalXPath('xrd:CanonicalID', $node); if (!$canonicalID_nodes) { return false; } $canonicalID = $canonicalID_nodes[0]; $canonicalID = Auth_Yadis_XRI($parser->content($canonicalID)); $childID = $canonicalID; for ($i = 1; $i < count($xrd_list); $i++) { $xrd = $xrd_list[$i]; $parent_sought = substr($childID, 0, strrpos($childID, '!')); $parentCID = $parser->evalXPath('xrd:CanonicalID', $xrd); if (!$parentCID) { return false; } $parentCID = Auth_Yadis_XRI($parser->content($parentCID[0])); if (strcasecmp($parent_sought, $parentCID)) { return false; } $childID = $parent_sought; } $root = Auth_Yadis_rootAuthority($iname); if (!Auth_Yadis_providerIsAuthoritative($root, $childID)) { return false; } return $canonicalID; }     import('core.lib.openid.auth.yadis.XRDS'); import('core.lib.openid.auth.yadis.XRI'); class Auth_Yadis_ProxyResolver { function Auth_Yadis_ProxyResolver(&$fetcher, $proxy_url = null) { $this->fetcher =& $fetcher; $this->proxy_url = $proxy_url; if (!$this->proxy_url) { $this->proxy_url = Auth_Yadis_getDefaultProxy(); } } function queryURL($xri, $service_type = null) { $qxri = substr(Auth_Yadis_toURINormal($xri), 6); $hxri = $this->proxy_url . $qxri; $args = array( '_xrd_r' => 'application/xrds+xml' ); if ($service_type) { $args['_xrd_t'] = $service_type; } else { $args['_xrd_r'] .= ';sep=false'; } $query = Auth_Yadis_XRIAppendArgs($hxri, $args); return $query; } function query($xri, $service_types, $filters = array()) { $services = array(); $canonicalID = null; foreach ($service_types as $service_type) { $url = $this->queryURL($xri, $service_type); $response = $this->fetcher->get($url); if ($response->status != 200 and $response->status != 206) { continue; } $xrds = Auth_Yadis_XRDS::parseXRDS($response->body); if (!$xrds) { continue; } $canonicalID = Auth_Yadis_getCanonicalID($xri, $xrds); if ($canonicalID === false) { return null; } $some_services = $xrds->services($filters); $services = array_merge($services, $some_services); } return array($canonicalID, $services); } }     import('core.lib.openid.auth.yadis.PlainHTTPFetcher'); import('core.lib.openid.auth.yadis.ParranoidHTTPFetcher'); import('core.lib.openid.auth.yadis.ParseHTML'); import('core.lib.openid.auth.yadis.XRDS'); define('Auth_Yadis_CONTENT_TYPE', 'application/xrds+xml'); define('Auth_Yadis_HEADER_NAME', 'X-XRDS-Location'); class Auth_Yadis_DiscoveryResult { var $request_uri = null; var $normalized_uri = null; var $xrds_uri = null; var $xrds = null; var $content_type = null; var $response_text = null; var $failed = false; function Auth_Yadis_DiscoveryResult($request_uri) { $this->request_uri = $request_uri; } function fail() { $this->failed = true; } function isFailure() { return $this->failed; } function services() { if ($this->xrds) { return $this->xrds->services(); } return null; } function usedYadisLocation() { return $this->normalized_uri != $this->xrds_uri; } function isXRDS() { return ($this->usedYadisLocation() || $this->content_type == Auth_Yadis_CONTENT_TYPE); } } function Auth_Yadis_getServiceEndpoints($input_url, $xrds_parse_func, $discover_func=null, $fetcher=null) { if ($discover_func === null) { $discover_function = array('Auth_Yadis_Yadis', 'discover'); } $yadis_result = call_user_func_array($discover_func, array($input_url, $fetcher)); if ($yadis_result === null) { return array($input_url, array()); } $endpoints = call_user_func_array($xrds_parse_func, array($yadis_result->normalized_uri, $yadis_result->response_text)); if ($endpoints === null) { $endpoints = array(); } return array($yadis_result->normalized_uri, $endpoints); } class Auth_Yadis_Yadis { function getHTTPFetcher($timeout = 20) { if (Auth_Yadis_Yadis::curlPresent() && (!defined('Auth_Yadis_CURL_OVERRIDE'))) { $fetcher = new Auth_Yadis_ParanoidHTTPFetcher($timeout); } else { $fetcher = new Auth_Yadis_PlainHTTPFetcher($timeout); } return $fetcher; } function curlPresent() { return function_exists('curl_init'); } function _getHeader($header_list, $names) { foreach ($header_list as $name => $value) { foreach ($names as $n) { if (strtolower($name) == strtolower($n)) { return $value; } } } return null; } function _getContentType($content_type_header) { if ($content_type_header) { $parts = explode(";", $content_type_header); return strtolower($parts[0]); } } function discover($uri, &$fetcher, $extra_ns_map = null, $timeout = 20) { $result = new Auth_Yadis_DiscoveryResult($uri); $request_uri = $uri; $headers = array("Accept: " . Auth_Yadis_CONTENT_TYPE . ', text/html; q=0.3, application/xhtml+xml; q=0.5'); if ($fetcher === null) { $fetcher = Auth_Yadis_Yadis::getHTTPFetcher($timeout); } $response = $fetcher->get($uri, $headers); if (!$response || ($response->status != 200 and $response->status != 206)) { $result->fail(); return $result; } $result->normalized_uri = $response->final_url; $result->content_type = Auth_Yadis_Yadis::_getHeader( $response->headers, array('content-type')); if ($result->content_type && (Auth_Yadis_Yadis::_getContentType($result->content_type) == Auth_Yadis_CONTENT_TYPE)) { $result->xrds_uri = $result->normalized_uri; } else { $yadis_location = Auth_Yadis_Yadis::_getHeader( $response->headers, array(Auth_Yadis_HEADER_NAME)); if (!$yadis_location) { $parser = new Auth_Yadis_ParseHTML(); $yadis_location = $parser->getHTTPEquiv($response->body); } if ($yadis_location) { $result->xrds_uri = $yadis_location; $response = $fetcher->get($yadis_location); if ((!$response) || ($response->status != 200 and $response->status != 206)) { $result->fail(); return $result; } $result->content_type = Auth_Yadis_Yadis::_getHeader( $response->headers, array('content-type')); } } $result->response_text = $response->body; return $result; } }    class izRender extends Object { public function render(){ $file = $this->getIzPath(); if (is_file($file)) { ob_start(); if (@include($file)){ error_log('Template not found at '.$this->getIzPath()); } foreach ($this->properties() as $render){ if ($render instanceof izRender){ echo '<div class="container">'; echo $render->render(); echo '</div>'; } } return ob_get_clean(); } return false; } public function seoUrlPart( $string ) { if( !defined( 'PROCESS_URI_SEO_MARKER' ) ) return; if( !( $marker = config( 'root.url_seo_marker', PROCESS_URI_SEO_MARKER ) ) ) return; preg_match_all( '/[A-Z0-9_-]/i', str_replace( ' ', '-', strtolower( $string ) ), $match ); return urlencode( str_replace( '--', '-', implode( '', $match[0] ) ) ).$marker; } }   class Integration implements IIntegration { public static function createParticipant($activity, $process_definition_identifier, $performer) { $participant = $component->queryAdapter($activity, $process_definition_identifier + '.' + $performer); if (is_null($participant)) $participant = $component->getAdapter($activity, '.' + $performer); return $participant; } public static function createWorkItem($participant, $process_definition_identifier, $application) { $workitem = $component->queryAdapter($participant, $process_definition_identifier + '.' + $application); if (is_null($workitem)) $workitem = $component->getAdapter($participant, '.' + $application); return $workitem; } }   class AttributeIntegration extends Object implements IIntegration { public function createParticipant($activity, $process_uuid, $performer) { $properties = $this->properties(); $name = $properties[$performer.'_participant']; $performerParticipant = new $name($activity); return $performerParticipant; } public function createWorkItem($participant, $process_uuid, $application, $id = null) { $properties = $this->properties(); $name = $properties[$application.'_workitem']; $applicationWorkItem = new $name($participant, $id); return $applicationWorkItem; } }   interface IIntegration{ public function createParticipant($activity, $process_definition_identifier, $performer); public function createWorkItem($participant, $process_definition_identifier, $application); } interface IProcessDefinition{ public function defineActivities($activities); public function defineTransitions($transitions); public function defineParticipants($participants); public function defineApplications($applications); public function defineParameters($parameters); } interface IActivityDefinition{ public function addApplication($parameters); public function definePerformer($performer); public function andSplit($setting); public function andJoin($setting); } interface ITransitionDefinition{ } interface IProcess{ } interface IProcessContext{ public function processFinished($process, $results); } interface IActivity{ public function workItemFinished($work_item, $results); } interface IApplicationDefinition{ } interface IParameterDefinition{ } interface IParticipantDefinition{ } interface IParticipant{ } interface IWorkItem{ public function start(); } interface IProcessStarted{ } interface IProcessFinished{ } interface IWorkItemStorage { public function pop($workitem); public function push($workitem); public function isEmpty($activity_id, $process_uuid); public function asArray($activity_id, $process_uuid); } interface IActivityStorage { public function push($activity); public function isEmpty(); } interface IWorkflowData { public function setAttr($name, $value); public function getAttr($name); public function dataAsArray(); } class InvalidProcessDefinition{ public function __construct() { } } class ProcessError{ public function __construct() { } }    class TransitionDefinition implements ITransitionDefinition{ public $id = null; public $name = null; public $description = null; public $from = null; public $to = null; public $condition = null; public function __construct($from, $to, $condition = null, $id = null, $name= null) { $this->id = $id; $this->from = $from; $this->to = $to; $this->condition = $condition; $this->name = $name; $this->description = null; if (is_null($condition)) $this->condition = array(new AlwaysTrue(), 'always_true'); } public function toString() { return "TransitionDefinition(from={$this->from}, to={$this->to})"; } } class ProcessDefinition implements IProcessDefinition{ public $id = null; public $name = null; public $description = null; public $integration = null; public $participants = null; public $activities = null; public $applications = null; private $_start = null; public function __construct($id, $integration = null){ $this->id = $id; $this->integration = $integration; $this->activities = array(); $this->transitions = array(); $this->applications = array(); $this->participants = array(); $this->parameters = array(); $this->description = null; } public function toString(){ return "ProcessDefinition ({$this->id})"; } public function defineActivities($activities) { $this->_dirty(); foreach ($activities as $id=>$activity) { $activity->id = $id; if ($activity->name == null) $activity->name = $this->id + '.' + $id; $activity->process = $this; $this->activities[$id] = $activity; } } public function defineTransitions($transitions) { $this->_dirty(); $this->transitions = array_merge($this->transitions, $transitions); $activities = $this->activities; foreach ($transitions as $transition) { $activities[$transition->from]->transitionOutgoing($transition); $activities[$transition->to]->incoming[] = $transition; } } public function defineApplications($applications) { foreach ($applications as $id=>$application) { $application->id = $id; $this->applications[$id] = $application; } } public function defineParticipants($participants) { foreach ($participants as $id=>$participant) { $participant->id = $id; $this->participants[$id] = $participant; } } public function defineParameters($parameters) { foreach ($parameters as $parameter) { $this->parameters[] = $parameter; } } private function _start() { $activities = $this->activities; $start = array(); foreach ($activities as $id=>$activity) { if (empty($activity->incoming)) { $start[] = array($id, $activity); if (empty($activity->outgoing)) { throw new Exception("Activity $id has no transitions"); } } } if (($count = count($start)) != 1) { if ($count > 1) { $errorMsg = "Multiple start activities"; throw new Exception($errorMsg); return false; }else{ $errorMsg = "No start activities"; throw new Exception($errorMsg); return false; } } $this->_start = new TransitionDefinition(null, $start[0][0]); return $this->_start; } private function _dirty() { try{ unset($this->_start); }catch(Exception $e){ } } public function getProcessForContext($context) { if (!@$this->_start) $this->_start(); return new Process($this, $this->_start, $context); } } class ActivityDefinition implements IActivityDefinition{ public $id; public $name; public $description; public $incoming = array(); public $outgoing = array(); public $transition_outgoing = array(); public $explicit_outgoing = array(); public $applications = array(); public $andJoinSetting = false; public $andSplitSetting = false; public $performer = ''; public $process = null; public function __construct($name = null) { $this->name = $name; $this->incoming = $this->outgoing = array(); $this->transition_outgoing = $this->transition_outgoing = array(); $this->applications = array(); $this->andJoinSetting = $this->andSplitSetting = false; $this->description = null; } public function andSplit($setting){ $this->andSplitSetting = $setting; } public function andJoin($setting){ $this->andJoinSetting = $setting; } public function addApplication($application_id, $actual = array()) { $app = $this->process->applications[$application_id]; $formal = $app->parameters; if ( ($count1 = count($formal)) !== ($count2 = count($actual)) ) { $formal_str = print_r($formal, true); $actual_str = print_r($actual, true); $errorMsg = "Wrong number of parameters => Actual={$actual_str}, Formal={$formal_str} for Application {$app->toString()} with id={$app->id}"; throw new Exception($errorMsg); return; } $this->applications[] = array($application_id, $formal, $actual); } public function definePerformer($performer) { $this->performer = $performer; } public function addOutgoing($transition_id) { $this->explicit_outgoing[] = $transition_id; $this->computeOutgoing(); } public function transitionOutgoing($transition) { $this->transition_outgoing[] = $transition; $this->computeOutgoing(); } public function computeOutgoing() { if ($this->explicit_outgoing) { $transitions = array(); foreach ($this->transition_outgoing as $t) { $transtions[$t->id] = $t; } $this->outgoing = array(); foreach($this->explicit_outgoing as $tid) { $transition = $transitions[$tid]; if (!is_null($transtion)){ $this->outgoing[] = $transition; } } }else{ $this->outgoing = $this->transition_outgoing; } } public function toString() { return "<ActivityDefinition {$this->name}>"; } } class Process implements IProcess{ public $uuid; public $definition; public $workflowRelevantData; public $applicationRelevantData; public $startTransition = null; public $nextActivityId = 0; public $process_definition_identifier = null; public $activities = array(); public $context = null; private $_p_changed = false; public function __construct($definition, $start, $context = null) { $this->definition = $definition; $this->process_definition_identifier = $definition->id; $this->startTransition = $start; $this->context = $context; $this->activities = array(); $this->nextActivityId = 0; $this->workflowRelevantData = new WorkflowData(); $this->applicationRelevantData = new WorkflowData(); $this->uuid = new_uuid(); } public function definition1() { } public function start($arguments) { if ($this->activities){ $errorMsg = "Already started"; throw new Exception('Process already started'); return; } $definition = $this->definition; $data = $this->workflowRelevantData; $args = $arguments; foreach ($definition->parameters as $parameter) { if ($parameter->input) { $arg = array_shift($args); $data->setAttr($parameter->name, $arg); } } if (($count1 = count($args)) !== 0){ $expectedCount = count($definition->parameters); $errorMsg = "Too many arguments, expected {$expectedCount}, got {$count1}"; return; } Event::fire('processStarted', new ProcessStarted($this)); $this->transition(null, array($this->startTransition)); } public function outputs() { $outputs = array(); foreach ($this->definition->parameters as $parameter) { if ($parameter->output){ $outputs[$parameter->name] = $this->workflowRelevantData->getAttr($parameter->name); } } return $outputs; } public function finish() { if ($this->context !== null) { $this->context->processFinished($this, $this->outputs()); } Event::fire("processFinished", new ProcessFinished($this)); } public function transition($activity, $transitions) { if (! empty($transitions)) { $definition = $this->definition; foreach ($transitions as $transition) { $activity_definition = $definition->activities[$transition->to]; $next = null; if ($activity_definition->andJoinSetting) { foreach ($this->activities as $i=>$a){ if ($a->activity_definition_identifier == $transition->to){ $next = $a; break; } } } if (is_null($next)) { $this->nextActivityId += 1; $next = new Activity($this, $activity_definition, $this->nextActivityId); } Event::fire('transition', new Transition($activity, $next)); $this->activities[$next->id] = $next; $next->start($transition); } Event::fire('processUpdated', $this); } if ($activity !== null) { izlog("[process/transition] Removing activity {$activity->definition->id} ({$activity->id})"); unset($this->activities[$activity->id]); if (empty($this->activities)) $this->finish(); Event::fire("processUpdated", $this); } $this->_p_changed = true; } public function toString() { return "Process({$this->process_definition_identifier})"; } } class WorkflowData implements IWorkflowData{ private $data = array(); public function setAttr($name, $value) { $this->data[$name] = $value; } public function getAttr($name) { return $this->data[$name]; } public function dataAsArray() { return $this->data; } } class ProcessStarted implements IProcessStarted{ public $process = null; public function __construct($process) { $this->process = $process; } public function toString(){ return "ProcessStarted({$this->process->toString()})"; } } class ProcessFinished implements IProcessFinished{ public $process = null; public function __construct($process) { $this->process = $process; } public function toString(){ return "ProcessFinished({$this->process->toString()})"; } } class Activity implements IActivity{ public $id; public $definition; public $process = null; public $process_uuid = null; public $activity_definition_identifier = null; public $workitems = null; public $incoming = array(); public function __construct($process, $definition, $id) { $this->id = $id; $this->process = $process; $this->process_uuid = $process->uuid; $this->activity_definition_identifier = $definition->id; $this->definition = $definition; $this->workitems = new WorkItemArrayStorage($this); $integration = $process->definition->integration; $workitems = array(); if (count($definition->applications)>0) { $participant = $integration->createParticipant($this, $process->uuid, $definition->performer); $i = 0; foreach ($definition->applications as $app) { $application_id = $app[0]; $formal = $app[1]; $actual = $app[2]; $i += 1; $workitem = $integration->createWorkItem($participant, $process->uuid, $application_id, $i); $workitem->id = strval($i); $this->workitems->push(array($workitem, $application_id, $formal, $actual)); izlog("[activity/__construct] Creating workitem for activity {$this->id}"); Event::fire("workItemCreated", $workitem); } } } public function getDefinition() { return $this->process->definition->activities[$this->activity_definition_identifier]; } public function start($transition) { $definition = $this->getDefinition(); if ($definition->andJoinSetting) { foreach($this->incoming as $t) { if ($t == $transition) { $errorMsg = "Repeated incoming while waiting for and completion"; throw new Exception($errorMsg); return; } } $this->incoming[] = $transition; if (count($this->incoming) < count($definition->incoming)) return; } Event::fire('activityStarted', new ActivityStarted($this)); $workitems = $this->workitems->asArray($this->id, $this->process->uuid); if (!empty($workitems)) { foreach ($workitems as $k=>$w) { $workitem = $w[0]; $app = $w[1]; $formal = $w[2]; $actual = $w[3]; $args = array(); $zip = pyzip($formal, $actual); foreach ($zip as $z) { $parameter = $z[0]; $name = $z[1]; if ($parameter->input) { $args[] = $this->process->workflowRelevantData->getAttr($name); } } Event::fire("workItemStarted", new WorkItemStarted($workitem, $app, $args)); $workitem->start($args); } }else{ $this->finish(); } } public function workItemFinished($work_item, $results = array()) { $popWorkItem = $this->workitems->pop($work_item); $unused = $popWorkItem[0]; $application_id = $popWorkItem[1]; $formal = $popWorkItem[2]; $actual = $popWorkItem[3]; $res = $results; $zip = pyzip($formal, $actual); foreach ($zip as $z) { $parameter = $z[0]; $name = $z[1]; if ($parameter->output){ $v = array_shift($res); $this->process->workflowRelevantData->setAttr($name, $v); } } if (!empty($res)) throw new Exception("Too many results"); Event::fire("workItemFinished", new WorkItemFinished($work_item, $application_id, $actual, $results)); if ($this->workitems->isEmpty()) $this->finish(); } public function finish() { Event::fire('activityFinished', new ActivityFinished($this)); $definition = $this->getDefinition(); $transitions = array(); foreach ($definition->outgoing as $transition) { $condition = call_user_func_array( $transition->condition, array($this->process->workflowRelevantData)); if ($condition) { $transitions[] = $transition; if (! $definition->andSplitSetting) { break; } } } $this->process->transition($this, $transitions); } public function toString() { return "Activity ({$this->process->process_definition_identifier}.{$this->activity_definition_identifier})"; } } class WorkItemStarted{ public $workitem = null; public $application_id = null; public $parameters = null; public function __construct($workitem, $application, $parameters) { $this->workitem = $workitem; $this->application_id = $application; $this->parameters = $parameters; } public function toString() { return "WorkItemStarted({$this->application_id})"; } } class WorkItemFinished{ public $workitem = null; public $application_id = null; public $parameters = null; public $results = null; public function __construct($workitem, $application, $parameters, $results) { $this->workitem = $workitem; $this->application_id = $application; $this->parameters = $parameters; $this->results = $results; } public function toString() { return "WorkItemFinished({$this->application_id})"; } } class Transition{ public function __construct($from, $to) { $this->from = $from; $this->to = $to; } public function toString() { $from = (is_null($this->from))?"None":$this->from->toString(); $to = (is_null($this->to))?"None":$this->to->toString(); return "Transition({$from},{$to})"; } } class ActivityFinished{ public $activity = null; public function __construct($activity) { $this->activity = $activity; } public function toString() { return "ActivityFinished({$this->activity->toString()})"; } } class ActivityStarted{ public $activity = null; public function __construct($activity) { $this->activity = $activity; } public function toString() { return "ActivityStarted({$this->activity->toString()})"; } } class Parameter implements IParameterDefinition{ public $name; public $input; public $output; public function __construct($name) { $this->name = $name; $this->input = $this->output = false; } } class OutputParameter extends Parameter{ public function __construct($name) { parent::__construct($name); $this->output = true; } } class InputParameter extends Parameter{ public function __construct($name) { parent::__construct($name); $this->input = true; } } class InputOutputParameter extends Parameter{ public function __construct() { $this->input = true; $this->output = true; } } class Application implements IApplicationDefinition{ public $name = null; public $description = null; public $parameters = null; public function __construct($parameters = null) { $this->parameters = $parameters; } public function defineParameters($parameters) { foreach ($parameters as $parameter) { $this->parameters[] = $parameter; } } public function toString() { $input = $output = array(); foreach ($this->parameters as $p) { if ($p->input == true) $input[] = $p->name; elseif ($p->output == true) $output[] = $p->name; } $input = implode(',', $input); $output = implode(',', $output); return "<Application {$this->name}: ($input) --> ($output)>"; } } class Participant implements IParticipantDefinition{ public $name; public $description; public function __construct($name = null) { $this->name = $name; $this->description = null; } public function toString() { return "Participant({$this->name})"; } } class izParticipant implements IParticipant{ public $activity = null; public $user = null; public $name = null; public $description = null; public function __construct($activity = null) { $this->activity = $activity; } } class AlwaysTrue { public function always_true($wrd) { return true; } } class WorkItemArrayStorage implements IWorkItemStorage{ public $activity = null; private $workitems = null; public function __construct($activity) { $this->activity = $activity; $this->workitems = array(); } public function pop($workitem) { if (!$this->isEmpty()) { $workitem = $this->workitems[$workitem->id]; unset($this->workitems[$workitem[0]->id]); return $workitem; } return null; } public function get($workitem_id) { if (array_key_exists($workitem_id, $this->workitems)) return $this->workitems[$workitem_id]; else return null; } public function push($workitem) { $this->workitems[$workitem[0]->id] = $workitem; } public function isEmpty($activity_id = null, $process_uuid = null) { return empty($this->workitems); } public function asArray($activity_id = null, $process_uuid = null) { return $this->workitems; } public function __desconstruct() { $this->activity = null; $this->workitems = null; } } class ActivityArrayStorage implements IActivityStorage { public $activities; public function push($activity) { } public function isEmpty() { } } function pyzip($arr1, $arr2) { if (!is_array($arr1) || !is_array($arr2)) return array(); $len1 = count($arr1); $len2 = count($arr2); $minlen = ($len1<$len2)?$len1:$len2; $zip = array(); for ($i = 0; $i < $minlen; $i ++) { $zip[] = array($arr1[$i], $arr2[$i]); } return $zip; }   ?>